<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>音视频自动播放</title>
      <link href="/2023/05/20/AutomaticPlayback/"/>
      <url>/2023/05/20/AutomaticPlayback/</url>
      
        <content type="html"><![CDATA[<p>前端音视频自动播放一直都是一个玄学问题</p><p>无论是 B 站还是抖音，都可以实现打开视频自动播放，但是在我写的页面中就不行</p><p>无论是使用<code>autoplay</code>还是 js 调用<code>play</code>方法都不能实现</p><p>后来了解到一个相关知识——浏览器自动播放策略<br>以谷歌为例<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E7%AD%96%E7%95%A5.jpg" alt="自动播放策略"></p><p>也很容易理解，避免恶意广告之类的东西打扰到用户嘛</p><p>要实现浏览器自动播放也不是完全不允许<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6.jpg" alt="自动播放前提条件"></p><p>这里提到一个叫做媒体参与度的东西<br>特意去查了相关资料<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/%E5%AA%92%E4%BD%93%E5%8F%82%E4%B8%8E%E5%BA%A60.jpg" alt="媒体参与度"></p><p>下面是我的媒体参与度指数<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/%E5%AA%92%E4%BD%93%E5%8F%82%E4%B8%8E%E5%BA%A6.jpg"></p><p>可以看到B站的指数是 0.88 而常用开发地址 localhost:52330 只有0.2</p><p>我也尝试寻找相关方法修改这个指数，结果很明显，这玩意儿是不可修改的</p><p>那只有退而求其次，这里提供两个解决方案</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.jpg" alt="解决方案"></p><p>方案一：引导用户进行交互操作，进而播放<br>这里是通过添加一个播放按钮来实现的</p><pre><code>&lt;div&gt;    &lt;video src=&quot;test.mp4&quot; autoplay&gt;&lt;/video&gt;    &lt;div class=&quot;modal&quot;&gt;        &lt;button class=&quot;play&quot;&gt;开始播放&lt;/button&gt;    &lt;/div&gt;&lt;/div&gt;    &lt;script&gt;        // 方案一：互动后播放        const vdo = document.querySelector(&#39;video&#39;);        const modal = document.querySelector(&#39;modal&#39;);        const btn = document.querySelector(&#39;btn&#39;);        async function palay() &#123;            try &#123;                await vdo.play();                modal.style.display = &#39;none&#39;;                btn.removeEventListener(&#39;click&#39;, play);            &#125; catch (err) &#123;                modal.style.display = &#39;flex&#39;;                btn.addEventListener(&#39;click&#39;, play);            &#125;        &#125;        play()    &lt;/script&gt;</code></pre><p>方案二：静音播放，根据条件判断是否打开声音</p><pre><code>&lt;div&gt;    &lt;video src=&quot;test.mp4&quot; autoplay&gt;&lt;/video&gt;    &lt;div class=&quot;modal&quot;&gt;        &lt;button class=&quot;play&quot;&gt;打开声音&lt;/button&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 方案二：互动后出声    const vdo = document.querySelector(&#39;video&#39;);    const modal = document.querySelector(&#39;modal&#39;);    const btn = document.querySelector(&#39;btn&#39;);    function play()&#123;        vdo.muted = true ;  //静音        vdo.play();        const ctx = new AudioContext();        const canAutoPlay = ctx.state === &#39;running&#39;;        ctx.close();        if(canAutoPlay)&#123;            vdo.muted = false;            modal.style.display = &#39;none&#39;;            btn.removeEventListener(&#39;click&#39;,play);        &#125;else&#123;            modal.style.display = &#39;flex&#39;;            btn.addEventListener(&#39;click&#39;,play);        &#125;    &#125;    play()    &lt;/script&gt;</code></pre><p>解释下方案二<br>这里用<code>AudioContext</code>来创建了一个音频上下文<br>通过判断<code>AudioContext.state</code>的值来判断当前状态<br> <em><code>AudioContext.state</code></em> 有三个返回值</p><ul><li>suspended： audio 被阻塞了</li><li>running：audio 正常运行</li><li>closed：audio 被关闭了</li></ul><p>详情可以查看<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext">mdn AudioContext</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext">mdn AudioContext.state</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用void 0 替代 undefined</title>
      <link href="/2023/05/12/void0/"/>
      <url>/2023/05/12/void0/</url>
      
        <content type="html"><![CDATA[<p>某厂有一条规定：不要直接使用 <em><code>undefined</code></em> 关键字，而要使用 <em><code>void 0</code></em> 来替代 <em><code>undefined</code></em> </p><p>起初看到这个规定是很不理解的<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/%E7%96%91%E6%83%91.jpg" alt="疑惑"><br>为什么会有这么奇葩的规定</p><p>众所周知，定义变量的时候，像关键字：<code>null</code>、<code>true</code>、<code>false</code>都是不能定义的<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/0.jpg"><br>但是 <code>undefined</code> 可以直接定义<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/undefined.jpg"><br>因为<code>undefined</code>不是一个关键字，它只是全局对象<code>window</code>中的一个属性<br><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/undefinedInWindow.jpg"><br>这就意味着可以直接定义一个变量名为<code>undefined</code>，并且重新赋值<br>这并不意味着就能直接修改<code>undefined</code>的值，相反<code>undefined</code>虽然是window的一个属性，但是这个属性是只读的，并不能更改</p><p>这样问题又来了，既然无法更改，为什么又会有这样一条规定</p><p>看下面这个代码</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/other/1.jpg"></p><p>也就是说，在函数内部声明一个名为<code>undefined</code>的变量是可以的，并且可以对它重新赋值</p><p>虽然这种情况几乎不可能发生，可能某厂也是担心<code>undefined</code>会带来的一些安全隐患吧</p><p>而他们使用的规避方法就是使用 <em><code>void 0</code></em> 而不是直接使用 <em><code>undefined</code></em></p><p>那 <em><code>void 0</code></em> 是什么意思呢？</p><p>首先 <code>void</code> 是个关键字，它后面可以跟一个表达式，无论表达式是什么，最终整个表达式返回一个 <code>undefined</code><br>也就是说写 <code>void 0</code>和 <code>void 3.1415926</code><br>返回结果是一样的</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是怎么看待代码</title>
      <link href="/2023/04/23/aboutCode/"/>
      <url>/2023/04/23/aboutCode/</url>
      
        <content type="html"><![CDATA[<p>有人问我，你是怎么看待代码这件事的？<br>关于我是怎么看待代码这件事的……</p><hr><p>比如说有一个数组</p><p><code>const arr = [1,2,3,4]</code></p><p>需求：将<code>arr</code>的每个值翻倍，并保存到新数组，打印新数组<br>需求很简单，代码实现起来也很简单</p><pre><code>for(let i = 0; i &lt; arr.length; i++)&#123;const newItem = arr[i] * 2newArr.push(newItem)&#125;console.log(newArr)</code></pre><p>需求就实现了。然后可能会觉得将来会进行多次这样的操作，所以为了避免重复代码，也就需要把这个流程给它封装到一个函数里面去，实现同样的功能</p><pre><code>function print()&#123;for(let i = 0; i &lt; arr.length ; i++)&#123;const newItem = arr[i] * 2newArr.push(newItem)&#125;console.log(newArr)&#125;</code></pre><p>于是，我们需要的时候就可以调用这个<strong>函数</strong><code>print()</code>，启动这个<strong>流程</strong>，从而得到相同的结果</p><p><strong>函数的本质，就是流程的封装！！！</strong></p><p>如果将来同样的需求，但是数组不一样怎么办呢？<br>因此，我希望把这个<strong>流程</strong>的目标修改一下，也就是说不是将固定的某一个数组的值翻倍，而是将某个数组的每个值进行翻倍。<br>这样一来我要完成这个<strong>流程</strong>就缺失了一个必要条件——缺失了一个数组<br>所以，就有了<strong>参数</strong>，<strong>参数</strong>就是我要完成这个流程所缺失的东西</p><pre><code>function print(arr)&#123;for(let i = 0; i &lt; arr.length ; i++)&#123;const newItem = arr[i] * 2newArr.push(newItem)&#125;console.log(newArr)&#125;</code></pre><p>于是，在调用函数的时候，就可以把参数传过去<code>print(arr)</code>，这个函数就变得通用了一些。<br>继续思考，是一定要将每个值进行翻倍吗？<br>答案是不一定的，于是继续对这个函数的功能进行修改，希望它变得更加通用。如果说需求是将数组的每个值翻指定的倍数，那就又缺少了一个必要的条件，即——指定的倍数</p><pre><code>function print(arr,rate)&#123;for(let i = 0; i &lt; arr.length ; i++)&#123;const newItem = arr[i] * ratenewArr.push(newItem)&#125;console.log(newArr)&#125;</code></pre><p>则调用时<code>print(arr,2)</code><br>这个函数变得更加通用了一些<br>继续思考，如果是将来有一天，需求变更为要把原数组的每一项变成一个对象又应该怎么做呢<br>那函数的需求也就随之改变，就是要<strong>将某个数组的每个值变成一个新的值</strong><br>现在，这个函数缺失了什么？<br>除了缺失一个原数组之外，还缺失了什么？还缺失了一个<strong>过程</strong><br>而<code>JavaScript</code>中，<strong>过程就是一个函数</strong></p><p>所以要传一个函数做为参数，姑且将这个参数叫做 <code>how</code></p><pre><code>function print(arr,how)&#123;for(let i = 0; i &lt; arr.length ; i++)&#123;const newItem = how(arr[i])newArr.push(newItem)&#125;console.log(newArr)&#125;</code></pre><p>那么将来我在调用这个函数的时候就会把原数组的某一项传入过去，由这个函数来决定新的一项是什么，我拿到之后保存新数组就可以了<br><code>print(arr,n =&gt; n * 2)</code><br>如果我要得到一个对象呢<br><code>print(arr,n =&gt; (&#123;id:n,name:n&#125;))</code></p><p>看上去好像这个函数变化挺大的，其实它的本质什么都没有变<br>之前缺失了数据，所以呢，要把数据通过参数传过去<br>现在缺失的是过程，所以呢，要把函数作为参数传过去<br>因为<strong>只有函数才能表示一个过程</strong></p><p>继续思考…..</p><p>如果需求继续变更，不再是打印新数组，而是交付新数组</p><pre><code>function print(arr,how)&#123;for(let i = 0; i &lt; arr.length ; i++)&#123;const newItem = how(arr[i])newArr.push(newItem)&#125;return newArr&#125;</code></pre><p>还是很简单就能实现了<br>于是<br><code>const newArray1 = print(arr,n =&gt; n * 2)</code><br><code>const newArray2 = print(arr,n =&gt; (&#123;id:n,name:n&#125;))</code><br>我可以打印新数组<code>console.log(newArray1)</code><br>也可以拿到数组之后直接保存到<strong>localStorage</strong><code>localStorage.setItem(&quot;last&quot;,newArray2 )</code><br>我可以做任何想要做的事情，所以说返回表达的是什么，表达的是做完这件事以后的结果可能会有一些后续的处理，但是后续的处理跟这个函数就没什么关系了，只需要把这个结果交付出去就可以了</p><p>继续思考……</p><p>这个结果就一定是字符串、数字、数组吗？有没有可能是交付一个过程（函数）呢</p><pre><code>unction createMap(arr)&#123;    return function(how)&#123;        for(let i = 0; i &lt; arr.length ; i++)&#123;            const newItem = how(arr[i])            newArr.push(newItem)            &#125;        return newArr    &#125;&#125;</code></pre><p>比如说针对这个数组可能会有很多的映射方式</p><pre><code>const map = createMap(arr) const newArray1 = map(arr,n =&gt; n * 2)const newArray2 = map(arr,n =&gt; (&#123;id:n,name:n&#125;))</code></pre><p>于是整个函数的功能又变化了，他要交付的不是转换后的数组，而是交付一个功能。</p><p>功能是什么？功能就是一件事。<br>一件事是什么？一件事就是一个函数。</p><p>有区别吗？<br>其实没多大区别，之前要返回的是一个数组，所以说返回了一个数组<br>现在调用这个函数要的是一个功能，所以说返回了一个功能<br>随着不断的深入，发现这个函数越来越复杂，越来越复杂，但是复杂到头的时候，事情突然变得简单起来了<br>程序就两个东西</p><p><strong>一个是数据，一个是流程</strong></p><p>无论是多复杂的代码，搞来搞去都是在搞这两个东西<br>而这，就是我对代码的看法</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发任务控制</title>
      <link href="/2023/04/09/concurrentTasks/"/>
      <url>/2023/04/09/concurrentTasks/</url>
      
        <content type="html"><![CDATA[<p>实现一个批量请求函数 <code>multiRequest()</code>，要求如下：</p><ul><li>要求最大并发数 <code>maxNum</code></li><li>每当有一个请求返回，就留下一个空位，可以增加新的请求</li><li>所有请求完成后，结果按照 <code>urls</code> 里面的顺序依次打出</li></ul><p>这道题目我想很多人应该都或多或少都有见过，那符合这个题目的需求的场景都有哪些呢？</p><p>假设现在有这么一种场景：现有 30 个异步请求需要发送，但由于某些原因，我们必须将同一时刻并发请求数量控制在 5 个以内，同时还要尽可能快速的拿到响应结果。<br>应该怎么做？</p><p>前天又遇到了，这里放出我的解决方法</p><p>现有条件是</p><ul><li>需要一个最大并发数 <code>maxNum</code></li><li>还需要一个变量（为了监听正在运行的任务数量） <code>runningCount</code></li><li>一个任务列表 <code>tasks</code></li></ul><p>首先创建一个函数，这个函数主要为了添加任务，添加之后需要返回一个<code>Promise</code></p><pre><code>add(task) &#123;    return new Promise((resolve, reject) =&gt; &#123;        this.tasks.push(&#123;            task,            resolve,            reject        &#125;)        this._run()    &#125;)&#125;</code></pre><p>我并没有将<code>resolve</code>和<code>reject</code>抛出，因为我其实并不知道这个函数是执行成功还是执行失败，那我现在能调用这个函数吗？很明显是不行的，因为很有可能目前正在运行的任务数量已经达到了我们设置的最大并发数<code>maxNum</code>，这就意味着现在的任务只能等。所以这里能做什么呢？既然不能调用这个任务，那就把这个任务加到一个集合里边，让它等待被调用</p><p>这里写一个辅助函数</p><pre><code>_run() &#123;    while (this.runningCount &lt; this.maxNum &amp;&amp; this.tasks.length) &#123;        const &#123; task, resolve, reject &#125; = this.tasks.shift()        this.runningCount++        task().then(resolve, reject).finally(() =&gt; &#123;                this.runningCount--                    // 递归调用辅助方法                this._run()            &#125;)    &#125;&#125;</code></pre><p>将这些全部封装在一个构造函数里面，创建构造函数实例<br><code>const superTask = new SuperTask()</code></p><p>然后需要一个<code>Promise</code>请求，这里用一个延时函数代替</p><pre><code>function timeout(time) &#123;    return new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve()        &#125;, time)    &#125;)&#125;</code></pre><p>为了测试构造函数的功能，还需要再写一个辅助函数</p><pre><code>function addTask(time, name) &#123;    superTask        add(() =&gt; timeout(time))        .then(() =&gt; &#123;            console.log(`任务$&#123;name&#125;完成`);        &#125;)&#125;</code></pre><p>最后调用测试一下</p><pre><code>addTask(10000, &quot;一&quot;)    // 10000ms 后输出：任务一完成addTask(5000, &quot;二&quot;)     // 5000ms 后输出：任务二完成addTask(2000, &quot;三&quot;)     // 2000ms 后输出：任务三完成addTask(3000, &quot;四&quot;)     // 5000ms 后输出：任务四完成addTask(8000, &quot;五&quot;)     // 13000ms 后输出：任务五完成addTask(6000, &quot;六&quot;)     // 11000ms 后输出：任务六完成addTask(4000, &quot;七&quot;)     // 14000ms 后输出：任务七完成</code></pre><p>也可以按照要求将请求全部放在数组中，然后调用<br>这里只模拟七个请求，主要是懒得 CV 了，本来想只写五个的，不过那好像太少了 😁。（我设置的最大并发数量是 3 个）</p><p>想要实际测试的朋友可以直接取源码进行测试</p><p>代码我放在<a href="https://github.com/ll-zhongyuan/informal-essay/blob/main/fore-end-demo/%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6/%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6.html">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2023/03/27/axios/"/>
      <url>/2023/03/27/axios/</url>
      
        <content type="html"><![CDATA[<p>axios 作为我们工作中的常用的 ajax 请求库，作为前端工程师的我们当然是想一探究竟，axios 究竟是如何去架构整个框架，中间的拦截器、适配器、 取消请求这些都是如何实现的。</p><p>在一个 axios 的实例上有两个拦截器，一个是请求拦截器，一个是响应拦截器。我们先来看下官网上的用法：</p><p>添加拦截器：</p><pre><code>// 添加请求拦截器axios.interceptors.request.use(function (config) &#123;    // 在发送请求之前做些什么    return config;  &#125;, function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error);&#125;);</code></pre><p>移除拦截器：</p><pre><code>const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor);</code></pre><p>在源码中，所有拦截器执行肯定会有一个 forEach 方法。</p><pre><code>export class InterceptorManager &#123;  constructor() &#123;    // 存放所有拦截器的栈    this.handlers = []  &#125;  use(fulfilled, rejected) &#123;    this.handlers.push(&#123;      fulfilled,      rejected,    &#125;)    //返回id 便于取消    return this.handlers.length - 1  &#125;  // 取消一个拦截器  eject(id) &#123;    if (this.handlers[id]) &#123;      this.handlers[id] = null    &#125;  &#125;  // 执行栈中所有的hanlder  forEach(fn) &#123;    this.handlers.forEach((item) =&gt; &#123;      // 这里为了过滤已经被取消的拦截器，因为已经取消的拦截器被置null      if (item) &#123;        fn(item)      &#125;    &#125;)  &#125;&#125;</code></pre><p>这样一来，拦截器的这个类就算初步实现了，接下来我们来实现 axios 这个类。</p><p><strong>axios(config)</strong></p><pre><code>// 发送 POST 请求axios(&#123;  method: &#39;post&#39;,  url: &#39;/user/12345&#39;,  data: &#123;    firstName: &#39;Fred&#39;,    lastName: &#39;Flintstone&#39;  &#125;&#125;);</code></pre><p><strong>axios(url[, config])</strong></p><pre><code>// 发送 GET 请求（默认的方法）axios(&#39;/user/12345&#39;);</code></pre><p>axios 这个类最核心的方法其实还是 request 这个方法。</p><pre><code>class Axios &#123;  constructor(config) &#123;    this.defaults = config    this.interceptors = &#123;      request: new InterceptorManager(),      response: new InterceptorManager(),    &#125;  &#125;  // 发送一个请求  request(config) &#123;    // 这里呢其实就是去处理了 axios(url[,config])    if (typeof config == &#39;string&#39;) &#123;      config = arguments[1] || &#123;&#125;      config.url = arguments[0]    &#125; else &#123;      config = config || &#123;&#125;    &#125;    // 默认get请求，并且都转成小写    if (config.method) &#123;      config.method = config.method.toLowerCase()    &#125; else &#123;      config.method = &#39;get&#39;    &#125;    // dispatchRequest 就是发送ajax请求    const chain = [dispatchRequest, undefined]    //  发生请求之前加入拦截的 fulfille 和reject 函数    this.interceptors.request.forEach((item) =&gt; &#123;      chain.unshift(item.fulfilled, item.rejected)    &#125;)    // 在请求之后增加 fulfilled 和reject 函数    this.interceptors.response.forEach((item) =&gt; &#123;      chain.push(item.fulfilled, item.rejected)    &#125;)    // 利用promise的链式调用，将参数一层一层传下去    let promise = Promise.resolve(config)    //然后我去遍历 chain    while (chain.length) &#123;      // 这里不断出栈 直到结束为止      promise = promise.then(chain.shift(), chain.shift())    &#125;    return promise  &#125;&#125;</code></pre><p><strong>adapter</strong></p><p>Adapter: 英文解释是适配器的意思。adapter 做了一件事非常简单，就是根据不同的环境 使用不同的请求。如果用户自定义了 adapter，就用 config.adapter。否则就是默认是 default.adpter.</p><pre><code>var adapter = config.adapter || defaults.adapter;return adapter(config).then() ...</code></pre><p>继续往下看 deafults.adapter 做了什么事情：</p><pre><code>function getDefaultAdapter() &#123;  var adapter;  if (typeof XMLHttpRequest !== &#39;undefined&#39;) &#123;    // For browsers use XHR adapter    adapter = require(&#39;./adapters/xhr&#39;);  &#125; else if (typeof process !== &#39;undefined&#39; &amp;&amp; Object.prototype.toString.call(process) === &#39;    [object process]&#39;) &#123;    // For node use HTTP adapter    adapter = require(&#39;./adapters/http&#39;);  &#125;  return adapter;&#125;</code></pre><p>其实就是做个选择：如果是浏览器环境：就是用 xhr 否则就是 node 环境。判断 process 是否存在。从写代码的角度来说，axios 源码的这里的设计可扩展性非常好。有点像设计模式中的适配器模式， 因为浏览器端和 node 端 发送请求其实并不一样， 但是我们不重要，我们不去管他的内部实现，用 promise 包一层做到对外统一。所以 我们用 axios 自定义 adapter 器的时候, 一定是返回一个 promise。</p><p><strong>cancleToken</strong></p><p>取消请求原生浏览器是怎么做到的？有一个 abort 方法。可以取消请求。那么 axios 源码肯定也是运用了这一点去取消请求。现在浏览器其实也支持 fetch 请求， fetch 可以取消请求？很多同学说是不可以的，其实不是？fetch 结合 abortController 可以实现取消 fetch 请求。我们看下例子：</p><pre><code>const controller = new AbortController();const &#123; signal &#125; = controller;fetch(&quot;http://localhost:8000&quot;, &#123; signal &#125;)  .then((response) =&gt; &#123;    console.log(`Request 1 is complete!`);  &#125;)  .catch((e) =&gt; &#123;    console.warn(`Fetch 1 error: $&#123;e.message&#125;`);  &#125;);// Wait 2 seconds to abort both requestssetTimeout(() =&gt; controller.abort(), 2000);</code></pre><p>但是这是个实验性功能，可恶的 ie。所以我们这次还是用原生的浏览器 xhr 基于 promise 简单的封装一下。代码如下：</p><pre><code>export function dispatchRequest(config) &#123;  return new Promise((resolve, reject) =&gt; &#123;    const xhr = new XMLHttpRequest();    xhr.open(config.method, config.url);    xhr.onreadystatechange = function () &#123;      if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300 &amp;&amp; xhr.readyState === 4) &#123;        resolve(xhr.responseText);      &#125; else &#123;        reject(&quot;失败了&quot;);      &#125;    &#125;;    if (config.cancelToken) &#123;      // Handle cancellation      config.cancelToken.promise.then(function onCanceled(cancel) &#123;        if (!xhr) &#123;          return;        &#125;        xhr.abort();        reject(cancel);        // Clean up request        xhr = null;      &#125;);    &#125;    xhr.send();  &#125;);&#125;</code></pre><p>Axios 源码里面做了很多处理， 这里我只做了 get 处理，我主要的目的就是为了 axios 是如何取消请求的。先看下官方用法:</p><p>主要是两种用法：</p><p>使用 <em>cancel token</em> 取消请求</p><pre><code>const CancelToken = axios.CancelToken;const source = CancelToken.source();axios  .get(&quot;/user/12345&quot;, &#123;    cancelToken: source.token,  &#125;)  .catch(function (thrown) &#123;    if (axios.isCancel(thrown)) &#123;      console.log(&quot;Request canceled&quot;, thrown.message);    &#125; else &#123;      // 处理错误    &#125;  &#125;);axios.post(  &quot;/user/12345&quot;,  &#123;    name: &quot;new name&quot;,  &#125;,  &#123;    cancelToken: source.token,  &#125;);// 取消请求（message 参数是可选的）source.cancel(&quot;Operation canceled by the user.&quot;);</code></pre><p>还可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token：</p><pre><code>const CancelToken = axios.CancelToken;let cancel;axios.get(&quot;/user/12345&quot;, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    // executor 函数接收一个 cancel 函数作为参数    cancel = c;  &#125;),&#125;);// cancel the requestcancel();</code></pre><p>看了官方用法 和结合 axios 源码：我给出以下实现:</p><pre><code>export class cancelToken &#123;    constructor(exactor) &#123;        if (typeof executor !== &#39;function&#39;) &#123;        throw new TypeError(&#39;executor must be a function.&#39;)        &#125;        // 这里其实将promise的控制权 交给 cancel 函数        // 同时做了防止多次重复cancel 之前 Redux 还有React 源码中也有类似的案列        const resolvePromise;        this.promise =  new Promise(resolve =&gt; &#123;            resolvePromise = resolve;        &#125;)        this.reason = undefined;        const cancel  = (message) =&gt; &#123;            if(this.reason) &#123;                return;            &#125;            this.reason = &#39;cancel&#39; + message;            resolvePromise(this.reason);        &#125;        exactor(cancel)    &#125;    throwIfRequested() &#123;        if(this.reason) &#123;            throw this.reason        &#125;    &#125;    // source 其实本质上是一个语法糖 里面做了封装    static source() &#123;        const cancel;        const token = new cancelToken(function executor(c) &#123;            cancel = c;        &#125;);        return &#123;            token: token,            cancel: cancel        &#125;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人图床</title>
      <link href="/2023/03/15/drawing-bed/"/>
      <url>/2023/03/15/drawing-bed/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是图床"><a href="#什么是图床" class="headerlink" title="什么是图床"></a>什么是图床</h3><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p><p>个人图床其实是互联网中存储图片的空间，作为一个人的云端图片链接</p><h3 id="为什么要图床"><a href="#为什么要图床" class="headerlink" title="为什么要图床"></a>为什么要图床</h3><p> 大部分人写博客都用<code>markdown</code>，而<code>markdown</code>的图片是通过链接的方式进行传输的的，因此，如果是在本电脑上直接嵌入的文件没办法在网络上访问（除非你把电脑长时间开机并且开放~极其危险）。</p><p> 因此一个云图片链接就很有必要了，而网上直接找到的链接不具有可靠性，可能哪天就挂了（自己搭图床也不知道什么时候挂），因此搭建自己的图床还是很有必要的。</p><h3 id="图床种类"><a href="#图床种类" class="headerlink" title="图床种类"></a>图床种类</h3><h4 id="图床分类"><a href="#图床分类" class="headerlink" title="图床分类"></a>图床分类</h4><ul><li>公共图床</li><li>自建图床:云服务(如：七牛云、阿里云oss、腾讯云cos等)</li><li>自建图床:开源方案（如：Lychee、树洞外链）</li></ul><p>目前图床可以分为两种，即公共图床和自建图床</p><p>公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，如微博图床等</p><p>自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛云、Lychee 开源自建图床方案。</p><p>目前自建图床方案有两种，一种是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片，另一种是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。</p><h4 id="图床工具"><a href="#图床工具" class="headerlink" title="图床工具"></a>图床工具</h4><p>虽然图床选择好，但是对普通用户来说，直接使用图床 API 很麻烦，我们可以借助一些工具方便的上传图片，下面就根据 macOS、Windows、Web 分别推荐几款工具。</p><p>macOS：</p><ul><li><a href="https://link.juejin.cn/?target=https://itunes.apple.com/cn/app/id1101244278?ls=1&mt=12">iPic - Markdown 图床、文件上传工具</a></li><li><a href="https://link.juejin.cn/?target=https://zh.mweb.im/">MWeb</a>（Markdown 写作工具，也支持上传图片）</li></ul><p>Windows：</p><ul><li><a href="https://link.juejin.cn/?target=http://mpic.lzhaofu.cn/">MPic-图床神器</a></li></ul><p>Web：</p><ul><li>比如「极简图床」插件、「微博图床」等等</li></ul><h3 id="七牛云图床"><a href="#七牛云图床" class="headerlink" title="七牛云图床"></a>七牛云图床</h3><p>关于七牛云的介绍：七牛是一个云存储服务商，注册并实名认证之后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。七牛的定位不是像百度云一样的网盘 ，也不是同坚果云一般的同步云 ，而是 CDN，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源。对于个人博主来说，你可以把博客中的图片、音频、视频等媒体上传到七牛，在博客中引用；也可以将站点需要加载的 CSS、JS 等文件上传到七牛，以加速网站。</p><ul><li><p>注册七牛云并实名认证</p></li><li><p>注册完成后打开控制管理台&gt;对象存储</p></li><li><p>新建一个公开的空间</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/3.jpg" alt="新建空间"></p></li><li><p>国内常用存储区域对应的编码：</p><ul><li>华东：z0</li><li>华北：z1</li><li>华南：z2</li></ul></li><li><p>秘钥配置</p><p>鼠标移入 控制台的头像 显示下拉列表 找到 秘钥管理</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/4.jpg" alt="密钥配置"></p></li></ul><p>​        注意这里的<code>accessKey</code> 和 <code>secretKey</code></p><ul><li><p>存储空间域名，这里七牛云提供了<code>30天</code>的测试域名，使用测试域名需注意时间</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/6.jpg" alt="存储空间域名"></p></li></ul><p>如果有自己的域名，也可以使用自己的，文章末尾有使用个人域名的相关配置方法</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><ul><li><p>下载Typora，使用<strong>PicGo-Core</strong></p></li><li><p>点击图像设置，进行一些简单的配置，配置如下：</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/1.jpg" alt="typora配置"></p></li><li><p>点击下载<strong>PicGo-Core</strong></p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/2.jpg" alt="下载picgo-core"></p></li><li><p>然后打开配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qiniu&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;qiniu&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>配置：</p><ul><li><strong>accessKey</strong> 秘钥</li><li><strong>secretKey</strong> 秘钥</li><li><strong>bucket</strong> 存储空间名称</li><li><strong>url</strong> 存储空间地址</li><li><strong>area</strong> 存储区域编号</li><li><strong>options</strong> 网站后缀（选填）</li><li><strong>path</strong> 自定义存储路径（选填）</li></ul></li></ul><p>然后使用<strong>CV</strong>大法，将对应配置填入</p><ul><li><p>测试上传</p><ul><li><p>回到偏好设置</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/7.jpg" alt="验证上传">  </p></li><li><p>测试成功如下，如果没有，请检查配置文件是否保存，或者哪个步骤遗漏了</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/8.jpg" alt="测试成功"></p></li></ul></li></ul><h3 id="为七牛云配置个人域名"><a href="#为七牛云配置个人域名" class="headerlink" title="为七牛云配置个人域名"></a>为七牛云配置个人域名</h3><p>这里以腾讯云为例</p><ul><li><p>首先将注册的域名进行备案（需提交资料到相关部门审核，此过程耗时较长，具体以管局审核为准）我的已经通过备案了，这里使用的是二级域名</p></li><li><p>找到七牛云<a href="https://portal.qiniu.com/cdn/domain">域名管理</a>&gt;添加域名</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/10.jpg" alt="添加域名"></p><p>这里没有ssl证书可以选择http（创建完成后在HTTPS<code>配置中开启</code>HTTPS`），然后选择创建</p></li><li><p>创建完成复制<code>CNAME</code>，使用cdn加速服务</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/11.jpg" alt="创建完成"></p></li><li><p>然后返回腾讯云对域名进行解析</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/drawing-bed/9.jpg" alt="域名解析"></p></li><li><p>再返回七牛云对象存储 &gt; 空间管理 &gt; 点击创建的空间 &gt; 文件管理 &gt; 外链域名选择自己创建的域名。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频可视化</title>
      <link href="/2023/02/27/canvas2/"/>
      <url>/2023/02/27/canvas2/</url>
      
        <content type="html"><![CDATA[<p>前几天使用canvas完成了基础绘图，今天来整点活</p><h3 id="最终要实现的效果"><a href="#最终要实现的效果" class="headerlink" title="最终要实现的效果"></a>最终要实现的效果</h3><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/canvas/%E9%9F%B3%E9%A2%91%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" alt="音频可视化效果图"></p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>canvas 生成柱状图</li><li>柱状图不断重新渲染</li></ul><p>简单来说只有这两点需求，好像很简单嘛</p><p>接下来实操：</p><pre><code>// 还是从获取 dom元素，生成 canvas 上下文开始const audioEle = document.querySelector(&#39;audio&#39;)const cvs = document.querySelector(&#39;canvas&#39;)const ctx = cvs.getContext(&#39;2d&#39;)// 初始化 canvas 尺寸 function initCvs() &#123;    cvs.width = window.innerWidth * devicePixelRatio    cvs.height = (window.innerHeight / 1.5) * devicePixelRatio&#125;initCvs()</code></pre><p>然后就是音频</p><ul><li>获取音频（这里直接引入一个本地音频）</li><li>创建音频上下文</li><li>创建音频源节点</li><li>创建分析器节点</li><li>创建数组接受分析器节点的分析数据</li><li>连接音频源节点与分析器节点</li><li>分析器节点连接到输出设备</li><li>绘制 canvas 画布</li></ul><pre><code>let isInit = false   let dataArray, analyseraudioEle.onplay = function () &#123;    //判断音频状态    if (isInit) &#123;        return    &#125;    // 初始化    // 创建音频上下文    const audCtx = new AudioContext()    // 创建音频源节点    const source = audCtx.createMediaElementSource(audioEle)    // 创建分析器节点    analyser = audCtx.createAnalyser()    // 样本的窗口大小 analyser.fftSize 默认值：2048,该数值只能为2的n次幂    analyser.fftSize = 512    // 创建数组，用于接收分析器节点的分析数据    // Uint8Array 类型化数组    dataArray = new Uint8Array(analyser.frequencyBinCount)    // 连接音频源节点与分析器节点    source.connect(analyser)    // 分析器节点连接到输出设备    analyser.connect(audCtx.destination)    isInit = true&#125;// 把分析出的波形不断的绘制到canvas上function draw() &#123;    requestAnimationFrame(draw)    // 清空画布    const &#123; width, height &#125; = cvs    ctx.clearRect(0, 0, width, height)    // 判断音频是否初始化    if (!isInit) &#123;        return    &#125;    // 让分析器节点分析出数据到数组中    analyser.getByteFrequencyData(dataArray)    // console.log(dataArray);    // 获取到数组长度   /2.5放大前半部分图形    const len = dataArray.length / 2.5    // 设置柱状条宽度  /2获得对称图形宽度    const barWidth = width / len / 2    ctx.fillStyle = &#39;#e15252&#39;    // 循环数据进行绘制    for (let i = 0; i &lt; len; i++) &#123;        const data = dataArray[i];  // &lt;256        // 设置柱状条高度        const barHeight = data / 255 * height        // const x = i * barWidth        // 计算横坐标        const x1 = i * barWidth + width / 2        const x2 = width / 2 - (i + 1) * barWidth        // 计算纵坐标        const y = height - barHeight        // 绘制图形 宽度-2 拉开柱状条间距        ctx.fillRect(x1, y, barWidth - 2, barHeight)        ctx.fillRect(x2, y, barWidth - 2, barHeight)    &#125;&#125;draw()</code></pre><p>来看下最终效果图</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/canvas/%E9%9F%B3%E9%A2%91%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" alt="最终效果图"></p><p>因为音频主要频率都在前半段，所以截取前半段并根据y轴镜像生成另一半canvas图</p><p>因为我觉得生成x轴的镜像图太丑了😂，没有生成x轴的镜像图，需要的可以自行添加，有疑问可以联系我😋</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas</title>
      <link href="/2023/02/16/canvas1/"/>
      <url>/2023/02/16/canvas1/</url>
      
        <content type="html"><![CDATA[<p>之前的博客中有个很有意思的画面，如下图</p><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/canvas/0.jpg" alt="博客图片"></p><p>之前是用组件实现的，并没有深入研究，最近也没什么事情，上手操作一下。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/API">canvas mdn 中文文档</a></p><p>英文能力够好的话，建议去看英文文档，毕竟原文档是写的最准确的。中文版难免会出现版本滞后或者是翻译错误的情况。但是不管怎么样，肯定是比平时看的博客专业度什么的要高得多，毕竟别人的东西不一定符合你的业务需求。官方文档才是最准确的知识！</p><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/API">mdn 英文文档</a></p><p>要实现 canvas 基本绘图</p><p>首先要获取绘制上下文</p><p><code> const cvs = document.querySelector(&#39;canvas&#39;)</code></p><p><code>const ctx = cvs.getContext(&#39;2d&#39;)</code></p><p>所有的绘图都必须在上下文中完成</p><p>同一个 canvas 只能产生唯一的上下文</p><p>上下文类型可以是 2d 、 bitmaprenderer 、webgl 、 webgl2、</p><p>一般来说要先初始化设置 canvas 的宽高</p><p><code>cvs.width = window.innerWidth - 50</code></p><p><code>cvs.height = window.innerHeight - 50</code></p><p>这里设置后页面呈现出一个矩形 canvas 区域</p><p>canvas 常用的 api 方法，个人理解，部分理解不一致，详情请参考官方文档 <a href="https://developer.mozilla.org/en-US/docs/Glossary/API">mdn 英文文档</a></p><ul><li>画直线 ：lineTo</li><li>画弧线 ：arc</li><li>清空路径 ： beginPath</li><li>关闭路径 ： closePath</li><li>填充 ： fill</li><li>描边 ： stroke</li></ul><p>根据需求自由组合，这里我们需要生成几个点并连接生成基础图形</p><p>写一个获取随机数的函数，这里最大数和最小数按需求来写</p><pre><code>function getRandom(min, max) &#123;    return Math.floor(Math.random() * (max + 1 - min) + min)&#125;</code></pre><p>封装 canvas 函数</p><pre><code>class Point &#123;        constructor() &#123;            this.r = 6   //设置弧形半径            this.x = getRandom(0, cvs.width - this.r / 2)  //设置横坐标            this.y = getRandom(0, cvs.height - this.r / 2) //设置纵坐标        &#125;        draw() &#123;            ctx.beginPath()            ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI)  // 绘制圆弧路径            ctx.fillStyle = &#39;#fff&#39;// 设置填充样式            ctx.fill()        &#125;    &#125;</code></pre><p>封装图形构造函数</p><pre><code> class Graph &#123;        constructor(pointNumber = 30, maxDis = 300) &#123;  //设置生成数量和最大直线距离            this.points = new Array(pointNumber).fill(0).map(() =&gt; new Point())            this.maxDis = maxDis        &#125;        draw() &#123;            for (let i = 0; i &lt; this.points.length; i++) &#123;                const p1 = this.points[i]                p1.draw()                for (let j = i + 1; j &lt; this.points.length; j++) &#123;                    const p2 = this.points[j]                    const d = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) **   2)  //开根号赋值两点之间的直线距离                    if (d &gt; this.maxDis) &#123;  //判断两点之间直线距离是否超过设置值                        continue                    &#125;                    ctx.beginPath()                    ctx.moveTo(p1.x, p1.y)                    ctx.lineTo(p2.x, p2.y)                    ctx.closePath()                    ctx.strokeStyle = `rgba(200,200,200,$&#123;1 - d / this.maxDis&#125;)`                    ctx.stroke()                &#125;            &#125;        &#125;    &#125;    const g = new Graph()    g.draw()</code></pre><p>这里有了静态 canvas 图形，然后加上部分动画效果</p><pre><code>this.xSpeed = getRandom(-50, 50)    // 设置横向速度(随机)this.ySpeed = getRandom(-50, 50)    // 设置纵向速度(随机)this.lastDrawTime = null    // 记录上次作画的时间// 更新坐标if (this.lastDrawTime) &#123;// 计算新的坐标const duration = (Date.now() - this.lastDrawTime) / 1000// 获取坐标距离const xDis = this.xSpeed * durationconst yDis = this.ySpeed * duration// 计算新的横纵坐标let x = this.x + xDislet y = this.y + yDisif (x &gt; cvs.width - this.r / 2) &#123;x = cvs.width - this.r / 2    this.xSpeed = - this.xSpeed&#125;else if (x &lt; 0) &#123;    x = 0this.xSpeed = - this.xSpeed&#125;if (y &gt; cvs.height - this.r / 2) &#123;    y = cvs.height - this.r / 2    this.ySpeed = - this.ySpeed&#125;else if (y &lt; 0) &#123;    y = 0    this.ySpeed = - this.ySpeed&#125;    this.x = x    this.y = y&#125;</code></pre><p><code>并记录作画时间  this.lastDrawTime = Date.now()  // 记录作画时间</code></p><p>我们需要重复渲染很多次，每次渲染需要重新执行<code>deaw()</code>方法</p><pre><code>requestAnimationFrame(() =&gt; &#123;  // 每次渲染重新执行draw()方法    this.draw()&#125;)ctx.clearRect(0, 0, cvs.width, cvs.height)  // 清空画布</code></pre><p><img src="https://ox.zhongyuan.space/hexo/articleIllustrations/canvas/1.jpg" alt="最终结果图"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue响应式原理</title>
      <link href="/2023/02/01/article32/"/>
      <url>/2023/02/01/article32/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/24/162f71d7977c8a3f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>看过Vue官方文档的同学，对这张图应该已然相当熟悉了。</p><p>vue的响应式是如何实现的？</p><p>听过太多回答，通过<code>Object.defineProperty</code>，可是再详细的问时，对方浑然不知。</p><p>来看下面这段代码</p><pre><code>const Observer = function(data) &#123;  // 循环修改为每个属性添加get set  for (let key in data) &#123;    defineReactive(data, key);  &#125;&#125;const defineReactive = function(obj, key) &#123;  // 局部变量dep，用于get set内部调用  const dep = new Dep();  // 获取当前值  let val = obj[key];  Object.defineProperty(obj, key, &#123;    // 设置当前描述属性为可被循环    enumerable: true,    // 设置当前描述属性可被修改    configurable: true,    get() &#123;      console.log(&#39;in get&#39;);      // 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系      dep.depend();      return val;    &#125;,    set(newVal) &#123;      if (newVal === val) &#123;        return;      &#125;      val = newVal;      // 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，      // 这里每个需要更新通过什么断定？dep.subs      dep.notify();    &#125;  &#125;);&#125;const observe = function(data) &#123;  return new Observer(data);&#125;const Vue = function(options) &#123;  const self = this;  // 将data赋值给this._data，源码这部分用的Proxy所以我们用最简单的方式临时实现  if (options &amp;&amp; typeof options.data === &#39;function&#39;) &#123;    this._data = options.data.apply(this);  &#125;  // 挂载函数  this.mount = function() &#123;    new Watcher(self, self.render);  &#125;  // 渲染函数  this.render = function() &#123;    with(self) &#123;      _data.text;    &#125;  &#125;  // 监听this._data  observe(this._data);  &#125;const Watcher = function(vm, fn) &#123;  const self = this;  this.vm = vm;  // 将当前Dep.target指向自己  Dep.target = this;  // 向Dep方法添加当前Wathcer  this.addDep = function(dep) &#123;    dep.addSub(self);  &#125;  // 更新方法，用于触发vm._render  this.update = function() &#123;    console.log(&#39;in watcher update&#39;);    fn();  &#125;  // 这里会首次调用vm._render，从而触发text的get  // 从而将当前的Wathcer与Dep关联起来  this.value = fn();  // 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，  // 造成代码死循环  Dep.target = null;&#125;const Dep = function() &#123;  const self = this;  // 收集目标  this.target = null;  // 存储收集器中需要通知的Watcher  this.subs = [];  // 当有目标时，绑定Dep与Wathcer的关系  this.depend = function() &#123;    if (Dep.target) &#123;      // 这里其实可以直接写self.addSub(Dep.target)，      // 没有这么写因为想还原源码的过程。      Dep.target.addDep(self);    &#125;  &#125;  // 为当前收集器添加Watcher  this.addSub = function(watcher) &#123;    self.subs.push(watcher);  &#125;  // 通知收集器中所的所有Wathcer，调用其update方法  this.notify = function() &#123;    for (let i = 0; i &lt; self.subs.length; i += 1) &#123;      self.subs[i].update();    &#125;  &#125;&#125;const vue = new Vue(&#123;  data() &#123;    return &#123;      text: &#39;hello world&#39;    &#125;;  &#125;&#125;)vue.mount(); // in getvue._data.text = &#39;123&#39;; // in watcher update /n in get</code></pre><p>这里用不到100行的代码，实现了一个简易的vue响应式。当然，这里如果不考虑期间的过程，我相信，40行代码之内可以搞定。但是我这里不想省略，为什么呢？我怕你把其中的过程自动忽略掉，怕别人问你相关东西的时候，明明自己看过了，却被怼的哑口无言。总之，我是为了你好，多喝热水。</p><h4 id="Dep的作用是什么？"><a href="#Dep的作用是什么？" class="headerlink" title="Dep的作用是什么？"></a>Dep的作用是什么？</h4><p> <code>依赖收集器，这不是官方的名字蛤，我自己起的，为了好记。 </code></p><p>用两个例子来看看依赖收集器的作用吧。</p><ul><li><p>例子1，毫无意义的渲染是不是没必要？</p><pre><code>  const vm = new Vue(&#123;      data() &#123;          return &#123;              text: &#39;hello world&#39;,              text2: &#39;hey&#39;,          &#125;      &#125;  &#125;)</code></pre><p>  当<code>vm.text2</code>的值发生变化时，会再次调用<code>render</code>，而<code>template</code>中却没有使用<code>text2</code>，所以这里处理<code>render</code>是不是毫无意义？</p><p>  针对这个例子还记得我们上面模拟实现的没，在<code>Vue</code>的<code>render</code>函数中，我们调用了本次渲染相关的值，所以，与渲染无关的值，并不会触发<code>get</code>，也就不会在依赖收集器中添加到监听(<code>addSub</code>方法不会触发)，即使调用<code>set</code>赋值，<code>notify</code>中的<code>subs</code>也是空的。OK，继续回归demo，来一小波测试去印证下我说的吧。</p><pre><code>  const vue = new Vue(&#123;    data() &#123;      return &#123;        text: &#39;hello world&#39;,        text2: &#39;hey&#39;      &#125;;    &#125;  &#125;)    vue.mount(); // in get  vue._data.text = &#39;456&#39;; // in watcher update /n in get  vue._data.text2 = &#39;123&#39;; // nothing</code></pre></li><li><p>例子2，多个Vue实例引用同一个data时，通知谁？是不是应该俩都通知？ </p><pre><code>  let commonData = &#123;    text: &#39;hello world&#39;  &#125;;    const vm1 = new Vue(&#123;    data() &#123;      return commonData;    &#125;  &#125;)    const vm2 = new Vue(&#123;    data() &#123;      return commonData;    &#125;  &#125;)    vm1.mount(); // in get  vm2.mount(); // in get  commonData.text = &#39;hey&#39; // 输出了两次 in watcher update /n in get</code></pre></li></ul><p>希望通过这两个例子，你已经大概清楚了<code>Dep</code>的作用，有没有原来就那么回事的感觉？有就对了。总结一下吧(以下依赖收集器实为<code>Dep</code>)：</p><ul><li><code>vue</code>将<code>data</code>初始化为一个<code>Observer</code>并对对象中的每个值，重写了其中的<code>get</code>、<code>set</code>，<code>data</code>中的每个<code>key</code>，都有一个独立的依赖收集器。</li><li>在<code>get</code>中，向依赖收集器添加了监听</li><li>在mount时，实例了一个<code>Watcher</code>，将收集器的目标指向了当前<code>Watcher</code></li><li>在<code>data</code>值发生变更时，触发<code>set</code>，触发了依赖收集器中的所有监听的更新，来触发<code>Watcher.update</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive</title>
      <link href="/2023/01/18/article31/"/>
      <url>/2023/01/18/article31/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>可能大家在平时的开发中会经常遇到这样的场景：有一个可以进行筛选的列表页<code>List.vue</code>，点击某一项时进入相应的详情页面，等到你从详情页返回<code>List.vue</code>时，发现列表页居然刷新了！刚刚的筛选条件都没了！！！</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li><code>keep-alive</code>是一个<code>Vue全局组件</code></li><li><code>keep-alive</code>本身不会渲染出来，也不会出现在父组件链中</li><li><code>keep-alive</code>包裹动态组件时，会缓存不活动的组件，而不是销毁它们</li></ul><h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><p><code>keep-alive</code>接收三个参数：</p><ul><li><code>include</code>：可传<code>字符串、正则表达式、数组</code>，名称匹配成功的组件会被缓存</li><li><code>exclude</code>：可传<code>字符串、正则表达式、数组</code>，名称匹配成功的组件不会被缓存</li><li><code>max</code>：可传<code>数字</code>，限制缓存组件的最大数量</li></ul><p><code>include</code>和<code>exclude</code>，传<code>数组</code>情况居多</p><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><pre><code>&lt;keep-alive :include=&quot;allowList&quot; :exclude=&quot;noAllowList&quot; :max=&quot;amount&quot;&gt;     &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;</code></pre><h4 id="路由组件"><a href="#路由组件" class="headerlink" title="路由组件"></a>路由组件</h4><pre><code>&lt;keep-alive :include=&quot;allowList&quot; :exclude=&quot;noAllowList&quot; :max=&quot;amount&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><p>前面说了，<code>keep-alive</code>是一个<code>Vue全局组件</code>，他接收三个参数：</p><ul><li><code>include</code>：可传<code>字符串、正则表达式、数组</code>，名称匹配成功的组件会被缓存</li><li><code>exclude</code>：可传<code>字符串、正则表达式、数组</code>，名称匹配成功的组件不会被缓存</li><li><code>max</code>：可传<code>数字</code>，限制缓存组件的最大数量，超过<code>max</code>则按照<code>LRU算法</code>进行置换</li></ul><p>顺便说说<code>keep-alive</code>在各个生命周期里都做了啥吧：</p><ul><li><code>created</code>：初始化一个<code>cache、keys</code>，前者用来存缓存组件的虚拟dom集合，后者用来存缓存组件的key集合</li><li><code>mounted</code>：实时监听<code>include、exclude</code>这两个的变化，并执行相应操作</li><li><code>destroyed</code>：删除掉所有缓存相关的东西</li></ul><p>之前说了，<code>keep-alive</code>不会被渲染到页面上，所以<code>abstract</code>这个属性至关重要！</p><pre><code>// src/core/components/keep-alive.jsexport default &#123;  name: &#39;keep-alive&#39;,  abstract: true, // 判断此组件是否需要在渲染成真实DOM  props: &#123;    include: patternTypes,    exclude: patternTypes,    max: [String, Number]  &#125;,  created() &#123;    this.cache = Object.create(null) // 创建对象来存储  缓存虚拟dom    this.keys = [] // 创建数组来存储  缓存key  &#125;,  mounted() &#123;    // 实时监听include、exclude的变动    this.$watch(&#39;include&#39;, val =&gt; &#123;      pruneCache(this, name =&gt; matches(val, name))    &#125;)    this.$watch(&#39;exclude&#39;, val =&gt; &#123;      pruneCache(this, name =&gt; !matches(val, name))    &#125;)  &#125;,  destroyed() &#123;    for (const key in this.cache) &#123; // 删除所有的缓存      pruneCacheEntry(this.cache, key, this.keys)    &#125;  &#125;,  render() &#123;      // 下面讲  &#125;&#125;</code></pre><h3 id="pruneCacheEntry函数"><a href="#pruneCacheEntry函数" class="headerlink" title="pruneCacheEntry函数"></a>pruneCacheEntry函数</h3><p>咱们上面实现的生命周期<code>destroyed</code>中，执行了<code>删除所有缓存</code>这个操作，而这个操作是通过调用<code>pruneCacheEntry</code>来实现的，那咱们来说说<code>pruneCacheEntry</code>里做了啥吧 </p><pre><code>// src/core/components/keep-alive.jsfunction pruneCacheEntry (  cache: VNodeCache,  key: string,  keys: Array&lt;string&gt;,  current?: VNode) &#123;  const cached = cache[key]  if (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;    cached.componentInstance.$destroy() // 执行组件的destory钩子函数  &#125;  cache[key] = null  // 设为null  remove(keys, key) // 删除对应的元素&#125;</code></pre><p>总结一下就是做了三件事：</p><ul><li>1、遍历集合，执行所有缓存组件的<code>$destroy</code>方法</li><li>2、将<code>cache</code>对应<code>key</code>的内容设置为<code>null</code></li><li>3、删除<code>keys</code>中对应的元素</li></ul><h3 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h3><p>以下称<code>include</code>为白名单，<code>exclude</code>为黑名单 </p><p><code>render</code>函数里主要做了这些事：</p><ul><li><p>第一步：获取到<code>keep-alive</code>包裹的第一个组件以及它的<code>组件名称</code></p></li><li><p>第二步：判断此<code>组件名称</code>是否能被<code>白名单、黑名单</code>匹配，如果<code>不能被白名单匹配 || 能被黑名单匹配</code>，则直接返回<code>VNode</code>，不往下执行，如果不符合，则往下执行<code>第三步</code></p></li><li><p>第三步：根据<code>组件ID、tag</code>生成<code>缓存key</code>，并在缓存集合中查找是否已缓存过此组件。如果已缓存过，直接取出缓存组件，并更新<code>缓存key</code>在<code>keys</code>中的位置（这是<code>LRU算法</code>的关键），如果没缓存过，则继续<code>第四步</code></p></li><li><p>第四步：分别在<code>cache、keys</code>中保存<code>此组件</code>以及他的<code>缓存key</code>，并检查数量是否超过<code>max</code>，超过则根据<code>LRU算法</code>进行删除</p></li><li><p>第五步：将此组件实例的<code>keepAlive</code>属性设置为true，这很重要哦，下面会讲到的！</p><pre><code>  // src/core/components/keep-alive.js  render() &#123;    const slot = this.$slots.default    const vnode: VNode = getFirstComponentChild(slot) // 找到第一个子组件对象    const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions    if (componentOptions) &#123; // 存在组件参数      // check pattern      const name: ?string = getComponentName(componentOptions) // 组件名      const &#123; include, exclude &#125; = this      if ( // 条件匹配        // not included        (include &amp;&amp; (!name || !matches(include, name))) ||        // excluded        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) &#123;        return vnode      &#125;      const &#123; cache, keys &#125; = this      const key: ?string = vnode.key == null // 定义组件的缓存key        // same constructor may get registered as different local components        // so cid alone is not enough (#3269)        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#39;&#39;)        : vnode.key      if (cache[key]) &#123; // 已经缓存过该组件        vnode.componentInstance = cache[key].componentInstance        // make current key freshest        remove(keys, key)        keys.push(key) // 调整key排序      &#125; else &#123;        cache[key] = vnode // 缓存组件对象        keys.push(key)        // prune oldest entry        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; // 超过缓存数限制，将第一个删除          pruneCacheEntry(cache, keys[0], keys, this._vnode)        &#125;      &#125;      vnode.data.keepAlive = true // 渲染和执行被包裹组件的钩子函数需要用到    &#125;    return vnode || (slot &amp;&amp; slot[0])  &#125;</code></pre></li></ul><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>咱们先来看看Vue一个组件是怎么渲染的，咱们从<code>render</code>开始说：</p><ul><li><code>render</code>：此函数会将组件转成<code>VNode</code></li><li><code>patch</code>：此函数在初次渲染时会直接渲染根据拿到的<code>VNode</code>直接渲染成<code>真实DOM</code>，第二次渲染开始就会拿<code>VNode</code>会跟<code>旧VNode</code>对比，打补丁（diff算法对比发生在此阶段），然后渲染成<code>真实DOM</code></li></ul><h4 id="keep-alive本身渲染"><a href="#keep-alive本身渲染" class="headerlink" title="keep-alive本身渲染"></a>keep-alive本身渲染</h4><p>刚刚说了，<code>keep-alive</code>自身组件不会被渲染到页面上，那是怎么做到的呢？其实就是通过判断组件实例上的<code>abstract</code>的属性值，如果是<code>true</code>的话，就跳过该实例，该实例也不会出现在父级链上</p><pre><code>// src/core/instance/lifecycle.jsexport function initLifecycle (vm: Component) &#123;  const options = vm.$options  // 找到第一个非abstract的父组件实例  let parent = options.parent  if (parent &amp;&amp; !options.abstract) &#123;    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;      parent = parent.$parent    &#125;    parent.$children.push(vm)  &#125;  vm.$parent = parent  // ...&#125;</code></pre><h4 id="包裹组件渲染"><a href="#包裹组件渲染" class="headerlink" title="包裹组件渲染"></a>包裹组件渲染</h4><p>咱们再来说说被<code>keep-alive</code>包裹着的组件是如何使用缓存的吧。刚刚说了<code>VNode -&gt; 真实DOM</code>是发生在<code>patch</code>的阶段，而其实这也是要细分的：<code>VNode -&gt; 实例化 -&gt; _update -&gt; 真实DOM</code>，而组件使用缓存的判断就发生在<code>实例化</code>这个阶段，而这个阶段调用的是<code>createComponent</code>函数，那我们就来说说这个函数吧：</p><pre><code>// src/core/vdom/patch.jsfunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) &#123;  let i = vnode.data  if (isDef(i)) &#123;    const isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive    if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;      i(vnode, false /* hydrating */)    &#125;    if (isDef(vnode.componentInstance)) &#123;      initComponent(vnode, insertedVnodeQueue)      insert(parentElm, vnode.elm, refElm) // 将缓存的DOM（vnode.elm）插入父元素中      if (isTrue(isReactivated)) &#123;        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)      &#125;      return true    &#125;  &#125;&#125;</code></pre><p>在第一次加载被包裹组件时，因为<code>keep-alive</code>的<code>render</code>先于包裹组件加载之前执行，所以此时<code>vnode.componentInstance</code>的值是<code>undefined</code>，而<code>keepAlive</code>是<code>true</code>，则代码走到<code>i(vnode, false /* hydrating */)</code>就不往下走了</p><p>再次访问包裹组件时，<code>vnode.componentInstance</code>的值就是已经缓存的组件实例，那么会执行<code>insert(parentElm, vnode.elm, refElm)</code>逻辑，这样就直接把上一次的DOM插入到了父元素中。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ES6，你知道多少</title>
      <link href="/2023/01/06/article30/"/>
      <url>/2023/01/06/article30/</url>
      
        <content type="html"><![CDATA[<p>关于 ES6 语法，这里将 ES5 之后的语法统称为 ES6.<br>所以关于标题，大家不必纠结</p><p>以下实例均已经过本人实际测试，确认可用，当然仅代表个人理解！</p><h3 id="1、let-和-const"><a href="#1、let-和-const" class="headerlink" title="1、let 和 const"></a>1、let 和 const</h3><p>与 var 的区别：</p><ul><li>var 有变量提升，有初始化提升，值可变</li><li>let 有变量提升，没有初始化提升，值可变</li><li>const 有变量提升，没有初始化提升，值不可变，但如果订单一对象，则属性可变</li></ul><p><code>暂时性死区</code> 问题说明:其实<code>let和const</code>是由变量提升的，但是没有初始化提升：</p><pre><code>var name = &quot;一起来看看吧&quot;function fn()&#123;    console.log(name)    let name = &quot;注意看&quot;&#125;fn()// Cannot access &#39;name&#39; before initialization</code></pre><p>块级作用域解决问题：</p><pre><code>for(var i = 0; i &lt; 5 ; i++)&#123;    setTimeout(()=&gt;&#123;        console.log(i)    &#125;)&#125;//5 5 5 5 5for(let i = 0 ; i &lt; 5 ; i++)&#123;    setTimeout(()=&gt;&#123;        console.log(i)    &#125;)&#125;// 0 1 2 3 4</code></pre><h3 id="2、默认参数"><a href="#2、默认参数" class="headerlink" title="2、默认参数"></a>2、默认参数</h3><p>开发中你曾遇到过这样的问题，如果参数不传进来，你就设置默认参数</p><pre><code>function fn (name, age) &#123;  var name = name || &#39;小天&#39;  var age = age || 18  console.log(name, age)&#125;fn()// 小天 18</code></pre><p>ES6 默认参数写法</p><pre><code>function fn (name = &#39;小天&#39;, age = 18) &#123;  console.log(name, age)&#125;fn()// 小天 18fn(&#39;小天&#39;, 22)// 小天 22</code></pre><h3 id="3、扩展运算符"><a href="#3、扩展运算符" class="headerlink" title="3、扩展运算符"></a>3、扩展运算符</h3><p>提到拼接数组，或许很多人想到的都是：</p><pre><code>const arr1 = [1, 2, 4]const arr2 = [4, 5, 7]const arr3 = [7, 8, 9]const arr = arr1.concat(arr2).concat(arr3)[ 1, 2, 4, 4, 5, 7, 7, 8, 9]</code></pre><p>但是 ES6 提供了更为优雅地拼接方法</p><pre><code>const arr1 = [1, 2, 4]const arr2 = [4, 5, 7]const arr3 = [7, 8, 9]const arr = [...arr1, ...arr2, ...arr3][ 1, 2, 4, 4, 5, 7, 7, 8, 9]</code></pre><h3 id="4、剩余参数"><a href="#4、剩余参数" class="headerlink" title="4、剩余参数"></a>4、剩余参数</h3><p>一个函数，传入参数的个数是不确定的，这就可以用 ES6 的剩余参数</p><pre><code>function fn (name, ...params) &#123;   console.log(name)   console.log(params)&#125;fn (&#39;小天&#39;, 1, 2)// 小天 [ 1, 2 ]fn (&#39;小天&#39;, 1, 2, 3, 4, 5)// 小天 [ 1, 2, 3, 4, 5 ]</code></pre><h3 id="5、模板字符串"><a href="#5、模板字符串" class="headerlink" title="5、模板字符串"></a>5、模板字符串</h3><p>以前拼接字符串</p><pre><code>const name = &#39;小天&#39;const age = &#39;22&#39;console.log(name + &#39;今年&#39; + age + &#39;岁啦&#39;)//小天今年22岁啦</code></pre><p>ES6 拼接字符串</p><pre><code>const name = &#39;小天&#39;const age = &#39;22&#39;console.log(`$&#123;name&#125;今年$&#123;age&#125;岁啦`)//小天今年22岁啦</code></pre><h3 id="6、Object-keys"><a href="#6、Object-keys" class="headerlink" title="6、Object.keys"></a>6、Object.keys</h3><p>可以用来获取对象的 key 的集合，进而可以获得对应 key 的 value</p><pre><code>const obj = &#123;  name: &#39;小天&#39;,  age: 22,  gender: &#39;男&#39;&#125;const keys = Object.keys(obj)console.log(keys)// [ &#39;name&#39;, &#39;age&#39;, &#39;gender&#39; ]</code></pre><h3 id="7、箭头函数"><a href="#7、箭头函数" class="headerlink" title="7、箭头函数"></a>7、箭头函数</h3><p>以前我们使用普通函数</p><pre><code>function fn () &#123;&#125;const fn = function () &#123;&#125;</code></pre><p>ES6 新加了<code>箭头函数</code></p><pre><code>const fn = () =&gt; &#123;&#125;// 如果只有一个参数，可以省略括号const fn = name =&gt; &#123;&#125;// 如果函数体里只有一句returnconst fn = name =&gt; &#123;    return 2 * name&#125;// 可简写为const fn = name =&gt; 2 * name// 如果返回的是对象const fn = name =&gt; (&#123; name: name &#125;)</code></pre><p>普通函数和箭头函数的区别：</p><ul><li>1、箭头函数不可作为构造函数，不能使用 new</li><li>2、箭头函数没有自己的 this</li><li>3、箭头函数没有 arguments 对象</li><li>4、箭头函数没有原型对象</li></ul><h3 id="8、Array-prototype-forEach"><a href="#8、Array-prototype-forEach" class="headerlink" title="8、Array.prototype.forEach"></a>8、Array.prototype.forEach</h3><p>ES6 新加的数组遍历方法</p><pre><code>const eachArr = [1, 2, 3, 4, 5]// 三个参数：遍历项 索引 数组本身// 配合箭头函数eachArr.forEach((item, index, arr) =&gt; &#123;  console.log(item, index, arr)&#125;)1 0 [ 1, 2, 3, 4, 5 ]2 1 [ 1, 2, 3, 4, 5 ]3 2 [ 1, 2, 3, 4, 5 ]4 3 [ 1, 2, 3, 4, 5 ]5 4 [ 1, 2, 3, 4, 5 ]</code></pre><h3 id="9、Array-prototype-map"><a href="#9、Array-prototype-map" class="headerlink" title="9、Array.prototype.map"></a>9、Array.prototype.map</h3><p>常用于返回一个处理过后的新数组</p><pre><code>const mapArr = [1, 2, 3, 4, 5]// 三个参数：遍历项 索引 数组本身// 配合箭头函数，对每一个元素进行翻倍const mapArr2 = mapArr.map((num, index, arr) =&gt; 2 * num)console.log(mapArr2)[ 2, 4, 6, 8, 10 ]</code></pre><h3 id="10、Array-prototype-filter"><a href="#10、Array-prototype-filter" class="headerlink" title="10、Array.prototype.filter"></a>10、Array.prototype.filter</h3><p>顾名思义，用来过滤的方法</p><pre><code>const filterArr = [1, 2, 3, 4, 5]// 三个参数：遍历项 索引 数组本身// 配合箭头函数，返回大于3的集合const filterArr2 = filterArr.filter((num, index, arr) =&gt; num &gt; 3)console.log(filterArr2)[ 4, 5 ]</code></pre><h3 id="11、Array-prototype-some"><a href="#11、Array-prototype-some" class="headerlink" title="11、Array.prototype.some"></a>11、Array.prototype.some</h3><p>some，意思就是只要有一个是真，那就返回真</p><pre><code>const someArr = [false, true, false, true, false]// 三个参数：遍历项 索引 数组本身// 配合箭头函数，只要有一个为true，就返回true，一个都true都没有，就返回falseconst someArr2 = someArr.some((bol, index, arr) =&gt; bol)console.log(someArr2)true</code></pre><h3 id="12、Array-prototype-every"><a href="#12、Array-prototype-every" class="headerlink" title="12、Array.prototype.every"></a>12、Array.prototype.every</h3><p>every 跟 some 是相反的，some 是只要有一个就行，every 是要所有为真才返回真</p><pre><code>const everyArr = [false, true, false, true, false]// 三个参数：遍历项 索引 数组本身// 配合箭头函数，需要所有为true，才返回true，否则返回falseconst everyArr2 = everyArr.every((bol, index, arr) =&gt; bol)console.log(everyArr2)</code></pre><h3 id="13、Array-prototype-reduce"><a href="#13、Array-prototype-reduce" class="headerlink" title="13、Array.prototype.reduce"></a>13、Array.prototype.reduce</h3><ul><li>第一个参数 callback 函数： pre 为上次 return 的值，next 为数组的本次遍历的项</li><li>第二个参数为初始值，也是第一个 pre</li></ul><p>举两个例子：</p><pre><code>// 计算 1 + 2 + 3 + 4 + 5const reduceArr = [1, 2, 3, 4, 5]const sum = reduceArr.reduce((pre, next) =&gt; &#123;  return pre + next&#125;, 0)console.log(sum)// 15// 统计元素出现个数const nameArr = [&#39;小天&#39;, &#39;xiaotian&#39;, &#39;小天&#39;, &#39;小天&#39;, &#39;科比&#39;]const totalObj = nameArr.reduce((pre, next) =&gt; &#123;  if (pre[next]) &#123;    pre[next]++  &#125; else &#123;    pre[next] = 1  &#125;  return pre&#125;, &#123;&#125;)console.log(totalObj)// &#123; &#39;小天&#39;: 3, xiaotian: 1, &#39;科比&#39;: 1 &#125;</code></pre><h3 id="14、对象属性同名简写"><a href="#14、对象属性同名简写" class="headerlink" title="14、对象属性同名简写"></a>14、对象属性同名简写</h3><p>以前同名属性需要这么写</p><pre><code>const name = &#39;小天&#39;const age = &#39;22&#39;const obj = &#123;  name: name,  age: age&#125;console.log(obj)// &#123; name: &#39;小天&#39;, age: &#39;22&#39; &#125;</code></pre><p>ES6 新增语法，只需这么写</p><pre><code>const name = &#39;小天&#39;const age = &#39;22&#39;// 属性同名可简写const obj = &#123;  name,  age&#125;console.log(obj)// &#123; name: &#39;小天&#39;, age: &#39;22&#39; &#125;</code></pre><h3 id="15、Promise"><a href="#15、Promise" class="headerlink" title="15、Promise"></a>15、Promise</h3><p><code>Promise</code>，中文名为<code>承诺</code>，承诺在哪呢？承诺在，一旦他的状态改变，就不会再改。</p><p>看看基本使用</p><ul><li><p>成功状态</p><pre><code>  function requestData () &#123;    // 模拟请求    return new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        resolve(&#39;小天&#39;)      &#125;, 1000)    &#125;)  &#125;  requestData().then(res =&gt; &#123;    console.log(res)    // 一秒钟后输出 &#39;小天&#39;  &#125;, err =&gt; &#123;    console.log(err)  &#125;)</code></pre></li><li><p>失败状态</p><pre><code>  function requestData () &#123;    // 模拟请求    return new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        reject(&#39;错误啦&#39;)      &#125;, 1000)    &#125;)  &#125;  requestData().then(res =&gt; &#123;    console.log(res)  &#125;, err =&gt; &#123;    console.log(err)    // 一秒钟后输出 &#39;错误啦&#39;  &#125;)</code></pre></li><li><p><code>all</code>方法</p><p>接收一个 Promise 数组，数组中如有非 Promise 项，则此项当做成功<br>如果所有 Promise 都成功，则返回成功结果数组<br>如果有一个 Promise 失败，则返回这个失败结果</p><pre><code>  // 如果全都为成功  function fn(time) &#123;   return new Promise((resolve, reject) =&gt; &#123;     console.log(88)     setTimeout(() =&gt; &#123;       resolve(`$&#123;time&#125;毫秒后我成功啦！！！`)     &#125;, time)   &#125;)  &#125;  Promise.all([fn(2000), fn(3000), fn(1000)]).then(res =&gt; &#123;    // 3秒后输出 [ &#39;2000毫秒后我成功啦！！！&#39;, &#39;3000毫秒后我成功啦！！！&#39;,    &#39;1000毫秒后我成功啦！！！&#39; ]    console.log(res)  &#125;, err =&gt; &#123;    console.log(err)  &#125;)  // 如果有一个失败  function fn(time, isResolve) &#123;    return new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        isResolve ? resolve(`$&#123;time&#125;毫秒后我成功啦！！！`) : reject(`$        &#123;time&#125;毫秒后我失败啦！！！`)      &#125;, time)    &#125;)  &#125;  Promise.all([fn(2000, true), fn(3000), fn(1000, true)]).then(res =&gt; &#123;    console.log(res)  &#125;, err =&gt; &#123;    console.log(err)    // 3秒后输出 &#39;3000毫秒后我失败啦！！！&#39;  &#125;)</code></pre></li><li><p><code>race</code>方法</p><p>接收一个 Promise 数组，数组中如有非 Promise 项，则此项当做成功<br>哪个 Promise 最快得到结果，就返回那个结果，无论成功失败</p><pre><code>  function fn(time, isResolve) &#123;    return new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        isResolve ? resolve(`$&#123;time&#125;毫秒后我成功啦！！！`) : reject(`$    &#123;time&#125;毫秒后我失败啦！！！`)      &#125;, time)    &#125;)  &#125;  Promise.race([fn(2000, true), fn(3000), fn(1000)]).then(res =&gt; &#123;    console.log(res)  &#125;, err =&gt; &#123;    console.log(err)    // 1秒后输出  &#125;)</code></pre></li></ul><h3 id="16、class"><a href="#16、class" class="headerlink" title="16、class"></a>16、class</h3><p>以前使用构造函数生成对象，这么做</p><pre><code>function Person(name) &#123;  this.name = name&#125;Person.prototype.sayName = function () &#123;  console.log(this.name)&#125;const kobe = new Person(&#39;科比&#39;)kobe.sayName()// 科比</code></pre><p>而有了 ES6 的<code>class</code>可以这么做</p><pre><code>class Person &#123;  constructor(name) &#123;    // 构造器    this.name = name  &#125;  sayName() &#123;    console.log(this.name)  &#125;&#125;const kobe = new Person(&#39;科比&#39;)kobe.sayName()// 科比</code></pre><p>值得一提的是，<code>class</code>本质也是<code>function</code>，<code>class</code>是<code>function</code>的<code>语法糖</code></p><pre><code>class Person &#123;&#125;console.log(typeof Person)// function</code></pre><p>除了以上，还需要知道 class 的以下知识点</p><p>静态属性和静态方法，使用<code>static</code>定义的属性和方法只能 class 自己用，实例用不了</p><pre><code>class Person &#123;  constructor(name) &#123;    this.name = name  &#125;  static age = 22  static fn() &#123;    console.log(&#39;哈哈&#39;)  &#125;&#125;console.log(Person.age)// 22Person.fn()// 哈哈const sunshine_lin = new Person(&#39;小天&#39;)console.log(sunshine_lin.age)// undefinedsunshine_lin.fn()// fn is not a function</code></pre><p><code>extend</code>继承</p><pre><code>class Animal &#123;  constructor(name, age) &#123;    this.name = name    this.age = age  &#125;&#125;class Cat extends Animal &#123;  say() &#123;    console.log(this.name, this.age)  &#125;&#125;const cat = new Cat(&#39;ketty&#39;, 5)// 继承了Animal的构造器cat.say()// ketty 5</code></pre><h3 id="17、解构赋值"><a href="#17、解构赋值" class="headerlink" title="17、解构赋值"></a>17、解构赋值</h3><p>以前想提取对象里的属性需要这么做</p><pre><code>const obj = &#123;  name: &#39;小天&#39;,  age: 22,  gender: &#39;男&#39;&#125;const name = obj.nameconst age = obj.ageconst gender = obj.genderconsole.log(name, age, gender)// 小天 22 男</code></pre><p>ES6 新增了解构赋值的语法</p><pre><code>const obj = &#123;  name: &#39;小天&#39;,  age: 22,  gender: &#39;男&#39;,  doing: &#123;    morning: &#39;摸鱼&#39;,    afternoon: &#39;摸鱼&#39;,    evening: &#39;sleep&#39;  &#125;&#125;const &#123; name, age, gender &#125; = objconsole.log(name, age, gender)// 小天 22 男// 解构重名const &#123; name: myname &#125; = objconsole.log(myname)// 小天// 嵌套解构const &#123; doing: &#123; evening &#125; &#125; = objconsole.log(evening)// sleep</code></pre><p>也可以进行数组的解构</p><pre><code>const arr = [1, 2, 3]const [a, b, c] = arrconsole.log(a, b, c)// 1 2 3// 默认赋值const [a, b, c, d = 5] = arrconsole.log(a, b, c, d)// 1 2 3 5// 乱序解构const &#123; 1: a, 0: b, 2: c &#125; = arrconsole.log(a, b, c) // 2 1 3</code></pre><h3 id="18、find-和-findIndex"><a href="#18、find-和-findIndex" class="headerlink" title="18、find 和 findIndex"></a>18、find 和 findIndex</h3><ul><li><p>find：找到返回被找元素，找不到返回 undefined</p></li><li><p>findIndex：找到返回被找元素索引，找不到返回-1</p><pre><code>  const findArr = [    &#123; name: &#39;科比&#39;, no: &#39;24&#39; &#125;,    &#123; name: &#39;罗斯&#39;, no: &#39;1&#39; &#125;,    &#123; name: &#39;利拉德&#39;, no: &#39;0&#39; &#125;  ]  const kobe = findArr.find((&#123; name &#125;) =&gt; name === &#39;科比&#39;)  const kobeIndex = findArr.findIndex((&#123; name &#125;) =&gt; name === &#39;科比&#39;)  console.log(kobe)  // &#123; name: &#39;科比&#39;, no: &#39;24&#39; &#125;  console.log(kobeIndex)  // 0</code></pre></li></ul><h3 id="19、for-of-和-for-in"><a href="#19、for-of-和-for-in" class="headerlink" title="19、for of 和 for in"></a>19、for of 和 for in</h3><ul><li>for in ：遍历方法，可遍历对象和数组</li><li>for of ：遍历方法，只能遍历数组，不能遍历非 iterable 对象</li></ul><p>先看 for in：</p><pre><code>const obj = &#123; name: &#39;小天&#39;, age: 22, gender: &#39;男&#39; &#125;const arr = [1, 2, 3, 4, 5]for(let key in obj) &#123;  console.log(key)&#125;nameagegenderfor(let index in arr) &#123;  console.log(index)&#125;0 1 2 3 4</code></pre><p>再看 for of：</p><pre><code>for(let item of arr) &#123;  console.log(item)&#125;1 2 3 4 5</code></pre><h3 id="20、Set-和-Map"><a href="#20、Set-和-Map" class="headerlink" title="20、Set 和 Map"></a>20、Set 和 Map</h3><ul><li>Set</li></ul><p>先说说<code>Set</code>的基本用法</p><pre><code>// 可不传数组const set1 = new Set()set1.add(1)set1.add(2)console.log(set1)// Set(2) &#123; 1, 2 &#125;// 也可传数组const set2 = new Set([1, 2, 3])// 增加元素 使用 addset2.add(4)set2.add(&#39;小天&#39;)console.log(set2)// Set(5) &#123; 1, 2, 3, 4, &#39;小天&#39; &#125;// 是否含有某个元素 使用 hasconsole.log(set2.has(2))// true// 查看长度 使用 sizeconsole.log(set2.size)// 5// 删除元素 使用 deleteset2.delete(2)console.log(set2)// Set(4) &#123; 1, 3, 4, &#39;小天&#39; &#125;</code></pre><p>再说说<code>Set</code>的不重复性</p><pre><code>// 增加一个已有元素，则增加无效，会被自动去重const set1 = new Set([1])set1.add(1)console.log(set1)// Set(1) &#123; 1 &#125;// 传入的数组中有重复项，会自动去重const set2 = new Set([1, 2, &#39;小天&#39;, 3, 3, &#39;小天&#39;])console.log(set2)// Set(4) &#123; 1, 2, &#39;小天&#39;, 3 &#125;</code></pre><p><code>Set</code>的不重复性中，要注意<code>引用数据类型和NaN</code></p><pre><code>// 两个对象都是不同的指针，所以没法去重const set1 = new Set([1, &#123;name: &#39;小天&#39;&#125;, 2, &#123;name: &#39;小天&#39;&#125;])console.log(set1)// Set(4) &#123; 1, &#123; name: &#39;小天&#39; &#125;, 2, &#123; name: &#39;小天&#39; &#125; &#125;// 如果是两个对象是同一指针，则能去重const obj = &#123;name: &#39;小天&#39;&#125;const set2 = new Set([1, obj, 2, obj])console.log(set2)// Set(3) &#123; 1, &#123; name: &#39;小天&#39; &#125;, 2 &#125;</code></pre><p>咱们都知道 NaN !== NaN，NaN 是自身不等于自身的，但是在 Set 中他还是会被去重</p><pre><code>const set = new Set([1, NaN, 1, NaN])console.log(set)// Set(2) &#123; 1, NaN &#125;</code></pre><p>利用 Set 的不重复性，可以实现数组去重</p><pre><code>const arr = [1, 2, 3, 4, 4, 5, 5, 66, 9, 1]// Set可利用扩展运算符转为数组哦const quchongArr = [...new Set(arr)]console.log(quchongArr)// [1,  2, 3, 4, 5, 66, 9]</code></pre><ul><li>Map</li></ul><p><code>Map</code>对比<code>object</code>最大的好处就是，key 不受<code>类型限制</code></p><pre><code>// 定义mapconst map1 = new Map()// 新增键值对 使用 set(key, value)map1.set(true, 1)map1.set(1, 2)map1.set(&#39;哈哈&#39;, &#39;嘻嘻嘻&#39;)console.log(map1)// Map(3) &#123; true =&gt; 1, 1 =&gt; 2, &#39;哈哈&#39; =&gt; &#39;嘻嘻嘻&#39; &#125;// 判断map是否含有某个key 使用 has(key)console.log(map1.has(&#39;哈哈&#39;))// true// 获取map中某个key对应的value 使用 get(key)console.log(map1.get(true))// 2// 删除map中某个键值对 使用 delete(key)map1.delete(&#39;哈哈&#39;)console.log(map1)// Map(2) &#123; true =&gt; 1, 1 =&gt; 2 &#125;// 定义map，也可传入键值对数组集合const map2 = new Map([[true, 1], [1, 2], [&#39;哈哈&#39;, &#39;嘻嘻嘻&#39;]])console.log(map2)// Map(3) &#123; true =&gt; 1, 1 =&gt; 2, &#39;哈哈&#39; =&gt; &#39;嘻嘻嘻&#39; &#125;</code></pre><h3 id="21、includes"><a href="#21、includes" class="headerlink" title="21、includes"></a>21、includes</h3><p>传入元素，如果数组中能找到此元素，则返回 true，否则返回 false</p><pre><code>const includeArr = [1, 2 , 3, &#39;小天&#39;, &#39;科比&#39;]const isKobe = includeArr.includes(&#39;科比&#39;)console.log(isKobe) // true</code></pre><p>跟 indexOf 很像，但还是有区别的</p><pre><code>const arr = [1, 2, NaN]console.log(arr.indexOf(NaN)) // -1  indexOf找不到NaNconsole.log(arr.includes(NaN)) // true includes能找到NaN</code></pre><h3 id="22、求幂运算符"><a href="#22、求幂运算符" class="headerlink" title="22、求幂运算符"></a>22、求幂运算符</h3><p>以前求幂，需要这么写</p><pre><code>const num = Math.pow(3, 2) // 9</code></pre><p>ES7 提供了求幂运算符：<code>**</code></p><pre><code>const num = 3 ** 2 // 9</code></pre><h3 id="23、Object-values"><a href="#23、Object-values" class="headerlink" title="23、Object.values"></a>23、Object.values</h3><p>可以用来获取对象的 value 的集合</p><pre><code>const obj = &#123;  name: &#39;小天&#39;,  age: 22,  gender: &#39;男&#39;&#125;const values = Object.values(obj)console.log(values)// [ &#39;小天&#39;, 22, &#39;男&#39; ]</code></pre><h3 id="24、Object-entries"><a href="#24、Object-entries" class="headerlink" title="24、Object.entries"></a>24、Object.entries</h3><p>可以用来获取对象的键值对集合</p><pre><code>const obj = &#123;  name: &#39;小天&#39;,  age: 22,  gender: &#39;男&#39;&#125;const entries = Object.entries(obj)console.log(entries)// [ [ &#39;name&#39;, &#39;小天&#39; ], [ &#39;age&#39;, 22 ], [ &#39;gender&#39;, &#39;男&#39; ] ]</code></pre><h3 id="25、async-await"><a href="#25、async-await" class="headerlink" title="25、async/await"></a>25、async/await</h3><p>这个是很常用的语法了，我的理解就是：<strong>以同步方式执行异步操作</strong></p><p>我们平时可能会遇到这种场景，接口一，请求到数据一，而数据一被当做请求二的参数去请求数据二，我们会用 Promise 这么做</p><pre><code>function fn() &#123;  // 模拟第一次请求  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(5)    &#125;, 1000)  &#125;).then(res =&gt; &#123;    // 模拟第二次请求    new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        // 拿第一次请求的数据去乘10，当做第二次请求的数据        resolve(res * 10)      &#125;, 2000)    &#125;).then(sres =&gt; &#123;      console.log(sres)    &#125;)  &#125;)&#125;fn()// 1 + 2 = 3 3秒后输出 50</code></pre><p>这样的嵌套是不美观的，如果有很多个接口，那就会嵌套很多层，此时我们可以使用 async/await 来以同步方式执行异步，注意以下几点：</p><ul><li><p>await 只能在 async 函数里使用</p></li><li><p>await 后面最好接 Promise，如果后面接的是普通函数则会直接执行</p></li><li><p>async 函数返回的是一个 Promise</p><pre><code>  function fn1 () &#123;    return new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        resolve(5)      &#125;, 1000)    &#125;)  &#125;  function fn2 (data) &#123;    return new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        resolve(data * 10)      &#125;, 2000)    &#125;)  &#125;  async function req () &#123;    // 同步方式执行异步，像排队一样    const data1 = await fn1()    // 等待1秒后返回数据再往下执行    const data2 = await fn2(data1)    // 拿data1去请求2秒后，往下走    console.log(data2)    // 总共3秒后 输出 50  &#125;  req()</code></pre></li></ul><h3 id="26、for-await-of"><a href="#26、for-await-of" class="headerlink" title="26、for await of"></a>26、for await of</h3><p>我们来看以下场景哈</p><pre><code>function fn (time) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(`$&#123;time&#125;毫秒后我成功啦！！！`)    &#125;, time)  &#125;)&#125;fn(3000).then(res =&gt; console.log(res))fn(1000).then(res =&gt; console.log(res))fn(2000).then(res =&gt; console.log(res))结果是1000毫秒后我成功啦！！！2000毫秒后我成功啦！！！3000毫秒后我成功啦！！！</code></pre><p>但是我想要这个结果</p><pre><code>3000毫秒后我成功啦！！！1000毫秒后我成功啦！！！2000毫秒后我成功啦！！！</code></pre><p>第一时间我们肯定想到的是<code>async/await</code></p><pre><code>function fn (time) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(`$&#123;time&#125;毫秒后我成功啦！！！`)    &#125;, time)  &#125;)&#125;async function asyncFn () &#123;  // 排队  const data1 = await fn(3000)  console.log(data1)  // 3秒后 3000毫秒后我成功啦！！！  const data2 = await fn(1000)  console.log(data2)  // 再过1秒 1000毫秒后我成功啦！！！  const data3 = await fn(2000)  console.log(data3)  // 再过2秒 2000毫秒后我成功啦！！！&#125;</code></pre><p>但是上面代码也是有缺点的，如果有几十个，那不是得写几十个 await，有没有一种方法可以通过循环来输出呢？</p><pre><code>function fn (time) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(`$&#123;time&#125;毫秒后我成功啦！！！`)    &#125;, time)  &#125;)&#125;async function asyncFn () &#123;  const arr = [fn(3000), fn(1000), fn(1000), fn(2000), fn(500)]  for await (let x of arr) &#123;    console.log(x)  &#125;&#125;asyncFn()3000毫秒后我成功啦！！！1000毫秒后我成功啦！！！1000毫秒后我成功啦！！！2000毫秒后我成功啦！！！500毫秒后我成功啦！！！</code></pre><h3 id="27、Promise-finally"><a href="#27、Promise-finally" class="headerlink" title="27、Promise.finally"></a>27、Promise.finally</h3><p>新增的 Promise 方法，无论失败或者成功状态，都会执行这个函数</p><pre><code>// 成功new Promise((resolve, reject) =&gt; &#123;  resolve(&#39;成功喽&#39;)&#125;).then(  res =&gt; &#123; console.log(res) &#125;,  err =&gt; &#123; console.log(err) &#125;).finally(() =&gt; &#123; console.log(&#39;我是finally&#39;) &#125;)// 失败喽new Promise((resolve, reject) =&gt; &#123;  reject(&#39;失败喽&#39;)&#125;).then(  res =&gt; &#123; console.log(res) &#125;,  err =&gt; &#123; console.log(err) &#125;).finally(() =&gt; &#123; console.log(&#39;我是finally&#39;) &#125;)</code></pre><h3 id="28、Array-flat"><a href="#28、Array-flat" class="headerlink" title="28、Array.flat"></a>28、Array.flat</h3><p>有一个二维数组，我想让他变成一维数组：</p><pre><code>const arr = [1, 2, 3, [4, 5, 6]]console.log(arr.flat())// [ 1, 2, 3, 4, 5, 6 ]</code></pre><p>还可以传参数，参数为降维的次数</p><pre><code>const arr = [1, 2, 3, [4, 5, 6, [7, 8, 9]]]console.log(arr.flat(2))[ 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>如果传的是一个无限大的数字，那么就实现了多维数组(无论几维)降为一维数组</p><pre><code>const arr = [1, 2, 3, [4, 5, 6, [7, 8, 9, [10, 11, 12]]]]console.log(arr.flat(Infinity))[   1,  2, 3, 4,  5,   6,  7, 8, 9, 10,   11, 12]</code></pre><h3 id="29、Array-flatMap"><a href="#29、Array-flatMap" class="headerlink" title="29、Array.flatMap"></a>29、Array.flatMap</h3><p>现在给你一个需求</p><pre><code>let arr = [&quot;科比 詹姆斯 安东尼&quot;, &quot;利拉德 罗斯 麦科勒姆&quot;];</code></pre><p>将上面数组转为</p><pre><code>[ &#39;科比&#39;, &#39;詹姆斯&#39;, &#39;安东尼&#39;, &#39;利拉德&#39;, &#39;罗斯&#39;, &#39;麦科勒姆&#39; ]</code></pre><p>第一时间想到<code>map + flat</code></p><pre><code>console.log(arr.map(x =&gt; x.split(&quot; &quot;)).flat());// [ &#39;科比&#39;, &#39;詹姆斯&#39;, &#39;安东尼&#39;, &#39;利拉德&#39;, &#39;罗斯&#39;, &#39;麦科勒姆&#39; ]</code></pre><p><code>flatMap</code>就是<code>flat + map</code></p><pre><code>console.log(arr.flatMap(x =&gt; x.split(&quot; &quot;)));// [ &#39;科比&#39;, &#39;詹姆斯&#39;, &#39;安东尼&#39;, &#39;利拉德&#39;, &#39;罗斯&#39;, &#39;麦科勒姆&#39; ]</code></pre><h3 id="30、Promise-allSettled"><a href="#30、Promise-allSettled" class="headerlink" title="30、Promise.allSettled"></a>30、Promise.allSettled</h3><p>ES11 新增的 Promise 的方法</p><ul><li><p>接收一个 Promise 数组，数组中如有非 Promise 项，则此项当做成功</p></li><li><p>把每一个 Promise 的结果，集合成数组，返回</p><pre><code>  function fn(time, isResolve) &#123;    return new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        isResolve ? resolve(`$&#123;time&#125;毫秒后我成功啦！！！`) : reject(`$&#123;time&#125;毫秒后我失败啦！！！`)      &#125;, time)    &#125;)  &#125;  Promise.allSettled([fn(2000, true), fn(3000), fn(1000)]).then(res =&gt; &#123;    console.log(res)    // 3秒后输出    [    &#123; status: &#39;fulfilled&#39;, value: &#39;2000毫秒后我成功啦！！！&#39; &#125;,    &#123; status: &#39;rejected&#39;, reason: &#39;3000毫秒后我失败啦！！！&#39; &#125;,    &#123; status: &#39;rejected&#39;, reason: &#39;1000毫秒后我失败啦！！！&#39; &#125;  ]  &#125;)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止数据重复提交的6种方法</title>
      <link href="/2022/11/30/article28/"/>
      <url>/2022/11/30/article28/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟用户场景"><a href="#模拟用户场景" class="headerlink" title="模拟用户场景"></a>模拟用户场景</h2><p>大致的场景是这样的，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3106d1c474bc4dd7abbad7d478a14811~tplv-k3u1fbpfcp-watermark.awebp"></p><p>简化的模拟代码如下（基于 Spring Boot）：</p><pre><code>import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController &#123;   /**     * 被重复请求的方法     */    @RequestMapping(&quot;/add&quot;)    public String addUser(String id) &#123;        // 业务代码...        System.out.println(&quot;添加用户ID:&quot; + id);        return &quot;执行成功！&quot;;    &#125;&#125;</code></pre><h2 id="前端拦截"><a href="#前端拦截" class="headerlink" title="前端拦截"></a>前端拦截</h2><p>前端拦截是指通过 HTML 页面来拦截重复请求，比如在用户点击完“提交”按钮后，我们可以把按钮设置为不可用或者隐藏状态。</p><p>执行效果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41abe74140434045874f902a113b5b08~tplv-k3u1fbpfcp-watermark.awebp"></p><p>前端拦截的实现代码：</p><pre><code>&lt;html&gt;&lt;script&gt;    function subCli()&#123;        // 按钮设置为不可用        document.getElementById(&quot;btn_sub&quot;).disabled=&quot;disabled&quot;;        document.getElementById(&quot;dv1&quot;).innerText = &quot;按钮被点击了~&quot;;    &#125;&lt;/script&gt;&lt;body style=&quot;margin-top: 100px;margin-left: 100px;&quot;&gt;    &lt;input id=&quot;btn_sub&quot; type=&quot;button&quot;  value=&quot; 提 交 &quot;  onclick=&quot;subCli()&quot;&gt;    &lt;div id=&quot;dv1&quot; style=&quot;margin-top: 80px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>但前端拦截有一个致命的问题，如果是懂行的程序员或非法用户可以直接绕过前端页面，通过模拟请求来重复提交请求，比如充值了 100 元，重复提交了 10 次变成了 1000 元（瞬间发现了一个致富的好办法）。</p><p>所以除了前端拦截一部分正常的误操作之外，后端的拦截也是必不可少。</p><h2 id="后端拦截"><a href="#后端拦截" class="headerlink" title="后端拦截"></a>后端拦截</h2><p>后端拦截的实现思路是在方法执行之前，先判断此业务是否已经执行过，如果执行过则不再执行，否则就正常执行。</p><p>我们将请求的业务 ID 存储在内存中，并且通过添加互斥锁来保证多线程下的程序执行安全，大体实现思路如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfb589c81df64f0abee57cda25219ef0~tplv-k3u1fbpfcp-watermark.awebp"></p><p>然而，将数据存储在内存中，最简单的方法就是使用 <code>HashMap</code> 存储，或者是使用 Guava Cache 也是同样的效果，但很显然 <code>HashMap</code> 可以更快的实现功能，所以我们先来实现一个 <code>HashMap</code> 的防重（防止重复）版本。</p><h3 id="1-基础版——HashMap"><a href="#1-基础版——HashMap" class="headerlink" title="1.基础版——HashMap"></a>1.基础版——HashMap</h3><pre><code>import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;/\*\*- 普通 Map 版本\*/@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController3 &#123;  // 缓存 ID 集合  private Map&lt;String, Integer&gt; reqCache = new HashMap&lt;&gt;();  @RequestMapping(&quot;/add&quot;)      public String addUser(String id) &#123;          // 非空判断(忽略)...          synchronized (this.getClass()) &#123;              // 重复请求判断              if (reqCache.containsKey(id)) &#123;                  // 重复请求                  System.out.println(&quot;请勿重复提交！！！&quot; + id);                  return &quot;执行失败&quot;;              &#125;              // 存储请求 ID              reqCache.put(id, 1);          &#125;          // 业务代码...          System.out.println(&quot;添加用户ID:&quot; + id);          return &quot;执行成功！&quot;;      &#125;&#125;</code></pre><p>实现效果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c073fd03734f448715d215875c19cf~tplv-k3u1fbpfcp-watermark.awebp"></p><p><strong>存在的问题</strong>：此实现方式有一个致命的问题，因为 <code>HashMap</code> 是无限增长的，因此它会占用越来越多的内存，并且随着 <code>HashMap</code> 数量的增加查找的速度也会降低，所以我们需要实现一个可以自动“清除”过期数据的实现方案。</p><h3 id="2-优化版——固定大小的数组"><a href="#2-优化版——固定大小的数组" class="headerlink" title="2.优化版——固定大小的数组"></a>2.优化版——固定大小的数组</h3><p>此版本解决了 <code>HashMap</code> 无限增长的问题，它使用数组加下标计数器（reqCacheCounter）的方式，实现了固定数组的循环存储。</p><p>当数组存储到最后一位时，将数组的存储下标设置 0，再从头开始存储数据，实现代码如下：</p><pre><code>import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Arrays;@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController &#123;    private static String[] reqCache = new String[100]; // 请求 ID 存储集合    private static Integer reqCacheCounter = 0; // 请求计数器（指示 ID 存储的位置）    @RequestMapping(&quot;/add&quot;)    public String addUser(String id) &#123;        // 非空判断(忽略)...        synchronized (this.getClass()) &#123;            // 重复请求判断            if (Arrays.asList(reqCache).contains(id)) &#123;                // 重复请求                System.out.println(&quot;请勿重复提交！！！&quot; + id);                return &quot;执行失败&quot;;            &#125;            // 记录请求 ID            if (reqCacheCounter &gt;= reqCache.length) reqCacheCounter = 0; // 重置计数器            reqCache[reqCacheCounter] = id; // 将 ID 保存到缓存            reqCacheCounter++; // 下标往后移一位        &#125;        // 业务代码...        System.out.println(&quot;添加用户ID:&quot; + id);        return &quot;执行成功！&quot;;    &#125;&#125;</code></pre><h3 id="3-扩展版——双重检测锁-DCL"><a href="#3-扩展版——双重检测锁-DCL" class="headerlink" title="3.扩展版——双重检测锁(DCL)"></a>3.扩展版——双重检测锁(DCL)</h3><p>上一种实现方法将判断和添加业务，都放入 <code>synchronized</code> 中进行加锁操作，这样显然性能不是很高，于是我们可以使用单例中著名的 DCL（Double Checked Locking，双重检测锁）来优化代码的执行效率，实现代码如下：</p><pre><code>import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Arrays;@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController &#123;    private static String[] reqCache = new String[100]; // 请求 ID 存储集合    private static Integer reqCacheCounter = 0; // 请求计数器（指示 ID 存储的位置）    @RequestMapping(&quot;/add&quot;)    public String addUser(String id) &#123;        // 非空判断(忽略)...        // 重复请求判断        if (Arrays.asList(reqCache).contains(id)) &#123;            // 重复请求            System.out.println(&quot;请勿重复提交！！！&quot; + id);            return &quot;执行失败&quot;;        &#125;        synchronized (this.getClass()) &#123;            // 双重检查锁（DCL,double checked locking）提高程序的执行效率            if (Arrays.asList(reqCache).contains(id)) &#123;                // 重复请求                System.out.println(&quot;请勿重复提交！！！&quot; + id);                return &quot;执行失败&quot;;            &#125;            // 记录请求 ID            if (reqCacheCounter &gt;= reqCache.length) reqCacheCounter = 0; // 重置计数器            reqCache[reqCacheCounter] = id; // 将 ID 保存到缓存            reqCacheCounter++; // 下标往后移一位        &#125;        // 业务代码...        System.out.println(&quot;添加用户ID:&quot; + id);        return &quot;执行成功！&quot;;    &#125;&#125;</code></pre><p><code>注意：DCL 适用于重复提交频繁比较高的业务场景，对于相反的业务场景下 DCL 并不适用。</code></p><h3 id="4-完善版——LRUMap"><a href="#4-完善版——LRUMap" class="headerlink" title="4.完善版——LRUMap"></a>4.完善版——LRUMap</h3><p>上面的代码基本已经实现了重复数据的拦截，但显然不够简洁和优雅，比如下标计数器的声明和业务处理等，但值得庆幸的是 Apache 为我们提供了一个 commons-collections 的框架，里面有一个非常好用的数据结构 <code>LRUMap</code> 可以保存指定数量的固定的数据，并且它会按照 LRU 算法，帮你清除最不常用的数据。</p><blockquote><p>小贴士：LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的数据淘汰算法，选择最近最久未使用的数据予以淘汰。</p></blockquote><p>首先，我们先来添加 Apache commons collections 的引用：</p><pre><code>&lt;!-- 集合工具类 apache commons collections --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;  &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;  &lt;version&gt;4.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>实现代码如下：</p><pre><code>import org.apache.commons.collections4.map.LRUMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController &#123;    // 最大容量 100 个，根据 LRU 算法淘汰数据的 Map 集合    private LRUMap&lt;String, Integer&gt; reqCache = new LRUMap&lt;&gt;(100);    @RequestMapping(&quot;/add&quot;)    public String addUser(String id) &#123;        // 非空判断(忽略)...        synchronized (this.getClass()) &#123;            // 重复请求判断            if (reqCache.containsKey(id)) &#123;                // 重复请求                System.out.println(&quot;请勿重复提交！！！&quot; + id);                return &quot;执行失败&quot;;            &#125;            // 存储请求 ID            reqCache.put(id, 1);        &#125;        // 业务代码...        System.out.println(&quot;添加用户ID:&quot; + id);        return &quot;执行成功！&quot;;    &#125;&#125;</code></pre><p>使用了 <code>LRUMap</code> 之后，代码显然简洁了很多。</p><h3 id="5-最终版——封装"><a href="#5-最终版——封装" class="headerlink" title="5.最终版——封装"></a>5.最终版——封装</h3><p>以上都是方法级别的实现方案，然而在实际的业务中，我们可能有很多的方法都需要防重，那么接下来我们就来封装一个公共的方法，以供所有类使用：</p><pre><code>import org.apache.commons.collections4.map.LRUMap;/** * 幂等性判断 */public class IdempotentUtils &#123;    // 根据 LRU(Least Recently Used，最近最少使用)算法淘汰数据的 Map 集合，最大容量 100 个    private static LRUMap&lt;String, Integer&gt; reqCache = new LRUMap&lt;&gt;(100);    /**     * 幂等性判断     * @return     */    public static boolean judge(String id, Object lockClass) &#123;        synchronized (lockClass) &#123;            // 重复请求判断            if (reqCache.containsKey(id)) &#123;                // 重复请求                System.out.println(&quot;请勿重复提交！！！&quot; + id);                return false;            &#125;            // 非重复请求，存储请求 ID            reqCache.put(id, 1);        &#125;        return true;    &#125;&#125;</code></pre><p>调用代码如下：</p><pre><code>import com.example.idempote.util.IdempotentUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RequestMapping(&quot;/user&quot;)@RestControllerpublic class UserController4 &#123;@RequestMapping(&quot;/add&quot;)public String addUser(String id) &#123;// 非空判断(忽略)...// -------------- 幂等性调用（开始） --------------if (!IdempotentUtils.judge(id, this.getClass())) &#123;return &quot;执行失败&quot;;&#125;// -------------- 幂等性调用（结束） --------------// 业务代码...System.out.println(&quot;添加用户 ID:&quot; + id);return &quot;执行成功！&quot;;&#125;&#125;</code></pre><p>小贴士：一般情况下代码写到这里就结束了，但想要更简洁也是可以实现的，你可以通过自定义注解，将业务代码写到注解中，需要调用的方法只需要写一行注解就可以防止数据重复提交了，可以自行尝试一下）。</p><h2 id="扩展知识——LRUMap-实现原理分析"><a href="#扩展知识——LRUMap-实现原理分析" class="headerlink" title="扩展知识——LRUMap 实现原理分析"></a>扩展知识——LRUMap 实现原理分析</h2><p>既然 <code>LRUMap</code> 如此强大，我们就来看看它是如何实现的。</p><p><code>LRUMap</code> 的本质是持有头结点的环回双链表结构，它的存储结构如下：</p><p><code>AbstractLinkedMap.LinkEntry entry;</code></p><p>当调用查询方法时，会将使用的元素放在双链表 header 的前一个位置，源码如下：</p><pre><code>public V get(Object key, boolean updateToMRU) &#123;LinkEntry&lt;K, V&gt; entry = this.getEntry(key);if (entry == null) &#123;return null;&#125; else &#123;if (updateToMRU) &#123;this.moveToMRU(entry);&#125;        return entry.getValue();    &#125;&#125;protected void moveToMRU(LinkEntry&lt;K, V&gt; entry) &#123;if (entry.after != this.header) &#123;++this.modCount;if (entry.before == null) &#123;throw new IllegalStateException(&quot;Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly.&quot;);&#125;        entry.before.after = entry.after;        entry.after.before = entry.before;        entry.after = this.header;        entry.before = this.header.before;        this.header.before.after = entry;        this.header.before = entry;    &#125; else if (entry == this.header) &#123;        throw new IllegalStateException(&quot;Can&#39;t move header to MRU This should not occur if your keys are immutable, and you have used synchronization properly.&quot;);    &#125;&#125;</code></pre><p>如果新增元素时，容量满了就会移除 header 的后一个元素，添加源码如下：</p><pre><code>protected void addMapping(int hashIndex, int hashCode, K key, V value) &#123;    // 判断容器是否已满    if (this.isFull()) &#123;        LinkEntry&lt;K, V&gt; reuse = this.header.after;        boolean removeLRUEntry = false;        if (!this.scanUntilRemovable) &#123;            removeLRUEntry = this.removeLRU(reuse);        &#125; else &#123;            while(reuse != this.header &amp;&amp; reuse != null) &#123;                if (this.removeLRU(reuse)) &#123;                    removeLRUEntry = true;                    break;                &#125;                reuse = reuse.after;            &#125;            if (reuse == null) &#123;                throw new IllegalStateException(&quot;Entry.after=null, header.after=&quot; + this.header.after + &quot; header.before=&quot; + this.header.before + &quot; key=&quot; + key + &quot; value=&quot; + value + &quot; size=&quot; + this.size + &quot; maxSize=&quot; + this.maxSize + &quot; This should not occur if your keys are immutable, and you have used synchronization properly.&quot;);            &#125;        &#125;        if (removeLRUEntry) &#123;            if (reuse == null) &#123;                throw new IllegalStateException(&quot;reuse=null, header.after=&quot; + this.header.after + &quot; header.before=&quot; + this.header.before + &quot; key=&quot; + key + &quot; value=&quot; + value + &quot; size=&quot; + this.size + &quot; maxSize=&quot; + this.maxSize + &quot; This should not occur if your keys are immutable, and you have used synchronization properly.&quot;);            &#125;            this.reuseMapping(reuse, hashIndex, hashCode, key, value);        &#125; else &#123;            super.addMapping(hashIndex, hashCode, key, value);        &#125;    &#125; else &#123;        super.addMapping(hashIndex, hashCode, key, value);    &#125;&#125;</code></pre><p>判断容量的源码：</p><pre><code>public boolean isFull() &#123;  return size &gt;= maxSize;&#125;</code></pre><p>容量未满就直接添加数据：<br><code>super.addMapping(hashIndex, hashCode, key, value);</code></p><p>如果容量满了，就调用 <code>reuseMapping</code> 方法使用 LRU 算法对数据进行清除。</p><p>综合来说：**<code>LRUMap</code> 的本质是持有头结点的环回双链表结构，当使用元素时，就将该元素放在双链表 <code>header</code> 的前一个位置，在新增元素时，如果容量满了就会移除 <code>header</code> 的后一个元素**。</p><p>稀土掘金——<a href="https://juejin.cn/post/7033231706270367775">码农出击 666</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload</title>
      <link href="/2022/11/10/article27/"/>
      <url>/2022/11/10/article27/</url>
      
        <content type="html"><![CDATA[<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>利用 <code>Blob.prototype.slice</code> 方法，和数组的 <code>slice</code> 方法相似，调用的 <code>slice</code> 方法可以返回原文件的某个切片</p><p>这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了<code>同时</code>传多个小的文件切片，可以大大减少上传时间</p><p>另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端需要负责接受这些切片，并在接收到所有切片后<code>合并</code>切片</p><p>这里又引伸出两个问题</p><ol><li>何时合并切片，即切片什么时候传输完成</li><li>如何合并切片</li></ol><p>第一个问题需要前端进行配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并，也可以额外发一个请求主动通知服务端进行切片的合并</p><p>第二个问题，具体如何合并切片呢？这里可以使用 nodejs 的 读写流（readStream/writeStream），将所有切片的流传输到最终文件的流里</p><p><code>talk is cheap,show me the code</code>，接着我们用代码实现上面的思路</p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>以 Vue 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 element-ui 作为 UI 框架</p><h3 id="上传控件"><a href="#上传控件" class="headerlink" title="上传控件"></a>上传控件</h3><p>首先创建选择文件的控件，监听 change 事件以及上传按钮</p><pre><code>&lt;template&gt;   &lt;div&gt;    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;    &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data: () =&gt; (&#123;    container: &#123;      file: null    &#125;  &#125;),  methods: &#123;     handleFileChange(e) &#123;      const [file] = e.target.files;      if (!file) return;      Object.assign(this.$data, this.$options.data());      this.container.file = file;    &#125;,    async handleUpload() &#123;&#125;  &#125;&#125;;&lt;/script&gt;</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/7/16f7ff98adb6bcdd~tplv-t2oaga2asx-watermark.awebp"></p><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><p>考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求</p><pre><code>request(&#123;      url,      method = &quot;post&quot;,      data,      headers = &#123;&#125;,      requestList    &#125;) &#123;      return new Promise(resolve =&gt; &#123;        const xhr = new XMLHttpRequest();        xhr.open(method, url);        Object.keys(headers).forEach(key =&gt;          xhr.setRequestHeader(key, headers[key])        );        xhr.send(data);        xhr.onload = e =&gt; &#123;          resolve(&#123;            data: e.target.response          &#125;);        &#125;;      &#125;);    &#125;</code></pre><h3 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h3><p>接着实现比较重要的上传功能，上传需要做两件事</p><ul><li><p>对文件进行切片</p></li><li><p>将切片传输给服务端</p>  <template>    <div>      <input type="file" @change="handleFileChange" />      <el-button @click="handleUpload">上传</el-button>    </div>  </template>    <script>   const SIZE = 10 * 1024 * 1024; // 切片大小   export default {    data: () => ({      container: {        file: null      }，     data: []    }),    methods: {      request() {},      handleFileChange() {},      // 生成文件切片      createFileChunk(file, size = SIZE) {       const fileChunkList = [];        let cur = 0;        while (cur < file.size) {          fileChunkList.push({ file: file.slice(cur, cur + size) });          cur += size;        }        return fileChunkList;      },     // 上传切片      async uploadChunks() {        const requestList = this.data          .map(({ chunk，hash }) => {            const formData = new FormData();            formData.append("chunk", chunk);            formData.append("hash", hash);            formData.append("filename", this.container.file.name);            return { formData };          })          .map(async ({ formData }) =>            this.request({              url: "http://localhost:3000",              data: formData            })          );        await Promise.all(requestList); // 并发切片      },      async handleUpload() {        if (!this.container.file) return;        const fileChunkList = this.createFileChunk(this.container.file);        this.data = fileChunkList.map(({ file }，index) => ({          chunk: file,          hash: this.container.file.name + "-" + index // 文件名 + 数组下标        }));        await this.uploadChunks();      }    }  };  </script><p>  当点击上传按钮时，调用 <code>createFileChunk</code> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说 100 MB 的文件会被分成 10 个切片</p><p>  createFileChunk 内使用 while 循环和 slice 方法将切片放入 <code>fileChunkList</code> 数组中返回</p><p>  在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<code>文件名 + 下标</code>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p><p>  随后调用 <code>uploadChunks</code> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 <code>request</code> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p><h3 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h3><p>  这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片</p>  <template>    <div>      <input type="file" @change="handleFileChange" />      <el-button @click="handleUpload">上传</el-button>    </div>  </template>    <script>  export default {    data: () => ({      container: {        file: null      },      data: []    }),    methods: {      request() {},      handleFileChange() {},      createFileChunk() {},      // 上传切片，同时过滤已上传的切片      async uploadChunks() {        const requestList = this.data          .map(({ chunk，hash }) => {            const formData = new FormData();            formData.append("chunk", chunk);            formData.append("hash", hash);            formData.append("filename", this.container.file.name);            return { formData };          })          .map(async ({ formData }) =>            this.request({              url: "http://localhost:3000",              data: formData            })          );        await Promise.all(requestList);        // 合并切片       await this.mergeRequest();     },      async mergeRequest() {        await this.request({          url: "http://localhost:3000/merge",          headers: {            "content-type": "application/json"          },          data: JSON.stringify({            filename: this.container.file.name          })        });      },          async handleUpload() {}    }  };  </script></li></ul><h2 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h2><p>简单使用 http 模块搭建服务端</p><pre><code>const http = require(&quot;http&quot;);const server = http.createServer();server.on(&quot;request&quot;, async (req, res) =&gt; &#123;  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);  if (req.method === &quot;OPTIONS&quot;) &#123;    res.status = 200;    res.end();    return;  &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</code></pre><h3 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h3><p>使用 <code>multiparty</code> 包处理前端传来的 FormData</p><p>在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，fields 参数保存了 FormData 中非文件的字段</p><pre><code>const http = require(&quot;http&quot;);const path = require(&quot;path&quot;);const fse = require(&quot;fs-extra&quot;);const multiparty = require(&quot;multiparty&quot;);const server = http.createServer(); const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录server.on(&quot;request&quot;, async (req, res) =&gt; &#123;  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);  if (req.method === &quot;OPTIONS&quot;) &#123;    res.status = 200;    res.end();    return;  &#125;  const multipart = new multiparty.Form();  multipart.parse(req, async (err, fields, files) =&gt; &#123;    if (err) &#123;      return;    &#125;    const [chunk] = files.chunk;    const [hash] = fields.hash;    const [filename] = fields.filename;    const chunkDir = path.resolve(UPLOAD_DIR, filename);   // 切片目录不存在，创建切片目录    if (!fse.existsSync(chunkDir)) &#123;      await fse.mkdirs(chunkDir);    &#125;      // fs-extra 专用方法，类似 fs.rename 并且跨平台      // fs-extra 的 rename 方法 windows 平台会有权限问题      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835      await fse.move(chunk.path, `$&#123;chunkDir&#125;/$&#123;hash&#125;`);    res.end(&quot;received file chunk&quot;);  &#125;);&#125;);server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/11/16f905fb6a626f47~tplv-t2oaga2asx-watermark.awebp"></p><p>查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename(由于我用的是 fs-extra，它的 rename 方法 windows 平台权限问题，所以换成了 fse.move) 移动临时文件，即移动文件切片</p><p>在接受文件切片时，需要先创建存储切片的文件夹，由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中，最后的结果如下</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f83c3caac8eb65~tplv-t2oaga2asx-watermark.awebp"></p><h3 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h3><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p><pre><code>const http = require(&quot;http&quot;);const path = require(&quot;path&quot;);const fse = require(&quot;fs-extra&quot;);const server = http.createServer();const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录 const resolvePost = req =&gt;   new Promise(resolve =&gt; &#123;     let chunk = &quot;&quot;;     req.on(&quot;data&quot;, data =&gt; &#123;       chunk += data;     &#125;);     req.on(&quot;end&quot;, () =&gt; &#123;       resolve(JSON.parse(chunk));     &#125;);   &#125;); const pipeStream = (path, writeStream) =&gt;  new Promise(resolve =&gt; &#123;    const readStream = fse.createReadStream(path);    readStream.on(&quot;end&quot;, () =&gt; &#123;      fse.unlinkSync(path);      resolve();    &#125;);    readStream.pipe(writeStream);  &#125;);// 合并切片 const mergeFileChunk = async (filePath, filename, size) =&gt; &#123;  const chunkDir = path.resolve(UPLOAD_DIR, filename);  const chunkPaths = await fse.readdir(chunkDir);  // 根据切片下标进行排序  // 否则直接读取目录的获得的顺序可能会错乱  chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);  await Promise.all(    chunkPaths.map((chunkPath, index) =&gt;      pipeStream(        path.resolve(chunkDir, chunkPath),        // 指定位置创建可写流        fse.createWriteStream(filePath, &#123;          start: index * size,          end: (index + 1) * size        &#125;)      )    )  );  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录&#125;;server.on(&quot;request&quot;, async (req, res) =&gt; &#123;  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);  if (req.method === &quot;OPTIONS&quot;) &#123;    res.status = 200;    res.end();    return;  &#125;   if (req.url === &quot;/merge&quot;) &#123;     const data = await resolvePost(req);     const &#123; filename,size &#125; = data;     const filePath = path.resolve(UPLOAD_DIR, `$&#123;filename&#125;`);     await mergeFileChunk(filePath, filename);     res.end(       JSON.stringify(&#123;         code: 0,         message: &quot;file merged success&quot;       &#125;)     );   &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</code></pre><p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹</p><p>接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是<strong>切片文件夹名 + 后缀名</strong>组合而成</p><p>随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中</p><p>值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start/end 控制的，目的是能够并发合并多个可读流到可写流中，这样即使流的顺序不同也能传输到正确的位置，所以这里还需要让前端在请求的时候多提供一个 size 参数</p><pre><code>async mergeRequest() &#123;  await this.request(&#123;    url: &quot;http://localhost:3000/merge&quot;,    headers: &#123;      &quot;content-type&quot;: &quot;application/json&quot;    &#125;,    data: JSON.stringify(&#123;     size: SIZE,      filename: this.container.file.name    &#125;)  &#125;);&#125;,</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/22/16fccc5d950c2275~tplv-t2oaga2asx-watermark.awebp"></p><p>其实也可以等上一个切片合并完后再合并下个切片，这样就不需要指定位置，但传输速度会降低，所以使用了并发合并的手段，接着只要保证每次合并完成后删除这个切片，等所有切片都合并完毕后最后删除切片文件夹即可</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f8414c7fae1c1f~tplv-t2oaga2asx-watermark.awebp"></p><p>至此一个简单的大文件上传就完成了，接下来我们再此基础上扩展一些额外的功能</p><h2 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h2><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度</p><h3 id="切片进度条"><a href="#切片进度条" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p><pre><code>// xhrrequest(&#123;  url,  method = &quot;post&quot;,  data,  headers = &#123;&#125;,  onProgress = e =&gt; e,  requestList&#125;) &#123;  return new Promise(resolve =&gt; &#123;    const xhr = new XMLHttpRequest();   xhr.upload.onprogress = onProgress;    xhr.open(method, url);    Object.keys(headers).forEach(key =&gt;      xhr.setRequestHeader(key, headers[key])    );    xhr.send(data);    xhr.onload = e =&gt; &#123;      resolve(&#123;        data: e.target.response      &#125;);    &#125;;  &#125;);&#125;</code></pre><p>由于每个切片都需要触发独立的监听事件，所以还需要一个工厂函数，根据传入的切片返回不同的监听函数<br>在原先的前端上传逻辑中新增监听函数部分</p><pre><code>// 上传切片，同时过滤已上传的切片async uploadChunks(uploadedList = []) &#123;  const requestList = this.data   .map((&#123; chunk,hash,index &#125;) =&gt; &#123;      const formData = new FormData();      formData.append(&quot;chunk&quot;, chunk);      formData.append(&quot;hash&quot;, hash);      formData.append(&quot;filename&quot;, this.container.file.name);     return &#123; formData,index &#125;;    &#125;)   .map(async (&#123; formData,index &#125;) =&gt;      this.request(&#123;        url: &quot;http://localhost:3000&quot;,        data: formData，       onProgress: this.createProgressHandler(this.data[index]),      &#125;)    );  await Promise.all(requestList);   // 合并切片  await this.mergeRequest();&#125;,async handleUpload() &#123;  if (!this.container.file) return;  const fileChunkList = this.createFileChunk(this.container.file);  this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;    chunk: file,   index,    hash: this.container.file.name + &quot;-&quot; + index   percentage:0  &#125;));  await this.uploadChunks();&#125;createProgressHandler(item) &#123;  return e =&gt; &#123;    item.percentage = parseInt(String((e.loaded / e.total) * 100));  &#125;;&#125;</code></pre><p>每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可</p><h3 id="文件进度条"><a href="#文件进度条" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 计算属性</p><pre><code>computed: &#123;   uploadPercentage() &#123;      if (!this.container.file || !this.data.length) return 0;      const loaded = this.data        .map(item =&gt; item.size * item.percentage)        .reduce((acc, cur) =&gt; acc + cur);      return parseInt((loaded / this.container.file.size).toFixed(2));    &#125;&#125;</code></pre><p>最终视图如下</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f84ad6b4848423~tplv-t2oaga2asx-watermark.awebp"></p><h1 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h1><p>断点续传的原理在于前端/服务端需要<code>记住</code>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p><ul><li>前端使用 localStorage 记录已上传的切片 hash</li><li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片</li></ul><p>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选取后者</p><h2 id="生成-hash"><a href="#生成-hash" class="headerlink" title="生成 hash"></a>生成 hash</h2><p>无论是前端还是服务端，都必须要生成文件和切片的 hash，<code>之前我们使用文件名 + 切片下标作为切片 hash</code>，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是<code>根据文件内容生成 hash</code>，所以我们修改一下 hash 的生成规则</p><p>这里用到另一个库 <code>spark-md5</code>，它可以根据文件内容计算出文件的 hash 值，另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<code>引起 UI 的阻塞</code>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互</p><p>由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了<code>importScripts</code> 函数用于导入外部脚本，通过它导入 spark-md5</p><pre><code>// /public/hash.jsself.importScripts(&quot;/spark-md5.min.js&quot;); // 导入脚本// 生成文件 hashself.onmessage = e =&gt; &#123;  const &#123; fileChunkList &#125; = e.data;  const spark = new self.SparkMD5.ArrayBuffer();  let percentage = 0;  let count = 0;  const loadNext = index =&gt; &#123;    const reader = new FileReader();    reader.readAsArrayBuffer(fileChunkList[index].file);    reader.onload = e =&gt; &#123;      count++;      spark.append(e.target.result);      if (count === fileChunkList.length) &#123;        self.postMessage(&#123;          percentage: 100,          hash: spark.end()        &#125;);        self.close();      &#125; else &#123;        percentage += 100 / fileChunkList.length;        self.postMessage(&#123;          percentage        &#125;);        // 递归计算下一个切片        loadNext(count);      &#125;    &#125;;  &#125;;  loadNext(0);&#125;;</code></pre><p>在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程</p><p><code>spark-md5 需要根据所有切片才能算出一个 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash，具体可以看官方文档</code></p><p><a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/spark-md5">spark-md5</a></p><p>接着编写主线程与 worker 线程通讯的逻辑</p><pre><code>   // 生成文件 hash（web-worker）calculateHash(fileChunkList) &#123;  return new Promise(resolve =&gt; &#123;   // 添加 worker 属性    this.container.worker = new Worker(&quot;/hash.js&quot;);    this.container.worker.postMessage(&#123; fileChunkList &#125;);    this.container.worker.onmessage = e =&gt; &#123;      const &#123; percentage, hash &#125; = e.data;      this.hashPercentage = percentage;      if (hash) &#123;        resolve(hash);      &#125;    &#125;;  &#125;);&#125;,async handleUpload() &#123;  if (!this.container.file) return;  const fileChunkList = this.createFileChunk(this.container.file); this.container.hash = await this.calculateHash(fileChunkList);  this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;   fileHash: this.container.hash,    chunk: file,    hash: this.container.file.name + &quot;-&quot; + index, // 文件名 + 数组下标    percentage:0  &#125;));  await this.uploadChunks();&#125;</code></pre><p>主线程使用 <code>postMessage</code> 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash</p><p>加上显示计算 hash 的进度条，看起来像这样</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f84ae4f233e891~tplv-t2oaga2asx-watermark.awebp"></p><p>至此前端需要将之前用文件名作为 hash 的地方改写为 workder 返回的这个 hash</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f84b3bba953304~tplv-t2oaga2asx-watermark.awebp"></p><p>服务端则使用 hash 作为切片文件夹名，hash + 下标作为切片名，hash + 扩展名作为文件名，没有新增的逻辑</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f84b50117e4db2~tplv-t2oaga2asx-watermark.awebp"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f84b33bbceaa48~tplv-t2oaga2asx-watermark.awebp"></p><h2 id="文件秒传"><a href="#文件秒传" class="headerlink" title="文件秒传"></a>文件秒传</h2><p>在实现断点续传前先简单介绍一下文件秒传</p><p>所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户<code>再次上传</code>时会直接提示上传成功</p><p>文件秒传需要依赖上一步生成的 hash，即在<code>上传前</code>，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p><pre><code>async verifyUpload(filename, fileHash) &#123;   const &#123; data &#125; = await this.request(&#123;     url: &quot;http://localhost:3000/verify&quot;,     headers: &#123;       &quot;content-type&quot;: &quot;application/json&quot;     &#125;,     data: JSON.stringify(&#123;       filename,       fileHash     &#125;)   &#125;);   return JSON.parse(data); &#125;,async handleUpload() &#123;  if (!this.container.file) return;  const fileChunkList = this.createFileChunk(this.container.file);  this.container.hash = await this.calculateHash(fileChunkList); const &#123; shouldUpload &#125; = await this.verifyUpload(   this.container.file.name,   this.container.hash ); if (!shouldUpload) &#123;   this.$message.success(&quot;秒传：上传成功&quot;);   return;&#125; this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;    fileHash: this.container.hash,    index,    hash: this.container.hash + &quot;-&quot; + index,    chunk: file,    percentage: 0  &#125;));  await this.uploadChunks();&#125;</code></pre><p>秒传其实就是给用户看的障眼法，实质上根本没有上传</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/9/16f890e5967106c6~tplv-t2oaga2asx-watermark.awebp"></p><p>服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可</p><pre><code>const extractExt = filename =&gt;filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录const resolvePost = req =&gt;  new Promise(resolve =&gt; &#123;    let chunk = &quot;&quot;;    req.on(&quot;data&quot;, data =&gt; &#123;      chunk += data;    &#125;);    req.on(&quot;end&quot;, () =&gt; &#123;      resolve(JSON.parse(chunk));    &#125;);  &#125;);server.on(&quot;request&quot;, async (req, res) =&gt; &#123;  if (req.url === &quot;/verify&quot;) &#123;    const data = await resolvePost(req);    const &#123; fileHash, filename &#125; = data;    const ext = extractExt(filename);    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);    if (fse.existsSync(filePath)) &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: false        &#125;)      );    &#125; else &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: true        &#125;)      );    &#125;  &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</code></pre><h2 id="暂停上传"><a href="#暂停上传" class="headerlink" title="暂停上传"></a>暂停上传</h2><p>讲完了生成 hash 和文件秒传，回到断点续传</p><p>断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传</p><p>原理是使用 XMLHttpRequest 的 <code>abort</code> 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p><pre><code>request(&#123;  url,  method = &quot;post&quot;,  data,  headers = &#123;&#125;,  onProgress = e =&gt; e, requestList&#125;) &#123;  return new Promise(resolve =&gt; &#123;    const xhr = new XMLHttpRequest();    xhr.upload.onprogress = onProgress;    xhr.open(method, url);    Object.keys(headers).forEach(key =&gt;      xhr.setRequestHeader(key, headers[key])    );    xhr.send(data);    xhr.onload = e =&gt; &#123;      // 将请求成功的 xhr 从列表中删除      if (requestList) &#123;        const xhrIndex = requestList.findIndex(item =&gt; item === xhr);        requestList.splice(xhrIndex, 1);      &#125;      resolve(&#123;        data: e.target.response      &#125;);    &#125;;    // 暴露当前 xhr 给外部    requestList?.push(xhr);  &#125;);&#125;,</code></pre><p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f8563491ea7793~tplv-t2oaga2asx-watermark.awebp"></p><p>每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存<code>正在上传切片的 xhr</code></p><p>之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p><pre><code>handlePause() &#123;    this.requestList.forEach(xhr =&gt; xhr?.abort());    this.requestList = [];&#125;</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/9/16f890e598dd6afb~tplv-t2oaga2asx-watermark.awebp"></p><p>点击暂停按钮可以看到 xhr 都被取消了</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/8/16f85644dc27459e~tplv-t2oaga2asx-watermark.awebp"></p><h2 id="恢复上传"><a href="#恢复上传" class="headerlink" title="恢复上传"></a>恢复上传</h2><p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传</p><p>由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果</p><p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p><ul><li>服务端已存在该文件，不需要再次上传</li><li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端</li></ul><p>所以我们改造一下之前文件秒传的服务端验证接口</p><pre><code>const extractExt = filename =&gt;  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录const resolvePost = req =&gt;  new Promise(resolve =&gt; &#123;    let chunk = &quot;&quot;;    req.on(&quot;data&quot;, data =&gt; &#123;      chunk += data;    &#125;);    req.on(&quot;end&quot;, () =&gt; &#123;      resolve(JSON.parse(chunk));    &#125;);  &#125;);  // 返回已经上传切片名列表 const createUploadedList = async fileHash =&gt;   fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))    ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash))    : [];server.on(&quot;request&quot;, async (req, res) =&gt; &#123;  if (req.url === &quot;/verify&quot;) &#123;    const data = await resolvePost(req);    const &#123; fileHash, filename &#125; = data;    const ext = extractExt(filename);    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);    if (fse.existsSync(filePath)) &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: false        &#125;)      );    &#125; else &#123;      res.end(        JSON.stringify(&#123;          shouldUpload: true，         uploadedList: await createUploadedList(fileHash)        &#125;)      );    &#125;  &#125;&#125;);server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</code></pre><p>接着回到前端，前端有两个地方需要调用验证的接口</p><ul><li>点击上传时，检查是否需要上传和已上传的切片</li><li>点击暂停后的恢复上传，返回已上传的切片</li></ul><p>新增恢复按钮并改造原来上传切片的逻辑</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;      &lt;input        type=&quot;file&quot;        @change=&quot;handleFileChange&quot;      /&gt;       &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;       &lt;el-button @click=&quot;handlePause&quot; v-if=&quot;isPaused&quot;&gt;暂停&lt;/el-button&gt;      &lt;el-button @click=&quot;handleResume&quot; v-else&gt;恢复&lt;/el-button&gt;      //...    &lt;/div&gt;&lt;/template&gt;async handleResume() &#123;  const &#123; uploadedList &#125; = await this.verifyUpload(    this.container.file.name,    this.container.hash  );  await this.uploadChunks(uploadedList);&#125;,async handleUpload() &#123;  if (!this.container.file) return;  const fileChunkList = this.createFileChunk(this.container.file);  this.container.hash = await this.calculateHash(fileChunkList); const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload(    this.container.file.name,    this.container.hash  );  if (!shouldUpload) &#123;    this.$message.success(&quot;秒传：上传成功&quot;);    return;  &#125;  this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;    fileHash: this.container.hash,    index,    hash: this.container.hash + &quot;-&quot; + index,    chunk: file，    percentage: 0  &#125;));  await this.uploadChunks(uploadedList);&#125;,// 上传切片，同时过滤已上传的切片async uploadChunks(uploadedList = []) &#123;  const requestList = this.data    .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash))    .map((&#123; chunk, hash, index &#125;) =&gt; &#123;      const formData = new FormData();      formData.append(&quot;chunk&quot;, chunk);      formData.append(&quot;hash&quot;, hash);      formData.append(&quot;filename&quot;, this.container.file.name);      formData.append(&quot;fileHash&quot;, this.container.hash);      return &#123; formData, index &#125;;    &#125;)    .map(async (&#123; formData, index &#125;) =&gt;      this.request(&#123;        url: &quot;http://localhost:3000&quot;,        data: formData,        onProgress: this.createProgressHandler(this.data[index]),        requestList: this.requestList      &#125;)    );  await Promise.all(requestList);  // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时  // 合并切片  if (uploadedList.length + requestList.length === this.data.length) &#123;     await this.mergeRequest();  &#125;&#125;</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/9/16f890e598de0946~tplv-t2oaga2asx-watermark.awebp"></p><p>这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动</p><p>到这里断点续传的功能基本完成了</p><h2 id="进度条改进"><a href="#进度条改进" class="headerlink" title="进度条改进"></a>进度条改进</h2><p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传/接收到已上传切片时的进度条会出现偏差</p><h3 id="切片进度条-1"><a href="#切片进度条-1" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>由于在点击上传/恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%</p><pre><code>async handleUpload() &#123;  if (!this.container.file) return;  const fileChunkList = this.createFileChunk(this.container.file);  this.container.hash = await this.calculateHash(fileChunkList);  const &#123; shouldUpload, uploadedList &#125; = await this.verifyUpload(    this.container.file.name,    this.container.hash  );  if (!shouldUpload) &#123;    this.$message.success(&quot;秒传：上传成功&quot;);    return;  &#125;  this.data = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;    fileHash: this.container.hash,    index,    hash: this.container.hash + &quot;-&quot; + index,    chunk: file,   percentage: uploadedList.includes(index) ? 100 : 0  &#125;));  await this.uploadChunks(uploadedList);&#125;,</code></pre><p>uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可</p><h3 id="文件进度条-1"><a href="#文件进度条-1" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>之前说到文件进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/9/16f8845dcca1427c~tplv-t2oaga2asx-watermark.awebp"></p><p>点击暂停会取消并清空切片的 xhr 请求，此时如果已经上传了一部分，就会发现文件进度条有<code>倒退</code>的现象</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/9/16f884633f3acfd9~tplv-t2oaga2asx-watermark.awebp"></p><p>当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退</p><p>解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条</p><p>这里我们使用 Vue 的监听属性</p><pre><code>data: () =&gt; (&#123;  fakeUploadPercentage: 0&#125;),computed: &#123;  uploadPercentage() &#123;    if (!this.container.file || !this.data.length) return 0;    const loaded = this.data      .map(item =&gt; item.size * item.percentage)      .reduce((acc, cur) =&gt; acc + cur);    return parseInt((loaded / this.container.file.size).toFixed(2));  &#125;&#125;,watch: &#123;  uploadPercentage(now) &#123;    if (now &gt; this.fakeUploadPercentage) &#123;      this.fakeUploadPercentage = now;    &#125;  &#125;&#125;,</code></pre><p>当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可</p><p>至此一个大文件上传 + 断点续传的解决方案就完成了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大文件上传</p><ul><li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li><li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li><li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li><li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li></ul><p>断点续传</p><ul><li>使用 spark-md5 根据文件内容算出文件 hash</li><li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li><li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li><li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传</li></ul><h1 id="反馈的问题"><a href="#反馈的问题" class="headerlink" title="反馈的问题"></a>反馈的问题</h1><p>部分功能由于不方便测试，这里列出评论区收集到的一些问题，有兴趣的朋友可以提出你的想法/写个 demo 进一步交流</p><ul><li>没有做切片上传失败的处理</li><li>使用 web socket 由服务端发送进度信息</li><li>打开页面没有自动获取上传切片，而需要主动再次上传一次后才显示</li></ul><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>源代码增加了一些按钮的状态，交互更加友好，文章表达比较晦涩的地方可以跳转到源代码查看</p><p><a href="https://link.juejin.cn/?target=https://github.com/yeyan1996/file-upload">file-upload</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite</title>
      <link href="/2022/09/30/article25/"/>
      <url>/2022/09/30/article25/</url>
      
        <content type="html"><![CDATA[<h2 id="Vite-的定义"><a href="#Vite-的定义" class="headerlink" title="Vite 的定义"></a>Vite 的定义</h2><p>面向现代浏览器的一个更轻、更快的 Web 应用开发工具，基于 ECMAScript 标准原生模块系统（ES Modules）实现。</p><h2 id="Vite-的特点"><a href="#Vite-的特点" class="headerlink" title="Vite 的特点"></a>Vite 的特点</h2><ul><li>闪电般快速的冷服务器启动</li><li>即时热模块更换（HMR）</li><li>真正的按需编译</li></ul><p>实际上，刚接触这个这个框架给人最直观的感受就是轻巧、利落，冷启动速度可以说是秒开，开发体验极度舒适，真应了尤大发表的感言让人再也不想用 webpack。</p><h2 id="为什么-Vite-启动速度快？"><a href="#为什么-Vite-启动速度快？" class="headerlink" title="为什么 Vite 启动速度快？"></a>为什么 Vite 启动速度快？</h2><p>vite 利用现代浏览器原生支持 ESM 特性，省略了对模块的打包，只有具体去请求某个文件时才会按需编译，vite 会根据 import 导入替换路径在前面加上@modules，然后去 node_modules 寻找相关依赖，再分别对 template、script、style 进行处理；而 webpack 会提前把所有模块进行编译，所以随着项目越来越大，启动速度也就越慢。下面进入图解环节：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8ac94ecc23449d9b2928f5123767d85~tplv-k3u1fbpfcp-watermark.awebp"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbc4e55ef0824e8d9c44329a6ba2d770~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><code>npm init vite-app demo</code></p><p>在命令窗口里输入这句命令即可创建一个 vite 的项目，而且还非常贴心的提示了后续操作，所以我这里就不多说了，按照命令窗口的提示安装依赖就好。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82663442c8e94716b4d4e5c054bfd055~tplv-k3u1fbpfcp-watermark.awebp"></p><p>目录结构还是和以前一样，业务都写在 src 里</p><p>然后执行<code>npm run dev</code> 启动项目</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/520f439a7d894d7dbc7cc97a2eb68a50~tplv-k3u1fbpfcp-watermark.awebp"></p><p>项目启动后你会看到一个这样的页面，和以往的 hello vue 不同，这里简单的实现了一个计数器功能</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c022c5b11fe40e98e5c89172b5ba7ad~tplv-k3u1fbpfcp-watermark.awebp"></p><p>这里还是以 vue2 的方式实现的小功能，实际上这里可以用 vue3 的 Composition API 入口 setup 实现，需要注意的是在 setup 里是没有实例对象 this 的，声明的变量必须在函数底部统一返回才能使用，并且他的执行是在旧生命函数里面的 beforeCreate 和 created 之间。</p><h2 id="Vite-与-TypeScript"><a href="#Vite-与-TypeScript" class="headerlink" title="Vite 与 TypeScript"></a>Vite 与 TypeScript</h2><p>前端应用的复杂度不断飙升，这带来的问题就是维护性以及扩展性会变差，使用 ts 编写代码会大大降低调试 bug 的时间，安装 ts 依赖后，在 vue3 里你只需要在 script 标签上加一个<code>lang=&#39;ts&#39;</code>就可以引入 ts 愉快的编码了。</p><p>在 vite 项目里使用 ts 是再合适不过了，vite 目前就只适用于 vue3 的版本（这里不考虑其余框架），而 vue3 就是用 ts 写的，所以对 ts 开发者非常友好，如果没有用过 ts 也没关系，vue3 只是对 ts 使用者更友好，而不是只能用 ts（当然这里还是推荐大家用 ts）。</p><h2 id="Vite-打包"><a href="#Vite-打包" class="headerlink" title="Vite 打包"></a>Vite 打包</h2><p>vite 打包内部采用的是 Rollup 完成的应用打包，因为 vite 高度依赖 ES Modules 特性所以只支持现代浏览器，抛弃 IE 市场，如果你需要兼容 IE 需要另做处理，详情可以参考<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">这里。</a></p><p>你只需要在终端执行 <code>npm run build</code> 打包过程轻松又愉快，先不要高兴的太早，这时候如果你打开 dist 文件下的打包文件会发现页面显示不出来，一拍脑门想起来在<code>vue.config.js</code>里面配置一下<code>publicPath: &#39;./&#39;</code>，不过当你做完这一切之后发现并没有解决问题，why？在这里先不要慌，只需要继续向下看。</p><p>解决办法：</p><p>这是因为 vue 打包后的路径默认是根路径，而在 vite 里面的配置文件是<code>vite.config.js</code>，所以同理，你只需要在配置里写上<code>base: &#39;./&#39;</code>即可轻松解决。</p><h2 id="配置路由和状态管理"><a href="#配置路由和状态管理" class="headerlink" title="配置路由和状态管理"></a>配置路由和状态管理</h2><p>路由配置</p><pre><code>// router/indeximport &#123; createRouter, createWebHistory, RouteRecordRaw &#125; from &#39;vue-router&#39;const routes: Array&lt;RouteRecordRaw&gt; =[ &#123;    path: &#39;/&#39;,    name: &#39;Home&#39;,    component: import(&#39;/@views/Home&#39;) &#125;, &#123;    path: &#39;/user&#39;,    name: &#39;User&#39;,    component: () =&gt; import(&#39;/@views/User&#39;) &#125;]const router = createRouter(&#123;    history: createWebHistory(process.env.BASE_URL),    routes&#125;)export default router</code></pre><p>vuex 配置</p><pre><code>// store/indeximport &#123; createStore &#125; from &#39;vuex&#39;export default createStore(&#123;    state: &#123;&#125;,    mutations: &#123;&#125;,    actions: &#123;&#125;,    modules: &#123;&#125;&#125;)</code></pre><p>更轻量的依赖注入工具 provide、inject 函数可以替代 vuex，两者可根据个人习惯二选一。</p><pre><code>import &#123; provide, inject &#125; from &#39;vue&#39;const Ancestor = &#123;  setup() &#123;    provide(&quot;name&quot;, &quot;我是父组件向子组件传递的值&quot;);  &#125;&#125;const Descendent = &#123;  setup() &#123;    const name = inject(&quot;name&quot;)    return &#123;      name    &#125;  &#125;&#125;</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过介绍大家应该对 vite 有一个初步的理解了，值得一说的是 vite 开发体验真的舒适，快一秒也是快啊，更何况不止快一秒呢，有时候不就差那几秒 😊</p>]]></content>
      
      
      <categories>
          
          <category> Vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>炫酷的 CSS 文字特效</title>
      <link href="/2022/09/01/article24/"/>
      <url>/2022/09/01/article24/</url>
      
        <content type="html"><![CDATA[<h2 id="一、实现线性渐变的文字"><a href="#一、实现线性渐变的文字" class="headerlink" title="一、实现线性渐变的文字"></a>一、实现线性渐变的文字</h2><p>实例描述：在网页制作时，可以通过对文字颜色的设置来实现网页的特殊效果。本实例将使用 CSS3 实现文字线性渐变的效果。运行实例，在页面中会输出一串线性渐变的文字 <code>人生苦短，我用Python</code>，结果如下图所示：</p><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813124246315-655954642.png"></p><p>技术要点：本实例主要使用了 CSS3 中的 linear-gradient() 函数，该函数用于创建一个线性渐变的图像。语法格式如下：</p><pre><code>background:linear-gradient(direction, color-stop1, color-stop2, …)/*参数说明：\1. direction：设置渐变的方向，可以使用角度值。\2. color-stop1, color-stop2, …：指定渐变的起止颜色。*/</code></pre><h2 id="二、制作文字阴影效果"><a href="#二、制作文字阴影效果" class="headerlink" title="二、制作文字阴影效果"></a>二、制作文字阴影效果</h2><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813124438144-2087509045.png"></p><p>技术要点：本实例主要使用了 CSS3 中的 text-shadow 属性，该属性用于向文本设置阴影。语法格式如下：</p><pre><code>text-shadow: h-shadow v-shadow blur color;/*参数说明：h-shadow：必选参数，用于设置水平阴影的位置，可以为负值。v-shadow：必选参数，用于设置垂直阴影的位置，可以为负值。blur：可选参数，用于设置模糊的距离。color：可选参数，用于设置阴影的颜色。*/</code></pre><h2 id="三、实现文字的荧光闪烁效果"><a href="#三、实现文字的荧光闪烁效果" class="headerlink" title="三、实现文字的荧光闪烁效果"></a>三、实现文字的荧光闪烁效果</h2><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813125627494-376405160.png"></p><p><code>animation: name duration timing-function delay iteration-count direction;</code></p><p>参数说明如下表所示：</p><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813125716122-1364222231.png"></p><h2 id="五、制作镂空文字"><a href="#五、制作镂空文字" class="headerlink" title="五、制作镂空文字"></a>五、制作镂空文字</h2><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813125131298-1439491023.png"></p><p>技术要点：在本实例中，实现文字的镂空效果主要应用了 CSS3 中的 text-stroke 属性，通过该属性可以设置文字的描边效果。语法格式如下：</p><pre><code>text-stroke:[text-stroke-width] || [text-stroke-color]/*参数说明： text-stroke-width：设置文字的描边厚度。text-stroke-color：设置文字的描边颜色。*/</code></pre><h2 id="六、实现文字的倾斜效果"><a href="#六、实现文字的倾斜效果" class="headerlink" title="六、实现文字的倾斜效果"></a>六、实现文字的倾斜效果</h2><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813125458633-503000637.png"></p><pre><code>text-stroke:[text-stroke-width] || [text-stroke-color]/*参数说明： text-stroke-width：设置文字的描边厚度。text-stroke-color：设置文字的描边颜色。*/</code></pre><h2 id="七、实现火焰文字"><a href="#七、实现火焰文字" class="headerlink" title="七、实现火焰文字"></a>七、实现火焰文字</h2><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813125826147-1767245020.png"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;实现火焰文字&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body&#123;font-size:120px; /*设置字体大小*/font-weight:bold; /*设置字体粗细*/font-family:&#39;微软雅黑&#39;; /*设置字体*/background:#000; /*设置页面背景颜色*/color:#fff; /*设置文字颜色*/text-align:center/*设置文字居中*/&#125;div&#123;text-shadow:0 0 20px #fefcc9,10px -10px 30px #feec85,-20px -20px 40px #ffae34,20px -40px 50px #ec760c,0 -80px 70px #f38e1c; /*设置文字阴影*/-webkit-animation: flame 2s infinite; /*设置动画*/&#125;@-webkit-keyframes flame&#123; /*创建动画*/0%&#123;text-shadow:0 0 20px #fefcc9,10px -10px 30px #feec85,-20px -20px 40px #ffae34,20px -40px 50px #ec760c,0 -80px 70px #f38e1c;&#125;30%&#123;text-shadow:0 0 20px #fefcc9,10px -10px 30px #feec85,-20px -20px 40px #ffae34,20px -40px 50px #ec760c,10px -90px 80px #f38e1c;&#125;60%&#123;text-shadow:0 0 20px #fefcc9,10px -10px 30px #feec85,-20px -20px 40px #ffae34,20px -40px 50px #ec760c,0px -80px 100px #f38e1c;&#125;100%&#123;text-shadow:0 0 20px #fefcc9,10px -10px 30px #feec85,-20px -20px 40px #ffae34,20px -40px 50px #ec760c,0 -80px 70px #f38e1c;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;星星之火可以燎原&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="八、使用-SVG-创建空心虚线线条文字"><a href="#八、使用-SVG-创建空心虚线线条文字" class="headerlink" title="八、使用 SVG 创建空心虚线线条文字"></a>八、使用 SVG 创建空心虚线线条文字</h2><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813130022598-1290072040.png"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;text&#123;font-family:SimHei; /*定义字体*/font-size:56px; /*定义文字大小*/font-weight:bolder; /*定义字体粗细*/fill:transparent; /*定义文字透明*/stroke:#0000FF; /*定义描边颜色*/stroke-dasharray:3; /*定义虚线长度和虚线间距*/&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;svg width=&quot;600&quot; height=&quot;300&quot;&gt;&lt;text x=&quot;30&quot; y=&quot;150&quot;&gt;人生苦短，我用Python&lt;/text&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="九、使用-SVG-实现文字沿曲线显示效果"><a href="#九、使用-SVG-实现文字沿曲线显示效果" class="headerlink" title="九、使用 SVG 实现文字沿曲线显示效果"></a>九、使用 SVG 实现文字沿曲线显示效果</h2><p><img src="https://img2020.cnblogs.com/blog/2423513/202108/2423513-20210813130155895-469616243.png"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;使用SVG实现文字沿曲线显示效果&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;text&#123;font-family:SimHei;/*定义字体*/font-size:33px;/*定义文字大小*/fill:url(#linear);/*定义文字颜色线性渐变*/&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;svg width=&quot;1000&quot; height=&quot;800&quot;&gt;&lt;defs&gt;&lt;path id=&quot;textPath&quot; d=&quot;M130,140 C130,240 330,240 330,140 S510,60 510,140&quot;/&gt;&lt;linearGradient id=&quot;linear&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;0%&quot;&gt;&lt;stop offset=&quot;0%&quot; stop-color=&quot;#FF0000&quot;&gt;&lt;/stop&gt;&lt;stop offset=&quot;50%&quot; stop-color=&quot;#00FF00&quot;&gt;&lt;/stop&gt;&lt;stop offset=&quot;100%&quot; stop-color=&quot;#0000FF&quot;&gt;&lt;/stop&gt;&lt;/linearGradient&gt;&lt;/defs&gt;&lt;text dy=&quot;10&quot;&gt;&lt;textPath xlink:href=&quot;#textPath&quot;&gt;世界会向那些有目标和远见的人让路&lt;/textPath&gt;&lt;/text&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冗余导航（路由冗余）解决方式</title>
      <link href="/2022/08/10/article23/"/>
      <url>/2022/08/10/article23/</url>
      
        <content type="html"><![CDATA[<p>项目中</p><p>报错： <code>NavigationDuplicated: Avoided redundant navigation to current location:</code></p><p><code>（NavigationDuplicated: 避免了对当前位置的冗余导航）</code></p><p>解决方法：</p><p>这个报错的关键是<code>this.$router.push(...).catch(err =&gt; err)</code>要有后面的<code>catch</code>。因为跳转方法返回了一个<code>promise</code>对象，要有处理拒绝的方法。</p><p>首先检查，路由跳转的时候是不是调用的<code>push</code>方法，还是用的<code>replace</code>？</p><p>打开 router 文件夹下的 index.js（路由文件）文件中添加如下代码：</p><p>// pust 方法</p><pre><code>const routerRePush = VueRouter.prototype.pushVueRouter.prototype.push = function (location) &#123;  return routerRePush.call(this, location).catch(error =&gt; error)&#125;</code></pre><p>// replace 方法</p><pre><code>const routerReplace = VueRouter.prototype.replaceVueRouter.prototype.replace = function (location) &#123;  return routerReplace.call(this, location).catch(error =&gt; error)&#125;</code></pre><p>问题解决，祝我生日快乐好吧</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端必备八股文</title>
      <link href="/2022/07/18/article22/"/>
      <url>/2022/07/18/article22/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="http-和-https-的基本概念"><a href="#http-和-https-的基本概念" class="headerlink" title="http 和 https 的基本概念"></a>http 和 https 的基本概念</h3><p>http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。<br>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p><h3 id="http-和-https-的区别及优缺点？"><a href="#http-和-https-的区别及优缺点？" class="headerlink" title="http 和 https 的区别及优缺点？"></a>http 和 https 的区别及优缺点？</h3><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li><li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高。</li><li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h3 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li><li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li><li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li><li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol><h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><ul><li><p>跨域的原理</p><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br><strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li><li><p>解决方案</p><p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p><ul><li><p><strong>JSONP</strong>：<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p><p>步骤：</p></li></ul><ol><li>去创建一个script标签</li><li>script的src属性设置接口地址</li><li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li><li>通过定义函数名去接受返回的数据</li></ol></li></ul><pre><code> //动态创建 script var script = document.createElement(&#39;script&#39;); // 设置回调函数 function getData(data) &#123;     console.log(data); &#125; //设置 script 的 src 属性，并设置请求地址 script.src = &#39;http://localhost:3000/?callback=getData&#39;; // 让 script 生效 document.body.appendChild(script);</code></pre><ul><li><strong>JSONP 的缺点</strong>:<br>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</li><li><strong>document.domain</strong> 基础域名相同 子域名不同</li><li><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</li><li><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</li><li><strong>proxy代理</strong> 目前常用方式,通过服务器设置代理</li><li><strong>window.postMessage()</strong> 利用h5新特性window.postMessage()</li></ul><h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p><ul><li>存储在客户端</li></ul><p><strong>不同点</strong>：</p><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><ol><li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack=j+1），<code>同时也发送一个自己的SYN包</code>（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol><li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<code>客户端进入FIN-WAIT-1（终止等待1）状态</code>。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li><code>服务器收到连接释放报文，发出确认报文</code>，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，<code>服务端就进入了CLOSE-WAIT（关闭等待）状态</code>。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，<code>客户端就进入FIN-WAIT-2（终止等待2）状态</code>，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</li><li><code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，<code>服务器就进入了LAST-ACK（最后确认）状态</code>，等待客户端的确认。</li><li><code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，<code>客户端就进入了TIME-WAIT（时间等待）状态</code>。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，<code>当客户端撤销相应的TCB后，才进入CLOSED状态</code>。</li><li>服务器只要收到了客户端发出的确认，<code>立即进入CLOSED状态</code>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，<code>服务器结束TCP连接的时间要比客户端早一些</code>。</li></ol><h3 id="TCP-IP-如何保证数据包传输的有序可靠？"><a href="#TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP/IP / 如何保证数据包传输的有序可靠？"></a>TCP/IP / 如何保证数据包传输的有序可靠？</h3><p>对字节流分段并进行编号然后<code>通过 ACK 回复</code>和<code>超时重发</code>这两个机制来保证。</p><ol><li>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</li><li>并为每个已发送的数据包启动一个超时定时器；</li><li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</li><li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li><li>接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li></ol><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol><li>TCP是面向<code>链接</code>的，而UDP是面向无连接的。</li><li>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</li></ol><h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>CP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p><strong>粘包出现原因</strong></p><p>简单得说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong></p><p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p><p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p><ol><li>对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li><li>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</li><li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</li></ol><p>以上提到的三种措施，都有其不足之处。</p><ol><li>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li><li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li><li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ol><p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="从输入URL到页面加载的全过程"><a href="#从输入URL到页面加载的全过程" class="headerlink" title="从输入URL到页面加载的全过程"></a>从输入URL到页面加载的全过程</h3><ul><li>首先在浏览器中输入URL</li><li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。<ul><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li><li>ISP缓存：若上述均失败，继续向ISP搜索。</li></ul></li><li>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议。</code>。</li><li>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</li><li>发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</li><li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</li><li>关闭TCP连接：通过四次挥手释放TCP连接</li><li>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：<ul><li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li><li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li><li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ul></li></ul><p>JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><ul><li>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li><li>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</li><li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</li><li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</li></ul><h3 id="浏览器重绘与回流的区别？"><a href="#浏览器重绘与回流的区别？" class="headerlink" title="浏览器重绘与回流的区别？"></a>浏览器重绘与回流的区别？</h3><ul><li><code>重排/回流（Reflow）</code>：当<code>DOM</code>的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li><code>重绘(Repaint)</code>: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li></ul><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p><p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p><p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p><h3 id="如何触发回流和重绘？"><a href="#如何触发回流和重绘？" class="headerlink" title="如何触发回流和重绘？"></a>如何触发回流和重绘？</h3><p>任何改变用来构建渲染树的信息都会导致一次回流或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发回流和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h3 id="如何避免回流和重绘？"><a href="#如何避免回流和重绘？" class="headerlink" title="如何避免回流和重绘？"></a>如何避免回流和重绘？</h3><ul><li><p><code>集中改变样式</code>，不要一条一条地修改 DOM 的样式。</p></li><li><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p></li><li><p>为动画的 HTML 元件使用 <code>fixed</code> 或 <code>absoult</code> 的 <code>position</code>，那么修改他们的 CSS 是不会 reflow 的。</p></li><li><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p></li><li><p>尽量只修改<code>position：absolute</code>或<code>fixed</code>元素，对其他元素影响不大</p></li><li><p>动画开始<code>GPU</code>加速，<code>translate</code>使用<code>3D</code>变化</p></li><li><p>提升为合成层</p><p>将元素提升为合成层有以下优点：</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p></li></ul><p>  <code>target &#123;will-change: transform;&#125;</code></p><h2 id="HTML-amp-amp-CSS"><a href="#HTML-amp-amp-CSS" class="headerlink" title="HTML &amp;&amp; CSS"></a>HTML &amp;&amp; CSS</h2><h3 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h3><ol><li><p><strong>概念</strong>：</p><p>HTML5的语义化指的是<code>合理正确的使用语义化的标签来创建页面结构</code>。【正确的标签做正确的事】</p></li><li><p><strong>语义化标签</strong>：</p><p>header nav main article section aside footer</p></li><li><p><strong>语义化的优点</strong>:</p><ul><li>在<code>没CSS样式的情况下，页面整体也会呈现很好的结构效果</code></li><li><code>代码结构清晰</code>，易于阅读，</li><li><code>利于开发和维护</code> 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li><li><code>有利于搜索引擎优化（SEO）</code>，搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><h3 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h3><p><strong>选择器</strong></p><ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel=”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1,p)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul><p><strong>优先级：</strong></p><ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器/属性选择器/伪类选择器（0010）</li><li>元素选择器/伪元素选择器（0001）</li><li>关系选择器/通配符选择器（0000）</li></ul><p>带!important 标记的样式属性优先级最高； 样式表的来源相同时：<code>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><h3 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h3><ul><li><strong>固定定位 fixed</strong>： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</li><li><strong>相对定位 relative</strong>： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</li><li><strong>绝对定位 absolute</strong>： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</li><li><strong>粘性定位 sticky</strong>： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</li><li><strong>默认定位 Static</strong>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</li></ul><h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><ul><li>box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box/border-box/inherit</li><li><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】</li><li><strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】</li><li><strong>inherit</strong>：继承父元素的 box-sizing 值。</li></ul><h3 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h3><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>在标准的盒子模型中，<code>width 指 content 部分的宽度</code>。<br>在 IE 盒子模型中，<code>width 表示 content+padding+border 这三个部分的宽度</code>。</p><p>故在计算盒子的宽度时存在差异：</p><p><strong>标准盒模型：</strong> 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)</p><p><strong>怪异盒模型：</strong> 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p><h3 id="让一个元素水平垂直居中"><a href="#让一个元素水平垂直居中" class="headerlink" title="让一个元素水平垂直居中"></a>让一个元素水平垂直居中</h3><ul><li><p><strong>水平居中</strong></p><ul><li><p>对于 行内元素 : <code>text-align: center</code>;</p></li><li><p>对于确定宽度的块级元素：</p><p>（1）width和margin实现。<code>margin: 0 auto</code>;</p><p>（2）绝对定位和margin-left: -width/2, 前提是父元素position: relative</p></li><li><p>对于宽度未知的块级元素</p><p>（1）<code>table标签配合margin左右auto实现水平居中</code>。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。</p><p>（2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。</p><p>（3）<code>绝对定位+transform</code>，translateX可以移动本身元素的50%。</p><p>（4）flex布局使用<code>justify-content:center</code></p></li></ul></li><li><p><strong>垂直居中</strong></p><ol><li>利用 <code>line-height</code> 实现居中，这种方法适合纯文字类</li><li>通过设置父容器 相对定位 ，子级设置 <code>绝对定位</code>，标签通过margin实现自适应居中</li><li>弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li><li><code>table 布局</code>，父级通过转换成表格形式，<code>然后子级设置 vertical-align 实现</code>。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）</li></ol></li></ul><h3 id="隐藏页面中某个元素的方法"><a href="#隐藏页面中某个元素的方法" class="headerlink" title="隐藏页面中某个元素的方法"></a>隐藏页面中某个元素的方法</h3><p>1.<code>opacity：0</code>，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的</p><p>2.<code>visibility：hidden</code>，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><p>3.<code>display：none</code>，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</p><h3 id="用CSS实现三角符号"><a href="#用CSS实现三角符号" class="headerlink" title="用CSS实现三角符号"></a>用CSS实现三角符号</h3><pre><code>/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */div:after&#123;    position: absolute;    width: 0px;    height: 0px;    content:&quot; &quot;;    border-right: 100px solid transparent;    border-top: 100px solid #ff0;    border-left: 100px solid transparent;    border-bottom: 100px solid transparent;&#125;</code></pre><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h4 id="1-Flex-布局"><a href="#1-Flex-布局" class="headerlink" title="1.Flex 布局"></a>1.Flex 布局</h4><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。</p><p>容器的属性：</p><ul><li>flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;</li><li>flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;</li><li>flex-flow： .box { flex-flow: || ; }</li><li>justify-content：对其方式，水平主轴对齐方式</li><li>align-items：对齐方式，竖直轴线方向</li><li>align-content</li></ul><p>项目的属性（元素的属性）：</p><ul><li>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li><li>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li><li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小</li><li>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li><li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。</li><li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</li><li>align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</li></ul><h4 id="2-Rem-布局"><a href="#2-Rem-布局" class="headerlink" title="2.Rem 布局"></a>2.Rem 布局</h4><p>首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem = 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。</p><p><strong>优点</strong>：可以快速适用移动端布局，字体，图片高度</p><p><strong>缺点</strong>：</p><p>①目前 ie 不支持，对 pc 页面来讲使用次数不多；<br>②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；<br>③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。</p><h4 id="3-百分比布局"><a href="#3-百分比布局" class="headerlink" title="3.百分比布局"></a>3.百分比布局</h4><p>通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p><p><strong>缺点</strong>：</p><p>（1）计算困难<br>（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。</p><h4 id="4-浮动布局"><a href="#4-浮动布局" class="headerlink" title="4.浮动布局"></a>4.浮动布局</h4><p>浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。</p><p><strong>优点</strong></p><p>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题</p><p><strong>缺点</strong></p><p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，<code>会造成父级元素高度塌陷</code>。</p><h3 id="如何使用rem或viewport进行移动端适配"><a href="#如何使用rem或viewport进行移动端适配" class="headerlink" title="如何使用rem或viewport进行移动端适配"></a>如何使用rem或viewport进行移动端适配</h3><p><strong>rem适配原理：</strong></p><p>改变了一个元素在不同设备上占据的css像素的个数</p><p>rem适配的优缺点</p><ul><li>优点：没有破坏完美视口</li><li>缺点：px值转换rem太过于复杂(下面我们使用less来解决这个问题)</li></ul><p><strong>viewport适配的原理</strong></p><p>viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的</p><p>viewport适配的优缺点</p><ul><li>在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设</li><li>缺点破坏完美视口</li></ul><h3 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h3><ul><li><p>添加额外标签</p>  <div class="parent">      //添加额外标签并且添加clear属性      <div style="clear:both"></div>      //也可以加一个br标签  </div>  </li><li><p>父级添加overflow属性，或者设置高度</p></li><li><p>建立伪类选择器清除浮动</p></li></ul><pre><code>//在css中添加:after伪元素.parent:after&#123;  /* 设置添加子元素的内容是空 */  content: &#39;&#39;;  /* 设置添加子元素为块级元素 */  display: block;  /* 设置添加的子元素的高度0 */  height: 0;  /* 设置添加子元素看不见 */  visibility: hidden;  /* 设置clear：both */  clear: both;&#125;</code></pre><h2 id="JS、TS、ES6"><a href="#JS、TS、ES6" class="headerlink" title="JS、TS、ES6"></a>JS、TS、ES6</h2><h3 id="JS中的8种数据类型及区别"><a href="#JS中的8种数据类型及区别" class="headerlink" title="JS中的8种数据类型及区别"></a>JS中的8种数据类型及区别</h3><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)</p><p><strong>基本类型(值类型)：</strong> Number(数字),String(字符串),Boolean(布尔),Symbol(符号),null(空),undefined(未定义)在内存中占据固定大小，保存在栈内存中</p><p><strong>引用类型(复杂数据类型)：</strong> Object(对象)、Function(函数)。其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</p><h3 id="JS中的数据类型检测方案"><a href="#JS中的数据类型检测方案" class="headerlink" title="JS中的数据类型检测方案"></a>JS中的数据类型检测方案</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><pre><code>  console.log(typeof 1);        // number  console.log(typeof true);      // boolean  console.log(typeof &#39;mc&#39;);      // string  console.log(typeof function()&#123;&#125;);  // function  console.log(typeof console.log());  // function  console.log(typeof []);       // object  console.log(typeof &#123;&#125;);       // object  console.log(typeof null);      // object  console.log(typeof undefined);    // undefined</code></pre><p>优点：能够快速区分基本数据类型</p><p>缺点：不能将Object、Array和Null区分，都返回object</p><h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><pre><code>console.log(1 instanceof Number);            // falseconsole.log(true instanceof Boolean);        // falseconsole.log(&#39;str&#39; instanceof String);        // false console.log([] instanceof Array);            // trueconsole.log(function ()&#123;&#125; instanceof Function);    // trueconsole.log(&#123;&#125; instanceof Object);           // true</code></pre><p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</p><p>缺点：Number，Boolean，String基本数据类型不能判断</p><h4 id="3-Object-prototype-toString-call"><a href="#3-Object-prototype-toString-call" class="headerlink" title="3.Object.prototype.toString.call()"></a>3.Object.prototype.toString.call()</h4><pre><code>var toString = Object.prototype.toString;console.log(toString.call(1));           //[object Number]console.log(toString.call(true));          //[object Boolean]console.log(toString.call(&#39;mc&#39;));          //[object String]console.log(toString.call([]));           //[object Array]console.log(toString.call(&#123;&#125;));           //[object Object]console.log(toString.call(function ()&#123;&#125;));      //[object Function]console.log(toString.call(undefined));       //[object Undefined]console.log(toString.call(null));          //[object Null]</code></pre><p>优点：精准判断数据类型</p><p>缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 id="var-amp-amp-let-amp-amp-const"><a href="#var-amp-amp-let-amp-amp-const" class="headerlink" title="var &amp;&amp; let &amp;&amp; const"></a>var &amp;&amp; let &amp;&amp; const</h3><p>ES6之前创建变量用的是var,之后创建变量用的是let/const</p><p><strong>三者区别</strong>：</p><ol><li>var定义的变量，<code>没有块的概念，可以跨块访问</code>, 不能跨函数访问。<br>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li>var可以<code>先使用，后声明</code>，因为存在变量提升；let必须先声明后使用。</li><li>var是允许在相同作用域内<code>重复声明同一个变量</code>的，而let与const不允许这一现象。</li><li>在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;<br>var声明的变量会和GO有映射关系；</li><li><code>会产生暂时性死区</code>：</li></ol><p>暂时性死区是浏览器的bug：检测一个未被声明的变量类型时，不会报错，会返回undefined<br>如：<code>console.log(typeof a) //undefined</code><br>而：<code>console.log(typeof a)//未声明之前不能使用</code><br><code>let a</code></p><ol><li>let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决</li></ol><h3 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h3><ol><li>项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</li><li>浏览器垃圾回收机制/内存回收机制:</li></ol><p>浏览器的Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p><ol><li><p><strong>标记清除</strong>:在<code>js</code>中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。<br><strong>谷歌浏览器</strong>：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br><strong>IE浏览器</strong>：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。</p></li><li><p>优化手段：内存优化 ; 手动释放：取消内存的占用即可。</p><p>（1）堆内存：fn = null 【null：空指针对象】</p><p>（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p></li><li><p>内存泄漏</p><p>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</p></li></ol><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域==&gt;<code>当前创建函数所处的上下文</code>。如果是在全局下创建的函数就是<code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文<code>EC(FN)</code>，供字符串代码执行(进栈执行)</p><p>定义：简单来说作用域就是变量与函数的可访问范围，<code>由当前环境与上层环境的一系列变量对象组成</code><br>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。<br>2.函数作用域：在固定的代码片段才能被访问</p><p>作用：作用域最大的用处就是<code>隔离变量</code>，不同作用域下同名变量不会有冲突。</p><p><strong>作用域链参考链接</strong>一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p><h3 id="闭包的两大作用：保存-保护"><a href="#闭包的两大作用：保存-保护" class="headerlink" title="闭包的两大作用：保存/保护"></a>闭包的两大作用：保存/保护</h3><ul><li><p><strong>闭包的概念</strong></p><p>函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p></li></ul><p>（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p><p>（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p><p>我们把函数执行形成私有上下文，来保护和保存私有变量机制称为<code>闭包</code>。</p><p><code>闭包是指有权访问另一个函数作用域中的变量的函数--《JavaScript高级程序设计》</code></p><p><strong>稍全面的回答</strong>： 在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p><ul><li><p><strong>闭包的特性</strong>：</p><ul><li><p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p><p>1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的</p><p>1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p></li><li><p>2、函数嵌套函数</p></li><li><p>3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p></li></ul></li><li><p><strong>闭包形成的条件</strong>：</p><ol><li>函数的嵌套</li><li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol></li><li><p><strong>闭包的用途</strong>：</p><ol><li>模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ol></li><li><p><strong>闭包应用场景</strong></p><p>闭包的两个场景，闭包的两大作用：<code>保存/保护</code>。 在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p></li><li><p><strong>闭包的优点</strong>：延长局部变量的生命周期</p></li><li><p><strong>闭包缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p></li></ul><h3 id="JS-中-this-的五种情况"><a href="#JS-中-this-的五种情况" class="headerlink" title="JS 中 this 的五种情况"></a>JS 中 this 的五种情况</h3><ol><li>作为普通函数执行时，<code>this</code>指向<code>window</code>。</li><li>当函数作为对象的方法被调用时，<code>this</code>就会指向<code>该对象</code>。</li><li>构造器调用，<code>this</code>指向<code>返回的这个对象</code>。</li><li>箭头函数 箭头函数的<code>this</code>绑定看的是<code>this所在函数定义在哪个对象下</code>，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。</li><li>基于Function.prototype上的 <code>apply 、 call 和 bind </code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，`` bind<code>方法通过传入一个对象，返回一个</code> this <code>绑定了传入对象的新函数。这个函数的 </code>this<code>指向除了使用</code>new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</li></ol><h3 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型 &amp;&amp; 原型链"></a>原型 &amp;&amp; 原型链</h3><p><strong>原型关系：</strong></p><ul><li>每个 class都有显示原型 prototype</li><li>每个实例都有隐式原型 _ proto_</li><li>实例的_ proto_指向对应 class 的 prototype</li></ul><p>‌<strong>原型:</strong> 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个<code>函数对象</code>都有一个<code>prototype</code> 属性，这个属性指向函数的<code>原型对象</code>。</p><p>原型链：函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p><p><strong>特点:</strong> <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="new运算符的实现机制"><a href="#new运算符的实现机制" class="headerlink" title="new运算符的实现机制"></a>new运算符的实现机制</h3><ol><li>首先创建了一个新的<code>空对象</code></li><li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。</li><li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><h3 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a>EventLoop 事件循环</h3><p><code>JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，</code>Promise.then<code>，</code>MutationObserver<code>，宏任务的话就是setImmediate setTimeout setInterval</code></p><p>JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h4 id="浏览器中的事件环（Event-Loop"><a href="#浏览器中的事件环（Event-Loop" class="headerlink" title="浏览器中的事件环（Event Loop)"></a><strong>浏览器中的事件环（Event Loop)</strong></h4><p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><ul><li>eventLoop 是由JS的宿主环境（浏览器）来实现的；</li><li>事件循环可以简单的描述为以下四个步骤:<ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol></li></ul><p>浏览器中的任务源(task):</p><ul><li><code>宏任务(macrotask)</code>：<br>宿主环境提供的，比如浏览器<br>ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</li><li><code>微任务(microtask)</code>：<br>语言本身提供的，比如promise.then<br>then、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li></ul><h3 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h3><p><code>节流</code>：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p><p><code>防抖</code>：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！</p><p><code>使用场景</code>：<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p><pre><code>/** * 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。 * @param fn要被节流的函数 * @param delay规定的时间 */function throttle(fn, delay) &#123;    //记录上一次函数触发的时间    var lastTime = 0;    return function()&#123;        //记录当前函数触发的时间        var nowTime = Date.now();        if(nowTime - lastTime &gt; delay)&#123;            //修正this指向问题            fn.call(this);            //同步执行结束时间            lastTime = nowTime;        &#125;    &#125;&#125;document.onscroll = throttle(function () &#123;    console.log(&#39;scllor事件被触发了&#39; + Date.now());&#125;, 200); /** * 防抖函数  一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效 * @param fn要被节流的函数 * @param delay规定的时间 */function debounce(fn, delay) &#123;    //记录上一次的延时器    var timer = null;    return function () &#123;       //清除上一次的演示器        clearTimeout(timer);        //重新设置新的延时器        timer = setTimeout(function()&#123;            //修正this指向问题            fn.apply(this);        &#125;, delay);    &#125;&#125;document.getElementById(&#39;btn&#39;).onclick = debounce(function () &#123;    console.log(&#39;按钮被点击了&#39; + Date.now());&#125;, 1000);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13 行 JavaScript 代码让你看起来像是高手</title>
      <link href="/2022/06/22/article21/"/>
      <url>/2022/06/22/article21/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 可以做许多神奇的事情，也有很多东西需要学习，今天我们介绍几个短小精悍的代码段。</p><h3 id="获取随机布尔值（True-False）"><a href="#获取随机布尔值（True-False）" class="headerlink" title="获取随机布尔值（True/False）"></a>获取随机布尔值（True/False）</h3><p>使用 <code>Math.random()</code> 会返回 0 到 1 的随机数，之后判断它是否大于 0.5，将会得到一个 50% 概率为 <code>True</code> 或 <code>False</code> 的值</p><pre><code>const randomBoolean = () =&gt; Math.random() &gt;= 0.5;console.log(randomBoolean());</code></pre><h3 id="判断一个日期是否是工作日"><a href="#判断一个日期是否是工作日" class="headerlink" title="判断一个日期是否是工作日"></a>判断一个日期是否是工作日</h3><pre><code>const isWeekday = (date) =&gt; date.getDay() % 6 !== 0;console.log(isWeekday(new Date(2021, 0, 11)));// Result: true (周一)console.log(isWeekday(new Date(2021, 0, 10)));// Result: false (周日)</code></pre><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>有许多反转字符串的方法，这里使用一种最简单的，使用了 <code>split()</code>，<code>reverse()</code> 和 <code>join()</code></p><pre><code>const reverse = str =&gt; str.split(&#39;&#39;).reverse().join(&#39;&#39;);reverse(&#39;hello world&#39;);// Result: &#39;dlrow olleh&#39;</code></pre><h3 id="判断当前标签页是否为可视状态"><a href="#判断当前标签页是否为可视状态" class="headerlink" title="判断当前标签页是否为可视状态"></a>判断当前标签页是否为可视状态</h3><p>浏览器可以打开很多标签页，下面 👇🏻 的代码段就是判断当前标签页是否是激活的标签页</p><pre><code>const isBrowserTabInView = () =&gt; document.hidden;isBrowserTabInView();</code></pre><h3 id="判断数字为奇数或者偶数"><a href="#判断数字为奇数或者偶数" class="headerlink" title="判断数字为奇数或者偶数"></a>判断数字为奇数或者偶数</h3><p>取模运算符 <code>%</code> 可以很好地完成这个任务</p><pre><code>const isEven = num =&gt; num % 2 === 0;console.log(isEven(2));// Result: trueconsole.log(isEven(3));// Result: false</code></pre><h3 id="从-Date-对象中获取时间"><a href="#从-Date-对象中获取时间" class="headerlink" title="从 Date 对象中获取时间"></a>从 Date 对象中获取时间</h3><p>使用 <code>Date</code> 对象的 <code>.toTimeString()</code> 方法转换为时间字符串，之后截取字符串即可</p><pre><code>const timeFromDate = date =&gt; date.toTimeString().slice(0, 8);console.log(timeFromDate(new Date(2021, 0, 10, 17, 30, 0)));// Result: &quot;17:30:00&quot;console.log(timeFromDate(new Date()));// Result: 返回当前时间</code></pre><h3 id="保留指定的小数位"><a href="#保留指定的小数位" class="headerlink" title="保留指定的小数位"></a>保留指定的小数位</h3><pre><code>const toFixed = (n, fixed) =&gt; ~~(Math.pow(10, fixed) * n) / Math.pow(10, fixed);// ExamplestoFixed(25.198726354, 1);       // 25.1toFixed(25.198726354, 2);       // 25.19toFixed(25.198726354, 3);       // 25.198toFixed(25.198726354, 4);       // 25.1987toFixed(25.198726354, 5);       // 25.19872toFixed(25.198726354, 6);       // 25.198726</code></pre><h3 id="检查指定元素是否处于聚焦状态"><a href="#检查指定元素是否处于聚焦状态" class="headerlink" title="检查指定元素是否处于聚焦状态"></a>检查指定元素是否处于聚焦状态</h3><p>可以使用 <code>document.activeElement</code> 来判断元素是否处于聚焦状态</p><pre><code>const elementIsInFocus = (el) =&gt; (el === document.activeElement);elementIsInFocus(anyElement)// Result: 如果处于焦点状态会返回 True 否则返回 False</code></pre><h3 id="检查当前用户是否支持触摸事件"><a href="#检查当前用户是否支持触摸事件" class="headerlink" title="检查当前用户是否支持触摸事件"></a>检查当前用户是否支持触摸事件</h3><pre><code>const touchSupported = () =&gt; &#123;  (&#39;ontouchstart&#39; in window || window.DocumentTouch &amp;&amp; document instanceof window.DocumentTouch);&#125;console.log(touchSupported());// Result: 如果支持触摸事件会返回 True 否则返回 False</code></pre><h3 id="检查当前用户是否是苹果设备"><a href="#检查当前用户是否是苹果设备" class="headerlink" title="检查当前用户是否是苹果设备"></a>检查当前用户是否是苹果设备</h3><p>可以使用 <code>navigator.platform</code> 判断当前用户是否是苹果设备</p><pre><code>const isAppleDevice = /Mac|iPod|iPhone|iPad/.test(navigator.platform);console.log(isAppleDevice);// Result: 是苹果设备会返回 True</code></pre><h3 id="滚动至页面顶部"><a href="#滚动至页面顶部" class="headerlink" title="滚动至页面顶部"></a>滚动至页面顶部</h3><p><code>window.scrollTo()</code> 会滚动至指定的坐标，如果设置坐标为（0，0），就会回到页面顶部</p><pre><code>const goToTop = () =&gt; window.scrollTo(0, 0);goToTop();// Result: 将会滚动至顶部</code></pre><h3 id="获取所有参数的平均值"><a href="#获取所有参数的平均值" class="headerlink" title="获取所有参数的平均值"></a>获取所有参数的平均值</h3><p>可以使用 <code>reduce()</code> 函数来计算所有参数的平均值</p><pre><code>const average = (...args) =&gt; args.reduce((a, b) =&gt; a + b) / args.length;average(1, 2, 3, 4);// Result: 2.5</code></pre><h3 id="转换华氏-摄氏"><a href="#转换华氏-摄氏" class="headerlink" title="转换华氏/摄氏"></a>转换华氏/摄氏</h3><p>再也不怕处理温度单位了，下面两个函数是两个温度单位的相互转换。</p><pre><code>const celsiusToFahrenheit = (celsius) =&gt; celsius * 9/5 + 32;const fahrenheitToCelsius = (fahrenheit) =&gt; (fahrenheit - 32) * 5/9;// ExamplescelsiusToFahrenheit(15);    // 59celsiusToFahrenheit(0);     // 32celsiusToFahrenheit(-20);   // -4fahrenheitToCelsius(59);    // 15fahrenheitToCelsius(32);    // 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2与vue3</title>
      <link href="/2022/06/04/article20/"/>
      <url>/2022/06/04/article20/</url>
      
        <content type="html"><![CDATA[<h2 id="1-全局属性"><a href="#1-全局属性" class="headerlink" title="1. 全局属性"></a>1. 全局属性</h2><h4 id="1-0-1-vue2"><a href="#1-0-1-vue2" class="headerlink" title="1.0.1. vue2"></a>1.0.1. vue2</h4><ul><li>对于一些第三方插件，vue2 中通常使用 prototype 原型来挂载到 vue 对象中</li></ul><p><code>import Vue from &#39;vue&#39;</code><br><code>Vue.prototype.$http=Axiox</code><br><code>Vue.prototype.$echart= Echart</code></p><h4 id="1-0-2-vue3"><a href="#1-0-2-vue3" class="headerlink" title="1.0.2. vue3"></a>1.0.2. vue3</h4><ul><li><p>vue3 中提供了一个名为<code>globalProperties</code>的全局属性配置，可以代替 vue2 中的 prototype</p><p><code>app.config.globalProperties.$http = Axios</code><br><code>app.config.globalProperties.$echart = Echart</code></p></li><li><p>使用$http</p><p>import {getCurrentInstance} from ‘vue’<br>setup () {<br>const { ctx } = getCurrentInstance();<br>onMounted(() =&gt; {<br>console.log(ctx.$http)<br>})<br>…….<br>}</p></li></ul><h2 id="2-ref-与-v-for-的生成"><a href="#2-ref-与-v-for-的生成" class="headerlink" title="2. ref 与 v-for 的生成"></a>2. ref 与 v-for 的生成</h2><h4 id="2-0-1-vue2"><a href="#2-0-1-vue2" class="headerlink" title="2.0.1. vue2"></a>2.0.1. vue2</h4><p>vue2 中 v-for 与 ref 一起使用，批量模板引用的时候，获取的 ref 为一个数组</p><pre><code>&lt;div v-for=&quot;i in 3&quot; ref=&quot;setItemRef&quot; :key=&quot;i&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/div&gt; //这里是数组mounted() &#123;      console.log(this.$refs.setItemRef)&#125;,</code></pre><h4 id="2-0-2-vue3"><a href="#2-0-2-vue3" class="headerlink" title="2.0.2. vue3"></a>2.0.2. vue3</h4><p>vue3 中 ref 绑定的是一个函数，</p><pre><code>&lt;div v-for=&quot;item in 3&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt; //这里绑定的是函数setup()&#123;    let itemRefs = []    const setItemRef = el =&gt; &#123;    itemRefs.push(el)    &#125;    onMounted(() =&gt; &#123;        console.log(itemRefs)    &#125;)&#125;</code></pre><p>二者获取 ref 的 dom 方式有变化，但是获取的结果相同</p><p><a href="https://gitee.com/baifangzi/blogimage/raw/master/img/image-20201218175111169.png"><img src="https://gitee.com/baifangzi/blogimage/raw/master/img/image-20201218175111169.png"></a></p><h2 id="3-异步组件"><a href="#3-异步组件" class="headerlink" title="3. 异步组件"></a>3. 异步组件</h2><p>在路由中，常常使用懒加载的方式来引入组件</p><h4 id="3-0-1-vue2"><a href="#3-0-1-vue2" class="headerlink" title="3.0.1. vue2"></a>3.0.1. vue2</h4><p><code>component: () =&gt; import(&#39;@/views/homePage/index.vue&#39;),</code></p><h4 id="3-0-2-vue3"><a href="#3-0-2-vue3" class="headerlink" title="3.0.2. vue3"></a>3.0.2. vue3</h4><p>在 vue3 中引入了一个新的方法 —&gt;<code>defineAsyncComponent</code>定义异步组件，来包裹 vue2 引入方式里面的内容</p><p><code>import &#123; defineAsyncComponent &#125; from &#39;vue&#39;</code><br><code>component: defineAsyncComponent(() =&gt; import(&#39;./NextPage.vue&#39;))</code></p><h2 id="4-自定义指令"><a href="#4-自定义指令" class="headerlink" title="4. 自定义指令"></a>4. 自定义指令</h2><h3 id="4-1-改变钩子函数的命名"><a href="#4-1-改变钩子函数的命名" class="headerlink" title="4.1. 改变钩子函数的命名"></a>4.1. 改变钩子函数的命名</h3><h4 id="4-1-1-vue2"><a href="#4-1-1-vue2" class="headerlink" title="4.1.1. vue2"></a>4.1.1. vue2</h4><p>vue2 中绑定的钩子函数为</p><ul><li><strong>bind</strong> - 指令绑定到元素后发生。只发生一次。</li><li><strong>inserted</strong> - 元素插入父 DOM 后发生。</li><li><strong>update</strong> - 当元素更新，但子元素尚未更新时，将调用此钩子。</li><li><strong>componentUpdated</strong> - 一旦组件和子级被更新，就会调用这个钩子。</li><li><strong>unbind</strong> - 一旦指令被移除，就会调用这个钩子。也只调用一次。</li></ul><h4 id="4-1-2-vue3"><a href="#4-1-2-vue3" class="headerlink" title="4.1.2. vue3"></a>4.1.2. vue3</h4><p>将钩子函数的命名与生命周期的钩子函数命名相一致</p><ul><li>bind → <strong>beforeMount</strong></li><li>inserted → <strong>mounted</strong></li><li><strong>beforeUpdate</strong>：新的！这是在元素本身更新之前调用的，很像组件生命周期钩子。</li><li>componentUpdated → <strong>updated</strong></li><li><strong>beforeUnmount</strong>：新的！与组件生命周期钩子类似，它将在卸载元素之前调用。</li><li>unbind -&gt; <strong>unmounted</strong></li></ul><h3 id="4-2-在钩子函数中引用组件实例的方式"><a href="#4-2-在钩子函数中引用组件实例的方式" class="headerlink" title="4.2. 在钩子函数中引用组件实例的方式"></a>4.2. 在钩子函数中引用组件实例的方式</h3><p>某些情况下需要去获取组件中实例的某些属性</p><h4 id="4-2-1-vue2"><a href="#4-2-1-vue2" class="headerlink" title="4.2.1. vue2"></a>4.2.1. vue2</h4><ul><li>需要通过 vnod 来获取实例</li></ul><pre><code>Vue.directive(&#39;has&#39;, &#123;inserted: (el, binding, vnode) =&gt; checkPermission(el, binding, vnode),&#125;);export const checkPermission = (el, binding, vnode) =&gt; &#123;    const permissionArr = vnode.context.$store.state.permissionId //所拥有的所有权限 id&#125;</code></pre><h4 id="4-2-2-vue3"><a href="#4-2-2-vue3" class="headerlink" title="4.2.2. vue3"></a>4.2.2. vue3</h4><ul><li>从 binding 中去获取对象</li></ul><pre><code>export const checkPermission = (el, binding, vnode) =&gt; &#123;const permissionArr =binding.instance.$store.state.permissionId //所拥有的所有权限 id&#125;</code></pre><h4 id="4-2-3-v-bind-”-attrs”"><a href="#4-2-3-v-bind-”-attrs”" class="headerlink" title="4.2.3. v-bind=”$attrs”"></a>4.2.3. v-bind=”$attrs”</h4><h2 id="5-自定义元素元素的交互"><a href="#5-自定义元素元素的交互" class="headerlink" title="5. 自定义元素元素的交互"></a>5. 自定义元素元素的交互</h2><h3 id="5-1-is-的用法"><a href="#5-1-is-的用法" class="headerlink" title="5.1. is 的用法"></a>5.1. is 的用法</h3><h4 id="5-1-1-vue2"><a href="#5-1-1-vue2" class="headerlink" title="5.1.1. vue2"></a>5.1.1. vue2</h4><ul><li>组件：</li></ul><p><code>&lt;component :is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code></p><ul><li><p>html 标签</p>  <table>    <tr is="blog-post-row"></tr>  </table></li></ul><h4 id="5-1-2-vue3"><a href="#5-1-2-vue3" class="headerlink" title="5.1.2. vue3"></a>5.1.2. vue3</h4><ul><li>组件</li></ul><p><code>&lt;component is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code></p><ul><li><p>html 标签</p>  <table>    <tr v-is="'blog-post-row'"></tr>  // v-is类似绑定一个变量，而我们需要组件名，为字符串，所以用单引号包裹  </table></li></ul><h2 id="6-事件"><a href="#6-事件" class="headerlink" title="6. 事件"></a>6. 事件</h2><ul><li>vue3 中去除了 <code>$on</code>、<code>$off</code>、<code>$once</code>、三种方法，仅保留<code>$emit</code>。</li></ul><h2 id="7-过滤器"><a href="#7-过滤器" class="headerlink" title="7. 过滤器"></a>7. 过滤器</h2><p>vue3 中移除了过滤器的功能，建议使用 methods 或者 computed 来代替，实际上在 vue2 中也完全可以这两种方式实现</p><h3 id="7-1-局部过滤器"><a href="#7-1-局部过滤器" class="headerlink" title="7.1. 局部过滤器"></a>7.1. 局部过滤器</h3><h4 id="7-1-1-vue2"><a href="#7-1-1-vue2" class="headerlink" title="7.1.1. vue2"></a>7.1.1. vue2</h4><pre><code>&lt;p&gt;&#123;&#123;message|toLower&#125;&#125;&lt;/p&gt;data() &#123;    return &#123;    message: &#39;ABC&#39;    &#125;&#125;,filters: &#123;    toLower(value) &#123;        return value.toLowerCase()    &#125;&#125;</code></pre><h4 id="7-1-2-vue3"><a href="#7-1-2-vue3" class="headerlink" title="7.1.2. vue3"></a>7.1.2. vue3</h4><ul><li><p>vue3 用 computed 或者 methods 来定义</p><p>  <code>&lt;p&gt;&#123;&#123;messageToLower&#125;&#125;&lt;/p&gt;</code></p></li></ul><pre><code>import &#123;        computed,    ref,    &#125; from &#39;vue&#39;;setup()&#123;    let message = ref(&#39;ABC&#39;)    let messageToLower = computed(() =&gt; &#123;        // console.log(message)        return message.value.toLowerCase()    &#125;)    return&#123;        messageToLower,    &#125;&#125;</code></pre><h3 id="7-2-全局过滤器"><a href="#7-2-全局过滤器" class="headerlink" title="7.2. 全局过滤器"></a>7.2. 全局过滤器</h3><h4 id="7-2-1-vue2"><a href="#7-2-1-vue2" class="headerlink" title="7.2.1. vue2"></a>7.2.1. vue2</h4><pre><code>Vue.filter(&#39;toLower&#39;,  (value)=&gt; &#123;    return value.toLowerCase()&#125;)</code></pre><h4 id="7-2-2-vue3"><a href="#7-2-2-vue3" class="headerlink" title="7.2.2. vue3"></a>7.2.2. vue3</h4><ul><li><p>在 main.js 中注册</p><p>const app =createApp(App)<br>app.config.globalProperties.$filter={<br>toLower(value){<br>return value.toLowerCase()<br>}<br>}</p></li><li><p>使用</p></li></ul><p><code>&lt;p&gt;&#123;&#123;$filters.toLower(message)&#125;&#125;&lt;/p&gt;</code></p><h2 id="8-根节点"><a href="#8-根节点" class="headerlink" title="8. 根节点"></a>8. 根节点</h2><h4 id="8-0-1-vue2"><a href="#8-0-1-vue2" class="headerlink" title="8.0.1. vue2"></a>8.0.1. vue2</h4><ul><li><p>vue2 的 <code>template</code>中只能存在一个根节点</p>  <template>    <div id="app">        ...    </div>  </template></li></ul><h4 id="8-0-2-vue3"><a href="#8-0-2-vue3" class="headerlink" title="8.0.2. vue3"></a>8.0.2. vue3</h4><ul><li><p>vue3 中可以存在多个节点</p>  <template>    <div>...</div>    <a>...</a>    <p>...</p>  </template></li></ul><h2 id="9-内联模板"><a href="#9-内联模板" class="headerlink" title="9. 内联模板"></a>9. 内联模板</h2><h4 id="9-0-1-vue2"><a href="#9-0-1-vue2" class="headerlink" title="9.0.1. vue2"></a>9.0.1. vue2</h4><ul><li><p>利用 inline-template 属性</p></li><li><p>在 vue2 中文档提示了这么一段话，所以几乎没有用过</p><p>不过，<code>inline-template</code> 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板。&gt;</p></li></ul><h4 id="9-0-2-vue3"><a href="#9-0-2-vue3" class="headerlink" title="9.0.2. vue3"></a>9.0.2. vue3</h4><p>移除了此功能，</p><h2 id="10-唯一的-key"><a href="#10-唯一的-key" class="headerlink" title="10. 唯一的 key"></a>10. 唯一的 key</h2><h3 id="10-1-v-if-中的-key"><a href="#10-1-v-if-中的-key" class="headerlink" title="10.1. v-if 中的 key"></a>10.1. v-if 中的 key</h3><h4 id="10-1-1-vue2"><a href="#10-1-1-vue2" class="headerlink" title="10.1.1. vue2"></a>10.1.1. vue2</h4><ul><li><p>在 vue2 中，v-if，v-else 中的 key 是为了控制某个组件或者元素的复用</p></li><li><p>不带 key 的话会复用，**&lt; hello-world &gt;**组件只创建一次</p>  <template v-if="loginType === 'username'">     <hello-world title="username"></hello-world>  </template>  <template v-else>     <hello-world title="email"></hello-world>  </template>  <button @click="changeType">切换</button></li><li><p>带 key 的话每次切换都会重新去渲染组件（前提是 key 不同）</p>  <template v-if="loginType === 'username'">      <hello-world title="username" key="a"></hello-world>  </template>  <template v-else>      <hello-world title="email" key="b"></hello-world>  </template>  <button @click="changeType">切换</button></li></ul><h4 id="10-1-2-vue3"><a href="#10-1-2-vue3" class="headerlink" title="10.1.2. vue3"></a>10.1.2. vue3</h4><p>vue3 中默认是带有 key 的，这个 key 始终保持唯一，与其他的 key 不同，不能通过故意使用相同的 <code>key</code> 来强制重用分支。</p><pre><code>&lt;div v-if=&quot;condition&quot;&gt;Yes&lt;/div&gt;&lt;div v-else&gt;No&lt;/div&gt;</code></pre><h3 id="10-2-template-中-v-for-的-key"><a href="#10-2-template-中-v-for-的-key" class="headerlink" title="10.2. template 中 v-for 的 key"></a>10.2. template 中 v-for 的 key</h3><h4 id="10-2-1-vue2"><a href="#10-2-1-vue2" class="headerlink" title="10.2.1. vue2"></a>10.2.1. vue2</h4><p>vue2 中，在 template 标签上，可以使用 v-for 指令，但是不能绑定 key，只能在子节点上面去绑定唯一的 key</p><pre><code>&lt;template v-for=&quot;item in list&quot;&gt;  &lt;div :key=&quot;item.id&quot;&gt;...&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="10-2-2-vue3"><a href="#10-2-2-vue3" class="headerlink" title="10.2.2. vue3"></a>10.2.2. vue3</h4><p>vue3 中可以将 key 绑定到 template 上</p><pre><code>&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;  &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webapck</title>
      <link href="/2022/05/26/article19/"/>
      <url>/2022/05/26/article19/</url>
      
        <content type="html"><![CDATA[<h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p>npm init 初始化项目<br><code>npm i -D snabbdom 安装</code><br><code>npm i -D webpack@5 webpack-cli@3 webpack-dev-server@3 </code></p><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>snabbdom 是一个 DOM 库.[重要]<br>不能够直接运行在 Node 环境中，<br>我们需要搭建一个 webpack 和 webpack-dev-server 的开发环境<br>需要注意的是必须安装 webpck5. 不能够安装 webpack4.<br>因为 webpck4 中没有读取 exports 的能力哈<br>然后安装：目的是搭建开发的运行环境</p><p><code>npm i -D webpack@5 webpack-cli@3 webpack-dev-server@3 </code><br>这个千万不忘记配置呀</p><h4 id="创建-webpack-config-文件"><a href="#创建-webpack-config-文件" class="headerlink" title="创建 webpack.config 文件"></a>创建 webpack.config 文件</h4><pre><code>//这个webpack.config文件在项目的根目录下// 安装官网配置直接复制 https://webpack.js.org/ 然后做简单的修改const path = require(&#39;path&#39;);module.exports = &#123;    // 入口，需要靠你去创建    entry: &#39;./src/index.js&#39;,    // 出口    output: &#123;      // path: path.resolve(__dirname, &#39;dist&#39;),      //虚拟的打包路径 也就是说文件夹不会真正的生成，而是在8080端口虚拟生成的      // xuni 这个不会真正的生成，在内存中，打包后的文件名是 bundle      publicPath:&#39;xuni&#39;,      filename: &#39;bundle.js&#39;,    &#125;,    &lt;!-- 配置的是 开发服务 --&gt;    devServer: &#123;        port: 8080, //端口        // 静态资源文件夹,你创建一个，跟src 同级，        contentBase:&#39;www&#39;    &#125;&#125;;</code></pre><h4 id="需要创建的文件"><a href="#需要创建的文件" class="headerlink" title="需要创建的文件"></a>需要创建的文件</h4><p>根据上面的配置要求。<br>我们需要在项目的跟目录下创建 src 文件夹，src 下有 index.js 文件<br>我们需要在项目的跟目录下创建 www 文件夹，src 下有 index.html 文件</p><p>我们在 index.js 文件中写<br>console.log(“你好啊，环境已经搭建 ok,我好高兴”)<br>这个文件打包后对应的虚拟文件是 bundle.js</p><p>我们在 index.html 文件中写</p><pre><code>&lt;body&gt;&lt;h1&gt;你好啊！&lt;/h1&gt;  &lt;!--    这个container 在我们等会使用snabbdom的时候需要，    我们现在就将他创建好    --&gt;  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;!-- bundle.js 是我们生成在内存中的，在物理上看不见。 我们等会写的xuni/bundle.js 是打包后的。 它打包前的是 src下有index.js文件 --&gt;&lt;script src=&quot;xuni/bundle.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><h4 id="更改-package-json-文件配置"><a href="#更改-package-json-文件配置" class="headerlink" title="更改 package.json 文件配置"></a>更改 package.json 文件配置</h4><p>在 package.json 文件中。<br>我们需要更改一下配置</p><pre><code>&quot;scripts&quot;: &#123;&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;&#125;,更改为&quot;scripts&quot;: &#123;&quot;dev&quot;: &quot;webpack-dev-server&quot;&#125;,</code></pre><p>这样我们执行 npm run dev 就会将,<br>我们下载的 webpack-dev-server 服务启动起来</p><h4 id="然后简单去走一下-snabbdom-的流程"><a href="#然后简单去走一下-snabbdom-的流程" class="headerlink" title="然后简单去走一下 snabbdom 的流程"></a>然后简单去走一下 snabbdom 的流程</h4><p>snabbdom 的地址：<a href="https://github.com/snabbdom/snabbdom">https://github.com/snabbdom/snabbdom</a><br>复制 Example。到我们的 index.js 文件中</p><p>我们会发现有<br><code>const container = document.getElementById(&quot;container&quot;);</code><br>所以我们需要在 index.html 中去创建<br>这就解释了为啥我们的 index.html 需要有一个 id 为 container<br>不过我们刚刚已经创建了</p><p>然后我们会发现有两个函数报错<br><code>someFn is not undefined</code><br><code>anotherEventHandler is not undefined</code><br>我们将这两个函数更改为普通函数 就 ok 了</p><h4 id="index-js-简单使用-h-函数"><a href="#index-js-简单使用-h-函数" class="headerlink" title="index.js 简单使用 h 函数"></a>index.js 简单使用 h 函数</h4><pre><code>import &#123;init,classModule,propsModule,styleModule,eventListenersModule,h,&#125; from &quot;snabbdom&quot;;let myVnode1 = h(&#39;a&#39;,&#123; props:&#123; href: &#39;https://www.cnblogs.com/IwishIcould/&#39; &#125;&#125;,&#39;我的博客&#39;)console.log(&quot;myVnode1&quot;, myVnode1) //输出来的内容就是虚拟 dom 节点这行代码说明了: h 函数产生虚拟 dom 节点</code></pre><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><pre><code>&lt;div&gt;    &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;转化为这个let obj=&#123;  &#39;tag&#39;:&#39;div&#39;,  &#39;child&#39;:[      &#39;tag&#39;:&#39;p&#39;,      &#39;text&#39;:&#39;123&#39;  ]&#125;</code></pre><p>不是 h 函数做的。<br>而是模板编译原理做的</p><h4 id="使用-patch-函数让虚拟-dom-节点上树"><a href="#使用-patch-函数让虚拟-dom-节点上树" class="headerlink" title="使用 patch 函数让虚拟 dom 节点上树"></a>使用 patch 函数让虚拟 dom 节点上树</h4><pre><code>import &#123;init,classModule,propsModule,styleModule,eventListenersModule,h,&#125; from &quot;snabbdom&quot;;let myVnode1 = h(&#39;a&#39;, &#123; props: &#123; href: &#39;https://www.cnblogs.com/IwishIcould/&#39; &#125; &#125;, &#39;我的博客&#39;)console.log(&quot;myVnode1&quot;, myVnode1) //输出来的内容就是虚拟 dom 节点// 使用 init 函数创建 patch 函数const patch = init([classModule, propsModule, styleModule, eventListenersModule])const container = document.getElementById(&#39;container&#39;)// 让虚拟节点上树patch(container,myVnode1)</code></pre><h4 id="init-函数创建-patch-函数"><a href="#init-函数创建-patch-函数" class="headerlink" title="init 函数创建 patch 函数"></a>init 函数创建 patch 函数</h4><p>使用 init 函数创建 patch 函数 ,init 函数接受 4 个参数。<br><code>const patch = init([classModule, propsModule, styleModule, eventListenersModule])</code><br>[类模块，属性模块，style 模块，事件模块 ]</p><h4 id="patch-函数让虚拟-dom-节点上树"><a href="#patch-函数让虚拟-dom-节点上树" class="headerlink" title="patch 函数让虚拟 dom 节点上树"></a>patch 函数让虚拟 dom 节点上树</h4><pre><code>// 让虚拟节点上树patch(container,myVnode1)patch 函数接受两个参数，上树到哪一个容器下，上树的虚拟节点#### 一个容器让多个虚拟节点上树，可以使用 h 函数的嵌套let myVnode1 = h(&#39;ul&#39;, &#123;&#125;, [h(&#39;li&#39;, &#123;&#125;, &#39;姓名&#39;),h(&#39;li&#39;, &#123;&#125;, &#39;年龄&#39;),h(&#39;li&#39;, &#123;&#125;, &#39;爱好&#39;),])console.log(&quot;myVnode1&quot;, myVnode1) //输出来的内容就是虚拟 dom 节点// 使用 init 函数创建 patch 函数const patch = init([classModule, propsModule, styleModule, eventListenersModule])const container = document.getElementById(&#39;container&#39;)// 让虚拟节点上树patch(container, myVnode1)console.log(&quot;上树后&quot;, myVnode1) //输出来的内容就是虚拟 dom 节点</code></pre>]]></content>
      
      
      <categories>
          
          <category> webapck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> webapck </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 Promise用法</title>
      <link href="/2022/05/08/article18/"/>
      <url>/2022/05/08/article18/</url>
      
        <content type="html"><![CDATA[<p>下面代码创造了一个 Promise 实例。</p><pre><code>const promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);</code></pre><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<br>resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。</p><pre><code>promise.then(function(value) &#123;  // success&#125;, function(error) &#123;  // failure&#125;);</code></pre><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。<br>下面是一个 Promise 对象的简单例子。</p><pre><code>function timeout(ms) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(resolve, ms, &#39;done&#39;);  &#125;);&#125;timeout(100).then((value) =&gt; &#123;  console.log(value);&#125;);</code></pre><p>上面代码中，timeout 方法返回一个 Promise 实例，表示一段时间以后才会发生的结果。过了指定的时间（ms 参数）以后，Promise 实例的状态变为 resolved，就会触发 then 方法绑定的回调函数。<br>Promise 新建后就会立即执行。</p><pre><code>let promise = new Promise(function(resolve, reject) &#123;  console.log(&#39;Promise&#39;);  resolve();&#125;);promise.then(function() &#123;  console.log(&#39;resolved.&#39;);&#125;);console.log(&#39;Hi!&#39;);// Promise// Hi!// resolved</code></pre><p>上面代码中，Promise 新建后立即执行，所以首先输出的是 Promise。然后，then 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以 resolved 最后输出。<br>下面是异步加载图片的例子。</p><pre><code>function loadImageAsync(url) &#123;  return new Promise(function(resolve, reject) &#123;    const image = new Image();    image.onload = function() &#123;      resolve(image);    &#125;;    image.onerror = function() &#123;      reject(new Error(&#39;Could not load image at &#39; + url));    &#125;;    image.src = url;  &#125;);&#125;</code></pre><p>上面代码中，使用 Promise 包装了一个图片加载的异步操作。如果加载成功，就调用 resolve 方法，否则就调用 reject 方法。<br>Promise 是一个构造函数，自己身上有 all、reject、resolve 这几个眼熟的方法，原型上有 then、catch 等同样很眼熟的方法。<br>那就 new 一个</p><pre><code>var p = new Promise(function(resolve, reject)&#123;    //做一些异步操作    setTimeout(function()&#123;        console.log(&#39;执行完成&#39;);        resolve(&#39;随便什么数据&#39;);    &#125;, 2000);&#125;);</code></pre><p>Promise 的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve 是将 Promise 的状态置为 fullfiled，reject 是将 Promise 的状态置为 rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是 setTimeout，2 秒后，输出“执行完成”，并且调用 resolve 方法。<br>运行代码，会在 2 秒后输出“执行完成”。注意！我只是 new 了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用 Promise 的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p><pre><code>function runAsync()&#123;    var p = new Promise(function(resolve, reject)&#123;        //做一些异步操作        setTimeout(function()&#123;            console.log(&#39;执行完成&#39;);            resolve(&#39;随便什么数据&#39;);        &#125;, 2000);    &#125;);    return p;&#125;runAsync()</code></pre><p>这时候你应该有两个疑问：</p><p>1.包装这么一个函数有什么用？</p><p>2.resolve(‘随便什么数据’);这是干毛的？</p><p>我们继续来讲。在我们包装好的函数最后，会 return 出 Promise 对象，也就是说，执行这个函数我们得到了一个 Promise 对象。还记得 Promise 对象上有 then、catch 方法吧？这就是强大之处了，看下面的代码：</p><pre><code>runAsync().then(function(data)&#123;    console.log(data);    //后面可以用传过来的数据做些其他操作    //......&#125;);</code></pre><p>在 runAsync()的返回上直接调用 then 方法，then 接收一个参数，是函数，并且会拿到我们在 runAsync 中调用 resolve 时传的的参数。运行这段代码，会在 2 秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p>这时候你应该有所领悟了，原来 then 里面的函数就跟我们平时的回调函数一个意思，能够在 runAsync 这个异步任务执行完成之后被执行。这就是 Promise 的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><p>你可能会不屑一顾，那么牛逼轰轰的 Promise 就这点能耐？我把回调函数封装一下，给 runAsync 传进去不也一样吗，就像这样：</p><pre><code>function runAsync(callback)&#123;    setTimeout(function()&#123;        console.log(&#39;执行完成&#39;);        callback(&#39;随便什么数据&#39;);    &#125;, 2000);&#125;runAsync(function(data)&#123;    console.log(data);&#125;);</code></pre><p>效果也是一样的，还费劲用 Promise 干嘛。那么问题来了，有多层回调该怎么办？如果 callback 也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个 callback2，然后给 callback 传进去吧。而 Promise 的优势在于，可以在 then 方法中继续写 Promise 对象并返回，然后继续调用 then 来进行回调操作。</p><h4 id="链式操作的用法"><a href="#链式操作的用法" class="headerlink" title="链式操作的用法"></a><strong>链式操作的用法</strong></h4><p>所以，从表面上看，Promise 只是能够简化层层回调的写法，而实质上，Promise 的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递 callback 函数要简单、灵活的多。所以使用 Promise 的正确场景是这样的：</p><pre><code>runAsync1().then(function(data)&#123;    console.log(data);    return runAsync2();&#125;).then(function(data)&#123;    console.log(data);    return runAsync3();&#125;).then(function(data)&#123;    console.log(data);&#125;);</code></pre><p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在 runAsync2 中传给 resolve 的数据，能在接下来的 then 方法中拿到。运行结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20181118110118300.png"></p><p>猜猜 runAsync1、runAsync2、runAsync3 这三个函数都是如何定义的？没错，就是下面这样</p><pre><code>function runAsync1()&#123;    var p = new Promise(function(resolve, reject)&#123;        //做一些异步操作        setTimeout(function()&#123;            console.log(&#39;异步任务1执行完成&#39;);            resolve(&#39;随便什么数据1&#39;);        &#125;, 1000);    &#125;);    return p;&#125;function runAsync2()&#123;    var p = new Promise(function(resolve, reject)&#123;        //做一些异步操作        setTimeout(function()&#123;            console.log(&#39;异步任务2执行完成&#39;);            resolve(&#39;随便什么数据2&#39;);        &#125;, 2000);    &#125;);    return p;&#125;function runAsync3()&#123;    var p = new Promise(function(resolve, reject)&#123;        //做一些异步操作        setTimeout(function()&#123;            console.log(&#39;异步任务3执行完成&#39;);            resolve(&#39;随便什么数据3&#39;);        &#125;, 2000);    &#125;);    return p;&#125;</code></pre><p>在 then 方法中，你也可以直接 return 数据而不是 Promise 对象，在后面的 then 中就可以接收到数据了，比如我们把上面的代码修改成这样：</p><pre><code>runAsync1().then(function(data)&#123;    console.log(data);    return runAsync2();&#125;).then(function(data)&#123;    console.log(data);    return &#39;直接返回数据&#39;;  //这里直接返回数据&#125;).then(function(data)&#123;    console.log(data);&#125;);</code></pre><p>那么输出就变成了这样：</p><p><img src="https://img-blog.csdnimg.cn/20181118110243603.png"></p><h4 id="reject-的用法"><a href="#reject-的用法" class="headerlink" title="reject 的用法"></a><strong>reject 的用法</strong></h4><p>到这里，你应该对“Promise 是什么玩意”有了最基本的了解。那么我们接着来看看 ES6 的 Promise 还有哪些功能。我们光用了 resolve，还没用 reject 呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject 的作用就是把 Promise 的状态置为 rejected，这样我们在 then 中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><pre><code>function getNumber()&#123;    var p = new Promise(function(resolve, reject)&#123;        //做一些异步操作        setTimeout(function()&#123;            var num = Math.ceil(Math.random()*10); //生成1-10的随机数            if(num&lt;=5)&#123;                resolve(num);            &#125;            else&#123;                reject(&#39;数字太大了&#39;);            &#125;        &#125;, 2000);    &#125;);    return p;&#125;getNumber().then(    function(data)&#123;        console.log(&#39;resolved&#39;);        console.log(data);    &#125;,    function(reason, data)&#123;        console.log(&#39;rejected&#39;);        console.log(reason);    &#125;);</code></pre><p>getNumber 函数用来异步获取一个数字，2 秒后执行完成，如果数字小于等于 5，我们认为是“成功”了，调用 resolve 修改 Promise 的状态。否则我们认为是“失败”了，调用 reject 并传递一个参数，作为失败的原因。</p><p>运行 getNumber 并且在 then 中传了两个参数，then 方法可以接受两个参数，第一个对应 resolve 的回调，第二个对应 reject 的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><p><img src="https://img-blog.csdnimg.cn/20181118110405487.png"><img src="https://img-blog.csdnimg.cn/20181118110346440.png"></p><h4 id="catch-的用法"><a href="#catch-的用法" class="headerlink" title="catch 的用法"></a><strong>catch 的用法</strong></h4><p>我们知道 Promise 对象除了 then 方法，还有一个 catch 方法，它是做什么用的呢？其实它和 then 的第二个参数一样，用来指定 reject 的回调，用法是这样：</p><pre><code>getNumber().then(function(data)&#123;    console.log(&#39;resolved&#39;);    console.log(data);&#125;).catch(function(reason)&#123;    console.log(&#39;rejected&#39;);    console.log(reason);&#125;);</code></pre><p>效果和写在 then 的第二个参数里面一样。不过它还有另外一个作用：在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js，而是会进到这个 catch 方法中。请看下面的代码：</p><pre><code>getNumber().then(function(data)&#123;    console.log(&#39;resolved&#39;);    console.log(data);    console.log(somedata); //此处的somedata未定义&#125;).catch(function(reason)&#123;    console.log(&#39;rejected&#39;);    console.log(reason);&#125;);</code></pre><p>在 resolve 的回调中，我们 console.log(somedata);而 somedata 这个变量是没有被定义的。如果我们不用 Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><p><img src="https://img-blog.csdnimg.cn/20181118110528999.png"></p><p>也就是说进到 catch 方法里面去了，而且把错误原因传到了 reason 参数中。即便是有错误的代码也不会报错了，这与我们的 try/catch 语句有相同的功能。</p><h4 id="all-的用法"><a href="#all-的用法" class="headerlink" title="all 的用法"></a><strong>all 的用法</strong></h4><p>Promise 的 all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的 runAsync1、runAsync2、runAsync3 这三个函数，看下面的例子：</p><pre><code>Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123;    console.log(results);&#125;);</code></pre><p>用 Promise.all 来执行，all 接收一个数组参数，里面的值最终都算返回 Promise 对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到 then 里面。那么，三个异步操作返回的数据哪里去了呢？都在 then 里面呢，all 会把所有异步操作的结果放进一个数组中传给 then，就是上面的 results。所以上面代码的输出结果就是：</p><p><img src="https://img-blog.csdnimg.cn/2018111811063113.png"></p><p>有了 all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash 以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><h4 id="race-的用法"><a href="#race-的用法" class="headerlink" title="race 的用法"></a><strong>race 的用法</strong></h4><p>all 方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是 race 方法，这个词本来就是赛跑的意思。race 的用法与 all 一样，我们把上面 runAsync1 的延时改为 1 秒来看一下：</p><pre><code>Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123;    console.log(results);&#125;);</code></pre><p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1 秒后 runAsync1 已经执行完了，此时 then 里面的就执行了。结果是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20181118110730499.png"></p><p>你猜对了吗？不完全，是吧。在 then 里面的回调开始执行时，runAsync2()和 runAsync3()并没有停止，仍旧再执行。于是再过 1 秒后，输出了他们结束的标志。</p><p>这个 race 有什么用呢？使用场景还是很多的，比如我们可以用 race 给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><pre><code>//请求某个图片资源function requestImg()&#123;var p = new Promise(function(resolve, reject)&#123;var img = new Image();img.onload = function()&#123;resolve(img);&#125;img.src = &#39;xxxxxx&#39;;&#125;);return p;&#125;//延时函数，用于给请求计时function timeout()&#123;    var p = new Promise(function(resolve, reject)&#123;        setTimeout(function()&#123;            reject(&#39;图片请求超时&#39;);        &#125;, 5000);    &#125;);    return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123;    console.log(results);&#125;).catch(function(reason)&#123;    console.log(reason);&#125;);</code></pre><p>requestImg 函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout 函数是一个延时 5 秒的异步操作。我们把这两个返回 Promise 对象的函数放进 race，于是他俩就会赛跑，如果 5 秒之内图片请求成功了，那么遍进入 then 方法，执行正常的流程。如果 5 秒钟图片还未成功返回，那么 timeout 就跑赢了，则进入 catch，报出“图片请求超时”的信息。运行结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20181118110835406.png"></p><p>转自————<a href="https://www.cnblogs.com/samve/">Samve</a>promise 用法讲解</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件、事件类型、事件流和事件模型</title>
      <link href="/2022/04/26/article17/"/>
      <url>/2022/04/26/article17/</url>
      
        <content type="html"><![CDATA[<h3 id="一、事件是什么？"><a href="#一、事件是什么？" class="headerlink" title="一、事件是什么？"></a>一、事件是什么？</h3><p>事件 (Event) 是 JavaScript 应用跳动的心脏 ，进行交互，使网页动起来。当我们与浏览器中 Web 页面进行某些类型的交互时，事件就发生了。事件可能是用户在某些内容上的点击、鼠标经过某个特定元素或按下键盘上的某些按键。事件还可能是 Web 浏览器中发生的事情，比如说某个 Web 页面加载完成，或者是用户滚动窗口或改变窗口大小。</p><p>通过使用 JavaScript ，你可以监听特定事件的发生，并规定让某些事件发生以对这些事件做出响应。</p><h3 id="1、事件作用"><a href="#1、事件作用" class="headerlink" title="1、事件作用"></a>1、事件作用</h3><p>（1）验证用户输入的数据。</p><p>（2）增加页面的动感效果。</p><p>（3）增强用户的体验度</p><h3 id="2、事件中的几个名词"><a href="#2、事件中的几个名词" class="headerlink" title="2、事件中的几个名词"></a>2、事件中的几个名词</h3><p>-事件源: 谁触发的事件 -事件名: 触发了什么事件 -事件监听: 谁管这个事情，谁监视？ -事件处理:发生了怎么办</p><p>例如</p><p>-闯红灯 事件源:车 ; 事件名: 闯红灯; 监听：摄像头、交警 ; 处理:扣分罚款 -单击按钮 事件源:按钮; 事件名: 单击; 监听:窗口 ; 处理:执行函数</p><p>当我们用户在页面中进行的点击动作，鼠标移动的动作，网页页面加载完成的动作等，都可以称之为事件名称，即：click、mousemove、load 等都是事件名称，具体的执行代码处理，响应某个事件的函数。</p><pre><code>&lt;body onload=&quot;loadWindow();&quot;&gt;&lt;/body&gt;&lt;script&gt;    function loadWindow()&#123;        alert(&quot;加载窗体&quot;);    &#125;&lt;/script&gt;</code></pre><h3 id="二、事件类型"><a href="#二、事件类型" class="headerlink" title="二、事件类型"></a>二、事件类型</h3><p>JavaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件。</p><p><a href="http://www.w3school.com.cn/tags/html_ref_eventattributes.asp">http://www.w3school.com.cn/tags/html_ref_eventattributes.asp</a> 用+查</p><p>Window 事件属性：针对 window 对象触发的事件（应用到 <body> 标签）</p><p>Form 事件：由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中）</p><p>Keyboard 事件 : 键盘事件</p><p>Mouse 事件：由鼠标或类似用户动作触发的事件</p><p>Media 事件：由媒介（比如视频、图像和音频）触发的事件（适用于所有 HTML 元素，但常见于媒介元素中，比如 <audio>、<embed>、<img>、<object> 以及 <video>）</p><p>几个常用的事件：</p><p>onclick 、onblur 、onfocus 、onload 、onchange</p><p>onmouseover、onmouseout、onkeyup、onkeydown</p><p>onload：当页面或图像加载完后立即触发<br>onblur：元素失去焦点<br>onfocus：元素获得焦点<br>onclick：鼠标点击某个对象<br>onchange：用户改变域的内容<br>onmouseover：鼠标移动到某个元素上<br>onmouseout：鼠标从某个元素上离开<br>onkeyup：某个键盘的键被松开<br>onkeydown：某个键盘的键被按下</p><h3 id="三、事件流和事件模型"><a href="#三、事件流和事件模型" class="headerlink" title="三、事件流和事件模型"></a>三、事件流和事件模型</h3><p>我们的事件最后都有一个特定的事件源，暂且将事件源看做是 HTML 的某个元素，那么当一个 HTML 元素产生一个事件时，该事件会在元素节点与根节点之间按特定的顺序传播，路径所经过的节点都会受到该事件，这个传播过程称为 DOM 事件流。</p><p>事件顺序有两种类型：事件捕获 和 事件冒泡。</p><p>冒泡和捕获其实都是事件流的不同表现，这两者的产生是因为 IE 和 Netscape 两个大公司完全不同的事件流概念产生的。（事件流：是指页面接受事件的顺序）IE 的事件流是事件冒泡，Netscape 的事件流是事件捕获流。</p><h3 id="1、事件冒泡"><a href="#1、事件冒泡" class="headerlink" title="1、事件冒泡"></a>1、事件冒泡</h3><p>IE 的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点（文档）。例如下面的：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;JavaScript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;myDiv&quot;&gt;Click me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>如果点击了页面中的<div>元素，那么这个 click 事件会按照如下顺序传播：</p><p><code>1、&lt;div&gt;</code></p><p><code>2、&lt;body&gt;</code></p><p><code>3、&lt;html&gt;</code></p><p><code>4、document</code></p><p>也就是说，click 事件首先在 div 元素上发生，而这个元素就是我们单击的元素。然后，click 事件沿 DOM 树向上传播，在每一级节点上都会发生，直到传播到 document 对象。</p><p>所有现代浏览器都支持事件冒泡，但在具体实现上还是有一些差别。</p><h3 id="2、事件捕获"><a href="#2、事件捕获" class="headerlink" title="2、事件捕获"></a>2、事件捕获</h3><p>Netscape 提出的另一种事件流叫做事件捕获，事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。还以前面的例子为例。那么单击<div>元素就会按下列顺序触发 click 事件：</p><p><code>1、document</code></p><p><code>2、&lt;html&gt;</code></p><p><code>3、&lt;body&gt;</code></p><p><code>4、&lt;div&gt;</code></p><p>在事件捕获过程中，document 对象首先接收到 click 事件，然后沿 DOM 树依次向下，一直传播到事件的实际目标，即<div>元素。</p><p>虽然事件捕获是 Netscape 唯一支持的事件流模式，但很多主流浏览器目前也都支持这种事件流模型。尽管“DOM2 级事件”规范要求事件应该从 document 对象开始时传播，但这些浏览器都是从 window 对象开始捕获的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3项目搭建规范</title>
      <link href="/2022/04/04/article16/"/>
      <url>/2022/04/04/article16/</url>
      
        <content type="html"><![CDATA[<h2 id="一-代码规范"><a href="#一-代码规范" class="headerlink" title="一. 代码规范"></a>一. 代码规范</h2><h3 id="1-1-集成-editorconfig-配置"><a href="#1-1-集成-editorconfig-配置" class="headerlink" title="1.1 集成 editorconfig 配置"></a>1.1 集成 editorconfig 配置</h3><p>EditorConfig 有助于为不同 IDE 编辑器上维护一致的编码风格<br>安装插件：EditorConfig for VS Code 后会读取.editorconfig 文件</p><h1 id="http-editorconfig-org"><a href="#http-editorconfig-org" class="headerlink" title="http://editorconfig.org"></a><a href="http://editorconfig.org/">http://editorconfig.org</a></h1><pre><code>root = true[*] # 表示所有文件适用charset = utf-8 # 设置文件字符集为 utf-8indent_style = space # 缩进风格（tab | space）indent_size = 2 # 缩进大小end_of_line = lf # 控制换行类型(lf | cr | crlf)trim_trailing_whitespace = true # 去除行首的任意空白字符insert_final_newline = true # 始终在文件末尾插入一个新行[*.md] # 表示仅 md 文件适用以下规则max_line_length = offtrim_trailing_whitespace = false</code></pre><h3 id="1-2-使用-prettier-工具"><a href="#1-2-使用-prettier-工具" class="headerlink" title="1.2 使用 prettier 工具"></a>1.2 使用 prettier 工具</h3><p>Prettier 是一款强大的格式化工具</p><p>1.安装开发式（-D）依赖 prettier<br><code>npm install prettier -D</code></p><ol><li>配置.prettierrc 文件：</li></ol><ul><li><p>useTabs：使用 tab 缩进还是空格缩进，选择 false；</p></li><li><p>tabWidth：tab 是空格的情况下，是几个空格，选择 2 个；</p></li><li><p>printWidth：当行字符的长度，推荐 80，也有人喜欢 100 或者 120；</p></li><li><p>singleQuote：使用单引号还是双引号，选择 true，使用单引号；</p></li><li><p>trailingComma：在多行输入的尾逗号是否添加，设置为 none；</p></li><li><p>semi：语句末尾是否要加分号，默认值 true，选择 false 表示不加；</p><pre><code>&#123;  &quot;useTabs&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;printWidth&quot;: 80,  &quot;singleQuote&quot;: true,  &quot;trailingComma&quot;: &quot;none&quot;,  &quot;semi&quot;: false&#125;</code></pre><p>3.创建.prettierignore 忽略文件</p><pre><code>/dist/*.local.output.js/node_modules/****/*.svg**/*.sh/public/*</code></pre><p>4.VSCode 需要安装 prettier 的插件：<code>Prettier-Code formatter</code></p><p>5.在 package.json 中配置一个 scripts</p></li></ul><p><code>&quot;prettier&quot;: &quot;prettier --write .&quot;</code></p><p>6.执行脚本：</p><pre><code>`npm run prettier`</code></pre><h3 id="1-3-使用-ESLint-检测"><a href="#1-3-使用-ESLint-检测" class="headerlink" title="1.3 使用 ESLint 检测#"></a>1.3 使用 ESLint 检测<a href="https://www.cnblogs.com/Acyang/p/15649095.html#13-%E4%BD%BF%E7%94%A8eslint%E6%A3%80%E6%B5%8B">#</a></h3><ol><li><p>VSCode 安装 ESLint 插件：<code>ESLint</code></p></li><li><p>解决 eslint 和 prettier 冲突的问题<br><code>npm i eslint-plugin-prettier eslint-config-prettier -D</code></p></li><li><p>添加 prettier 插件</p><p>extends: [<br>“plugin:vue/vue3-essential”,<br>“eslint:recommended”,<br>“@vue/typescript/recommended”,<br>“@vue/prettier”,<br>“@vue/prettier/@typescript-eslint”,<br>‘plugin:prettier/recommended’<br>],</p></li></ol><h2 id="二、项目搭建规范-第三方库集成"><a href="#二、项目搭建规范-第三方库集成" class="headerlink" title="二、项目搭建规范-第三方库集成"></a>二、项目搭建规范-第三方库集成</h2><h3 id="2-1-vue-config-js-配置（修改-vue-cli-封装好的内部-webpack）"><a href="#2-1-vue-config-js-配置（修改-vue-cli-封装好的内部-webpack）" class="headerlink" title="2.1 vue.config.js 配置（修改 vue-cli 封装好的内部 webpack）"></a>2.1 vue.config.js 配置（修改 vue-cli 封装好的内部 webpack）</h3><p>node 接受 commonJS 模板规范</p><pre><code>const path require(&#39;path&#39;)module.exports = &#123;    // 1. 配置方式一： CLI提供的属性    outputDir: &#39;./build&#39;,    publicPath: &#39;./&#39;, // 打包后文件是相对路径    // 2. 配置方式二： 和Webpack属性完全一致，最后会进行合并    configureWebpack: &#123;        resolve: &#123;            alias: &#123;                components: &#39;@/components&#39;            &#125;        &#125;    &#125;,    // configure是函数形式：直接覆盖原Webpack配置    configureWebpack: (config) =&gt; &#123;        config.resolve.alias = &#123;            &quot;@&quot;: path.resolve(__dirname, &#39;src&#39;),            components: &#39;@/components&#39;        &#125;    &#125;,    // 3. 配置方式三：chainWebpack链式形式    chainWebpack: (config) =&gt; &#123;        config.resolve.alias.set(&#39;@&#39;, path.resolve(__dirname, &#39;src&#39;).set(&#39;components&#39;, &#39;@/components&#39;))    &#125;&#125;</code></pre><h3 id="2-2-vue-router-集成"><a href="#2-2-vue-router-集成" class="headerlink" title="2.2 vue-router 集成"></a>2.2 vue-router 集成</h3><ol><li><p>安装 vue-router 最新版本</p><p><code> npm install vue-router@next</code></p><p><code>defineComponent</code>：定义组件，更好的支持 ts</p></li><li><p>创建 router 对象</p><p>import { createRouter, createWebHashHistory } from ‘vue-router’;<br>import type { RouteRecordRaw } from ‘vue-router’; // 声明导入的是一个 type，可不加</p><p>const routes: RouteRecordRaw[] = [<br>{<br>path: ‘/‘,<br>redirect: ‘/login’<br>},<br>{<br>path: ‘/login’,<br>component: () =&gt; import(‘@/views/login/index.vue’)<br>},<br>{<br>path: ‘/main’,<br>component: () =&gt; import(‘@/views/main/index.vue’)<br>}<br>]</p><p>const router = createRouter({<br>routes,<br>history: createWebHashHistory()<br>})</p><p>export default router</p></li></ol><h3 id="2-3-element-plus-集成"><a href="#2-3-element-plus-集成" class="headerlink" title="2.3 element-plus 集成"></a>2.3 element-plus 集成</h3><ol><li><p>全局引用：所有组件全部集成</p><p> 优点：集成简单，方便使用<br> 缺点：全部会打包</p><p> import ElementPlus from ‘element-plus’;<br> import ‘element-plus/theme-chalk/index.css’;<br> app.use(ElementPlus)</p></li><li><p>按需引用</p><p> 优点：包会小一些<br> 缺点：引用麻烦</p><pre><code> &lt;el-button type=&quot;primary&quot;&gt;哈哈哈哈&lt;/el-button&gt;</code></pre><p> import { ElButton } from ‘element-plus’<br> import ‘element-plus/theme-chalk/base.css’;<br> import ‘element-plus/theme-chalk/el-button.css’;</p><p> components: {<br> ElButton<br> }</p></li></ol><p>以上方法太麻烦，可以添加 babel-plugin-import 工具进行按需引入，并进行配置</p><p><code>npm install babel-plugin-import -D</code></p><pre><code>// babel.config.jsmodule.exports = &#123;  plugins: [    [      &#39;import&#39;,      &#123;        libraryName: &#39;element-plus&#39;,        // 引入组件        customName: (name) =&gt; &#123;          name = name.slice(3)          return `element-plus/lib/components/$&#123;name&#125;`        &#125;,        // 引入样式        customStyleName: (name) =&gt; &#123;          name = name.slice(3)          // 如果你需要引入 [name].scss 文件，你需要用下面这行          // return `element-plus/lib/components/$&#123;name&#125;/style`          // 引入 [name].css          return `element-plus/lib/components/$&#123;name&#125;/style/css`        &#125;      &#125;    ]  ],  presets: [&#39;@vue/cli-plugin-babel/preset&#39;]&#125;</code></pre><ul><li><p>main.ts 入口文件存放主要逻辑</p></li><li><p>把共性的逻辑进行抽取</p><p>// main.ts<br>import { createApp, App } from ‘vue’<br>import { globalRegister } from ‘./global’<br>import rootApp from ‘./App.vue’</p><p>const app: App = createApp(rootApp)</p><p>/** app.use()有传入函数的两种方式<br>app.use(function(app: App) {</p><pre><code>  &#125;)  app.use(&#123;      install: function(app: App) &#123;      &#125;  &#125;)</code></pre><p>*/</p><p>// 方式一：<br>globalRegister(app)<br>// 方式二：更优雅<br>app.use(globalRegister)</p><p>// global/index.ts<br>import { App } from ‘vue’<br>import registerElement from ‘./regiserElement’<br>export function globalRegister(app: App): void {<br>registerElement(app)<br>}</p><p>// global/registerELement<br>import { App } from ‘vue’<br>import ‘element-plus/theme-chalk/base.css’;<br>import { ElButton, ElForm } from ‘element-plus’</p><p>const components = [<br>ElButton,<br>ElForm<br>]</p><p>export default function (app: App): void {<br>for (const component of components) {<br>app.component(component.name, component)<br>}<br>}</p></li></ul><h2 id="三、其他文件"><a href="#三、其他文件" class="headerlink" title="三、其他文件"></a>三、其他文件</h2><h3 id="1-browserslistrc-帮助我们做浏览器适配"><a href="#1-browserslistrc-帮助我们做浏览器适配" class="headerlink" title="1. browserslistrc - 帮助我们做浏览器适配"></a>1. browserslistrc - 帮助我们做浏览器适配</h3><ul><li>帮助我们做浏览器适配</li><li>css 查询文件</li><li>babel：ES6 TS -&gt; JS</li></ul><blockquote><p>1% // 市场份额大于百分之一的浏览器<br>last 2 versions // 适配主流浏览器的最新的两个版本<br>not dead // 目前浏览器处于维护状态的 xxxxxxxxxx &gt; 1% // 市场份额大于百分之一的浏览器 last 2 versions // 适配主流浏览器的最新的两个版本 not dead // 目前浏览器处于维护状态的 onload：当页面或图像加载完后立即触发 onblur：元素失去焦点 onfocus：元素获得焦点 onclick：鼠标点击某个对象 onchange：用户改变域的内容 onmouseover：鼠标移动到某个元素上 onmouseout：鼠标从某个元素上离开 onkeyup：某个键盘的键被松开 onkeydown：某个键盘的键被按下</p></blockquote><h3 id="2-tsconfig-json-TS-配置文件"><a href="#2-tsconfig-json-TS-配置文件" class="headerlink" title="2.tsconfig.json - TS 配置文件"></a>2.tsconfig.json - TS 配置文件</h3><pre><code>&#123;  &quot;compilerOptions&quot;: &#123; // 编译选项    // 目标代码（ts -&gt; js(es5/6/7)）    &quot;target&quot;: &quot;esnext&quot;,    // 目标代码需要使用的模块化方案(commonjs require/module.exports/es module import/export)，常写umd，代表支持多种模块化    &quot;module&quot;: &quot;esnext&quot;,    // 严格的检查(any)    &quot;strict&quot;: true,    // 对jsx进行怎样的处理，不转化preserve保留    &quot;jsx&quot;: &quot;preserve&quot;,    // 辅助导入功能    &quot;importHelpers&quot;: true,    // 按照node方式去解析模块 import &quot;/index.node .json .js&quot;    &quot;moduleResolution&quot;: &quot;node&quot;,    // 跳过一些库的类型检测(axios本身会定义很多类型，提高性能，有可能多个库的类型命名会冲突)    &quot;skipLibCheck&quot;: true,    // export default/module.exports = &#123;&#125;是否能混合使用    // es module / commonjs 是否能混合使用    &quot;esModuleInterop&quot;: true,    &quot;allowSyntheticDefaultImports&quot;: true,    // 要不要生成映射文件(ts -&gt; js)    &quot;sourceMap&quot;: true,    // 文件路径在解析时的基本的url    &quot;baseUrl&quot;: &quot;.&quot;,    // 指定具体要解析使用的类型，不传时target写的什么类型在这里就可以使用    &quot;types&quot;: [&quot;webpack-env&quot;],    // 编译的路径解析，使用@/components会在src/components中寻找    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [&quot;src/*&quot;],      &quot;components/*&quot;: [&quot;src/components/*&quot;] // (我们自己新增的)    &#125;,    // 可以指定在项目中可以使用哪些库的类型(Proxy/Window/Document)    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;, &quot;scripthost&quot;]  &#125;,  // 哪些文件需要被约束和解析  &quot;include&quot;: [    &quot;src/**/*.ts&quot;,    &quot;src/**/*.tsx&quot;,    &quot;src/**/*.vue&quot;,    &quot;tests/**/*.ts&quot;,    &quot;tests/**/*.tsx&quot;  ],  // 排除哪些文件被约束和解析  &quot;exclude&quot;: [&quot;node_modules&quot;]&#125;</code></pre><h3 id="3-shims-vue-d-ts-声明，防止报错"><a href="#3-shims-vue-d-ts-声明，防止报错" class="headerlink" title="3.shims-vue.d.ts 声明，防止报错"></a>3.shims-vue.d.ts 声明，防止报错</h3><pre><code>declare module &#39;*.vue&#39; &#123;  import type &#123; DefineComponent &#125; from &#39;vue&#39;  const component: DefineComponent&lt;&#123;&#125;, &#123;&#125;, any&gt;  export default component&#125;</code></pre><p>// 声明一下$store，防止报错<br><code>declare let $store: any</code></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何基于 React 封装一个组件</title>
      <link href="/2022/03/18/article15/"/>
      <url>/2022/03/18/article15/</url>
      
        <content type="html"><![CDATA[<h2 id="antd-是如何封装组件的"><a href="#antd-是如何封装组件的" class="headerlink" title="antd 是如何封装组件的"></a>antd 是如何封装组件的</h2><h3 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h3><ul><li>antd 仓库地址：<a href="https://github.com/ant-design/ant-design">https://github.com/ant-design/ant-design</a></li><li>divider 组件在下图对应目录下 (代码我会拷贝过来，感兴趣的还是可以去克隆一下仓库)<br><img src="https://img2020.cnblogs.com/blog/2352436/202111/2352436-20211127180234938-992380461.png"></li></ul><h3 id="divider-组件源代码"><a href="#divider-组件源代码" class="headerlink" title="divider 组件源代码"></a>divider 组件源代码</h3><p>antd 的源码使用了 TypeScript 语法，因此不了解语法的同学要及时了解！</p><pre><code>import * as React from &#39;react&#39;;import classNames from &#39;classnames&#39;;import &#123; ConfigConsumer, ConfigConsumerProps &#125; from &#39;../config-provider&#39;;export interface DividerProps &#123;    prefixCls?: string;    type?: &#39;horizontal&#39; | &#39;vertical&#39;;    orientation?: &#39;left&#39; | &#39;right&#39; | &#39;center&#39;;    className?: string;    children?: React.ReactNode;    dashed?: boolean;    style?: React.CSSProperties;    plain?: boolean;&#125;const Divider: React.FC&lt;DividerProps&gt; = props =&gt; (    &lt;ConfigConsumer&gt;        &#123;(&#123; getPrefixCls, direction &#125;: ConfigConsumerProps) =&gt; &#123;            const &#123;                prefixCls: customizePrefixCls,                type = &#39;horizontal&#39;,                orientation = &#39;center&#39;,                className,                children,                dashed,                plain,                ...restProps            &#125; = props;            const prefixCls = getPrefixCls(&#39;divider&#39;, customizePrefixCls);            const orientationPrefix = orientation.length &gt; 0 ? `-$&#123;orientation&#125;` : orientation;            const hasChildren = !!children;            const classString = classNames(                prefixCls,                `$&#123;prefixCls&#125;-$&#123;type&#125;`,                &#123;                    [`$&#123;prefixCls&#125;-with-text`]: hasChildren,                    [`$&#123;prefixCls&#125;-with-text$&#123;orientationPrefix&#125;`]: hasChildren,                    [`$&#123;prefixCls&#125;-dashed`]: !!dashed,                    [`$&#123;prefixCls&#125;-plain`]: !!plain,                    [`$&#123;prefixCls&#125;-rtl`]: direction === &#39;rtl&#39;,                &#125;,                className,            );            return (                &lt;div className=&#123;classString&#125; &#123;...restProps&#125; role=&quot;separator&quot;&gt;                    &#123;children &amp;&amp; &lt;span className=&#123;`$&#123;prefixCls&#125;-inner-text`&#125;&gt;&#123;children&#125;&lt;/span&gt;&#125;                &lt;/div&gt;            );        &#125;&#125;    &lt;/ConfigConsumer&gt;);export default Divider;</code></pre><h3 id="如何暴露组件属性"><a href="#如何暴露组件属性" class="headerlink" title="如何暴露组件属性"></a>如何暴露组件属性</h3><p>在源码中，最先看到的是以下内容，这些属性也就是 divider 组件所暴露的属性，我们可以 <code>&lt;Divider type=&#39;vertical&#39; /&gt;</code> 这样来传入 type 属性，那么 divider 分割线样式就会渲染为垂直分割线，是不是很熟悉！</p><pre><code>export interface DividerProps &#123; // interface 是 TypeScript 的语法    prefixCls?: string;    type?: &#39;horizontal&#39; | &#39;vertical&#39;; // 限定 type 只能传入两个值中的一个    orientation?: &#39;left&#39; | &#39;right&#39; | &#39;center&#39;;    className?: string;    children?: React.ReactNode;    dashed?: boolean;    style?: React.CSSProperties;    plain?: boolean;&#125;</code></pre><p>在上面的属性中，我们还发现 className 和 style 是比较常见的属性，这代表我们可以 <code>&lt;Divider type=&#39;vertical&#39; className=&#39;myClassName&#39; style=&#123;&#123;width: '1em'&#125;&#125; /&gt;</code> 这样使用这些属性。</p><h3 id="如何设置统一类名前缀"><a href="#如何设置统一类名前缀" class="headerlink" title="如何设置统一类名前缀"></a>如何设置统一类名前缀</h3><p>我们知道，antd 的组件类名会有他们独特的前缀 <code>ant-</code>，这是如何处理的呢？继续看源码。</p><pre><code>&lt;ConfigConsumer&gt;    &#123;(&#123; getPrefixCls, direction &#125;: ConfigConsumerProps) =&gt; &#123;        const &#123;            prefixCls: customizePrefixCls,            type = &#39;horizontal&#39;,            orientation = &#39;center&#39;,            className,            children,            dashed,            plain,            ...restProps        &#125; = props;        const prefixCls = getPrefixCls(&#39;divider&#39;, customizePrefixCls);</code></pre><p>​<br> 从源码中，发现 prefixCls ，是通过 getPrefixCls 方法生成，再看看 getPrefixCls 方法的源码，如下。</p><pre><code>    export interface ConfigConsumerProps &#123;  ...  getPrefixCls: (suffixCls?: string, customizePrefixCls?: string) =&gt; string;  ...&#125;const defaultGetPrefixCls = (suffixCls?: string, customizePrefixCls?: string) =&gt; &#123;  if (customizePrefixCls) return customizePrefixCls;  return suffixCls ? `ant-$&#123;suffixCls&#125;` : &#39;ant&#39;;&#125;;</code></pre><p>不难发现此时会生成的类名前缀为 <code>ant-divider</code> 。</p><h3 id="如何处理样式与类名"><a href="#如何处理样式与类名" class="headerlink" title="如何处理样式与类名"></a>如何处理样式与类名</h3><p>我们封装的组件肯定是有预设的样式，又因为样式要通过类名来定义，而我们传入的属性值则会决定组件上要添加哪个类名，这又是如何实现的呢？下面看源码。</p><pre><code> import classNames from &#39;classnames&#39;; const classString = classNames(     prefixCls,     `$&#123;prefixCls&#125;-$&#123;type&#125;`,     &#123;         [`$&#123;prefixCls&#125;-with-text`]: hasChildren,         [`$&#123;prefixCls&#125;-with-text$&#123;orientationPrefix&#125;`]: hasChildren,         [`$&#123;prefixCls&#125;-dashed`]: !!dashed,         [`$&#123;prefixCls&#125;-plain`]: !!plain,         [`$&#123;prefixCls&#125;-rtl`]: direction === &#39;rtl&#39;,     &#125;,     className, ); return (     &lt;div className=&#123;classString&#125; &#123;...restProps&#125; role=&quot;separator&quot;&gt;         &#123;children &amp;&amp; &lt;span className=&#123;`$&#123;prefixCls&#125;-inner-text`&#125;&gt;&#123;children&#125;&lt;/span&gt;&#125;     &lt;/div&gt; );</code></pre><p>它通过 classNames 方法（<a href="https://www.npmjs.com/package/classnames">classNames 是 React 处理多类名的组件</a>）定义了一个所有类名的常量，然后传给了 div 中的 className 属性。</p><p>其实生成的类名也就是 <code>ant-divider-horizontal</code> 这个样子，那么 css 中以此类名定义的样式也就自然会生效了。而 className 和 style 属性则是通过 <code>&#123;...restProps&#125;</code> 来传入。</p><p>最后我们再看看它的 css 样式代码是怎么写的！</p><h3 id="divider-组件样式源代码"><a href="#divider-组件样式源代码" class="headerlink" title="divider 组件样式源代码"></a>divider 组件样式源代码</h3><p>antd 组件的样式使用 Less 书写，不了解 Less 语法的同学一定要了解一下。</p><pre><code>@import &#39;../../style/themes/index&#39;;@import &#39;../../style/mixins/index&#39;;@divider-prefix-cls: ~&#39;@&#123;ant-prefix&#125;-divider&#39;; // 可以看到这里对应的也就是之前说到的类名前缀.@&#123;divider-prefix-cls&#125; &#123;  .reset-component();  border-top: @border-width-base solid @divider-color;  &amp;-vertical &#123; // 这里的完整类名其实就是 ant-divider-vertical, 也就是 divider 组件的 type 属性值为 vertical 时对应的样式    position: relative;    top: -0.06em;    display: inline-block;    height: 0.9em;    margin: 0 8px;    vertical-align: middle;    border-top: 0;    border-left: @border-width-base solid @divider-color;  &#125;  &amp;-horizontal &#123;    display: flex;    clear: both;    width: 100%;    min-width: 100%;    margin: 24px 0;  &#125;  &amp;-horizontal&amp;-with-text &#123;    display: flex;    margin: 16px 0;    color: @heading-color;    font-weight: 500;    font-size: @font-size-lg;    white-space: nowrap;    text-align: center;    border-top: 0;    border-top-color: @divider-color;    &amp;::before,    &amp;::after &#123;      position: relative;      top: 50%;      width: 50%;      border-top: @border-width-base solid transparent;      // Chrome not accept `inherit` in `border-top`      border-top-color: inherit;      border-bottom: 0;      transform: translateY(50%);      content: &#39;&#39;;    &#125;  &#125;  &amp;-horizontal&amp;-with-text-left &#123;    &amp;::before &#123;      top: 50%;      width: @divider-orientation-margin;    &#125;    &amp;::after &#123;      top: 50%;      width: 100% - @divider-orientation-margin;    &#125;  &#125;  &amp;-horizontal&amp;-with-text-right &#123;    &amp;::before &#123;      top: 50%;      width: 100% - @divider-orientation-margin;    &#125;    &amp;::after &#123;      top: 50%;      width: @divider-orientation-margin;    &#125;  &#125;  &amp;-inner-text &#123;    display: inline-block;    padding: 0 @divider-text-padding;  &#125;  &amp;-dashed &#123;    background: none;    border-color: @divider-color;    border-style: dashed;    border-width: @border-width-base 0 0;  &#125;  &amp;-horizontal&amp;-with-text&amp;-dashed &#123;    border-top: 0;    &amp;::before,    &amp;::after &#123;      border-style: dashed none none;    &#125;  &#125;  &amp;-vertical&amp;-dashed &#123;    border-width: 0 0 0 @border-width-base;  &#125;  &amp;-plain&amp;-with-text &#123;    color: @text-color;    font-weight: normal;    font-size: @font-size-base;  &#125;&#125;@import &#39;./rtl&#39;;</code></pre><p>在源码中还有很多地方值得学习，比如这里的 ConfigConsumer 的定义与使用，感兴趣的欢迎一起交流。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP图解</title>
      <link href="/2022/03/11/article14/"/>
      <url>/2022/03/11/article14/</url>
      
        <content type="html"><![CDATA[<p>本文只要内容：</p><ul><li>了解 web 及网络基础</li><li>简单的 http 协议</li></ul><h2 id="了解-web-及网络基础"><a href="#了解-web-及网络基础" class="headerlink" title="了解 web 及网络基础"></a>了解 web 及网络基础</h2><h3 id="1、使用-http-协议访问-web"><a href="#1、使用-http-协议访问-web" class="headerlink" title="1、使用 http 协议访问 web"></a>1、使用 http 协议访问 web</h3><p>当我们用网页浏览器（web browser）的地址栏中输入 URL 时，Web 页面的呈现过程：</p><ul><li>输入 URL 时，可以看到 web 页面，即使不了解运作原理，也能看到页面</li><li>输入 URL 后，信息会被送往某处</li><li>然后从某处获得的回复，内容就会显示在 web 页面上</li></ul><p>web 页面不可能凭空显示出来，根据 web 浏览器地址栏中指定的 URL，web 浏览器会从服务器端获取文件资源等信息，从而显示 web 页面。</p><p>像这一套流程就可以称作是客户端（client）向服务端（server）获取服务器资源</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226102247007-547804454.png" alt="img"></p><p>web 使用一种名为 HTTP（HyperText Transfer Protocol），超文本传输协议作为规范，完成从客户端到服务端等一系列运作过程。而协议是指规则的约定。可以理解成，web 是建立在 HTTP 协议上通信的。</p><h3 id="2、网络基础-TCP-IP"><a href="#2、网络基础-TCP-IP" class="headerlink" title="2、网络基础 TCP/IP"></a>2、网络基础 TCP/IP</h3><p>为了了解 HTTP，必须的了解 TCP/IP 协议族。</p><p>通常使用的网络实在 TCP/IP 协议族的基础上运作的。而 HTTP 就属于他的一个子集。</p><h4 id="2-1、TCP-IP-协议族"><a href="#2-1、TCP-IP-协议族" class="headerlink" title="2.1、TCP/IP 协议族"></a>2.1、TCP/IP 协议族</h4><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如：如何探测到通信目标、由哪一方先发起通信、使用哪种语言等等好多规则。然而这种规则就是所谓的协议（protocol），你要用我就按照我协议的规则来。常用协议有：tcp，http，ftp，dhcp，dns，ip，pppoe，udp，snmp，icmp 等等。</p><p>像这样把与互联网关联的协议集合起来总称 TCP/IP，TCP/IP 实在 IP 协议通信过程中，使用到的协议族的统称</p><h4 id="2-2、TCP-ip-的分层管理"><a href="#2-2、TCP-ip-的分层管理" class="headerlink" title="2.2、TCP/ip 的分层管理"></a>2.2、TCP/ip 的分层管理</h4><p>TCP/IP 协议族重要的一点就是分层。TCP/IP 协议族按层次划分分别是：应用层、传输层、网络层和数据链路层。把塔层次化是有好处的。比如：当某个地方需求变更时，就必须吧所有的整体替换掉。而分层之后只需要把变动的层替换掉即可。下面介绍一下每个层次的作用</p><p><strong>应用层</strong></p><p>应用层决定了向用户提供应用服务时通信的活动。比如：ftp，dns 服务就是其中的两类。HTTP 协议也处于该层。</p><p><strong>传输层</strong></p><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP 和 UDP。</p><p><strong>网络层</strong></p><p>网络层用来处理网络上流动的数据包。数据包是网络传输的最小单位。该层规定了通过怎样的路径到达对方计算机，并把数据包发送给对方。</p><p><strong>链路层</strong></p><p>用来处理链接网络的硬件部分。包括操作系统、硬件的设备驱动、网卡及光纤等物理可见部分。</p><h4 id="2-3、TCP-IP-通信传输流"><a href="#2-3、TCP-IP-通信传输流" class="headerlink" title="2.3、TCP/IP 通信传输流"></a>2.3、TCP/IP 通信传输流</h4><p>比如说我想看百度网页：流程如下：</p><ul><li>客户端在应用层发出一个想看某个 WEB 页面的 HTTP 请求的时候；</li><li>接着为了传输方便，在传输层把应用层收到的数据进行分割，并在各个报文上打上标记序号及端口号后转发给网络层；</li><li>在网络层增加作为通信目的的 MAC 地址后转发给链路层，这样一来发送网络的通信请求就准备齐全了；</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层；</li><li>当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求了。</li></ul><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226105703836-1640778610.png" alt="img"></p><p>发送端在层与层之间传输数据时，每经过一层时必定会打上一个该层的首部信息。接收端没经过一层，会把消去。这种数据信心包装叫做封装。</p><p>TCP/IP 传输是三次握手，四次断开。一张图搞定一切，哈哈</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226110351929-905606021.png" alt="img"></p><h3 id="3、URI-和-URL"><a href="#3、URI-和-URL" class="headerlink" title="3、URI 和 URL"></a>3、URI 和 URL</h3><p>URI 用字符串标示某一互联网资源，而 URL 表示资源的地点。可见 URL 是 URI 的子集。</p><p>URI 要使用涵盖全部必要信息的 URI、绝对 URL 以及相对 URL。相对 URL 是指从浏览器中基本 URI 处理的 URL，来先看下 URI 的格式</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226111056726-284649747.png" alt="img"></p><h3 id="1、通信过程"><a href="#1、通信过程" class="headerlink" title="1、通信过程"></a>1、通信过程</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端相应该请求并返回。换个意思就是客户端建立通信的，服务器端在没有接收到请求之前不会发送响应。来一个示例：</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226111936554-179110730.png" alt="img"></p><p>下面的内容是客户端想服务端发的求求内容</p><p><code>GET / HTTP/1.1</code><br><code>HOST: HACKR.JP</code></p><p>起始行的 get 表示请求访问服务器的类型，成为方法。随后的字符串指明了请求访问的资源对象，也叫请求 URL，后面是版本号，用来提示客户端使用的 HTTP 协议功能</p><p>总结：请求报文是由请求方法、请求 URL、协议版本、可选的气你去头和内容实体构成的。</p><p>接下来服务器端接收到请求，会将请求内容的处理结果以相应的形式返回。</p><p><code>HTTP /1.1 200 OK</code><br><code>Date：Tue，10 JUL 2016 10:50:20 GMT</code><br><code>Content-length：398</code><br><code>Content-Type：text/html</code></p><p>来用图片详细讲解一下：</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226112725617-2066854960.png" alt="img"></p><h3 id="2、HTTP-是不保存状态的协议"><a href="#2、HTTP-是不保存状态的协议" class="headerlink" title="2、HTTP 是不保存状态的协议"></a>2、HTTP 是不保存状态的协议</h3><p>HTTP 是一种不报错状态，即无状态协议。http 协议自身不对请求和相应之间的通信状态进行保存，也就是说在 HTTP 这个级别，协议对于发送过得请求和响应不做持久化处理。</p><p>使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本事并不保留之前的请求或响应报文的信息。这是为了处理大量事务，确保协议的课伸缩性，而特意吧 HTTP 协议设计成如此简单的。但是也存在弊端，当业务处理变得棘手的情况多了,比如用户登录一家网站，即使他跳转到别的页面后，也需要保持登录状态，然而 cookie 就诞生了。有了 cookie 再用 http 协议通信，就可以管理状态了。</p><h3 id="3、HTTP-方法"><a href="#3、HTTP-方法" class="headerlink" title="3、HTTP 方法"></a>3、HTTP 方法</h3><h4 id="3-1、GET-获取资源"><a href="#3-1、GET-获取资源" class="headerlink" title="3.1、GET 获取资源"></a>3.1、GET 获取资源</h4><p>get 方法是用来请求访问已被 URL 识别的资源。指定的资源经服务端解析后返回响应内容。也就是说，请求的资源是文本，那就保持原样返回；如果像 cgi 那样的程序，则返回经过执行后的输出结果</p><p>使用 get 方法的请求响应的例子：</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226120528132-1874626847.png" alt="img"></p><h4 id="3-2、POST-传输实体主体"><a href="#3-2、POST-传输实体主体" class="headerlink" title="3.2、POST 传输实体主体"></a>3.2、POST 传输实体主体</h4><p>post 方法用来传输实体的主体。虽然用 get 方法也可以传输实体的主体，但是一般不用 get 方法进行传输，而是用 post 方法。虽说 post 的功能与 get 很相似，但是 post 的主要目的并不是获取相应的主体内容。</p><p>使用 post 方法请求的例子：</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226120758867-1985668124.png" alt="img"></p><h4 id="3-3、PUT-传输文件"><a href="#3-3、PUT-传输文件" class="headerlink" title="3.3、PUT 传输文件"></a>3.3、PUT 传输文件</h4><p>put 方法用来传输文件，就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 url 指定的位置。由于 put 的方法不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的 web 网站不适用该方法。</p><p>使用 put 方法请求的例子：</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226121403304-570945445.png" alt="img"></p><h4 id="3-4、head-获取报文首部"><a href="#3-4、head-获取报文首部" class="headerlink" title="3.4、head 获取报文首部"></a>3.4、head 获取报文首部</h4><p>head 和 get 方法一样，只是不返回报文主体部分，用于确认 url 的有效性及资源更新的日期时间等。</p><p>使用 head 方法请求的例子：</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226121709414-631298510.png" alt="img"></p><h4 id="3-5、DELETE-删除文件"><a href="#3-5、DELETE-删除文件" class="headerlink" title="3.5、DELETE 删除文件"></a>3.5、DELETE 删除文件</h4><p>delete 方法用来删除文件，是与 put 相反的方法，delete 方法按照请求 url 删除指定的资源。其本质和 put 方法一样不带验证机制，所以不适用 delete 方法。</p><p>使用 delete 方法请求的例子：</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226123200476-512062972.png" alt="img"></p><p>下面列举一些方法：其中 link 和 unlink 已被 HTTP/1.1 废弃 ，不在支持</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226123318820-192725553.png" alt="img"></p><h3 id="4、持久化"><a href="#4、持久化" class="headerlink" title="4、持久化"></a>4、持久化</h3><p>当频繁访问 web 网页的时候，每次都要进行 TCP/IP 通信，tcp/ip 通信三次握手四次断开，代价是很昂贵的，增加了通信量的开销，为解决上述 TCP 连接的问题，HTTP 就诞生了持久连接的方法。特点是只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</p><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226141328882-90680114.png" alt="img"></p><p>持久化连接减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早的结束，这样 web 页面的显示速度也就相应的提高了。</p><h3 id="5、使用-cookie-的状态管理"><a href="#5、使用-cookie-的状态管理" class="headerlink" title="5、使用 cookie 的状态管理"></a>5、使用 cookie 的状态管理</h3><p>cookie 技术通过在请求和相应报文中写入 cookie 信息来控制客户端的状态。cookie 会根据从服务端发送的相应报文内的一个叫做 set-cookie 的首部字段信息，通知客户端保存 cookie。当下次客户端再往服务器发送请求的时候，客户端会自动在请求头加入 cookie 值后发送出去。下面带图分析下过程</p><ul><li>没有 cookie 状态下的请求</li></ul><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226142019148-996060572.png" alt="img"></p><ul><li>第二次以后（存有 cookie 信息状态）的请求</li></ul><p><img src="https://images2015.cnblogs.com/blog/938876/201612/938876-20161226142059726-1822981009.png" alt="img"></p><p>后续待更新！！！技术写起来没有代码写起来顺手，不过还是得写，坚持就是成功</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建（三）</title>
      <link href="/2022/03/05/hexo3/"/>
      <url>/2022/03/05/hexo3/</url>
      
        <content type="html"><![CDATA[<h2 id="网站SEO优化"><a href="#网站SEO优化" class="headerlink" title="网站SEO优化"></a>网站SEO优化</h2><p>网站推广是一个比较烦人的事情，特别是对于专心搞技术的来说，可能就不是很擅长，那么怎么才能让别人知道我们网站呢？也就是说我们需要想办法让别人通过搜索就可以搜索到博客的内容，给我们带来自然流量，这就需要<code>seo</code>优化,让我们的站点变得对搜索引擎友好</p><p><code>SEO</code>是由英文<code>Search Engine Optimization</code>缩写而来， 中文意译为“搜索引擎优化”。<code>SEO</code>是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。</p><h3 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h3><p>首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入<code>site:&lt;域名&gt;</code>查看站点是否被百度收录</p><h4 id="验证网站所有权"><a href="#验证网站所有权" class="headerlink" title="验证网站所有权"></a>验证网站所有权</h4><p>登录百度站长搜索资源平台：<a href="http://zhanzhang.baidu.com/">http://zhanzhang.baidu.com</a>， 只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击<a href="http://zhanzhang.baidu.com/site/siteadd">添加网站</a>然后输入你的站点地址。</p><p>注意，这里需要输入我们自己购买的域名,不能使用<code>xxx.github.io</code>之类域名.因为<code>github</code>是不允许百度的<code>spider</code>（蜘蛛）爬取<code>github</code>上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名</p><p>在填完网址选择完网站的类型之后需要验证网站的所有权，验证网站所有权的方式有三种：</p><ul><li>文件验证</li><li><code>html</code>标签验证</li><li><code>CNAME</code>解析验证</li></ul><p>其实使用哪一种方式都可以，都是比较简单的。</p><p>但是一定要注意，使用文件验证文件存放的位置需要放在<code>sourc</code>文件夹下，如果是<code>html</code>文件那么<code>hexo</code>就会将其编译，所以必须要在<code>html</code>头部加上的<code>layout:false</code>，这样就不会被<code>hexo</code>编译。（如果验证文件是<code>txt</code>格式的就不需要）</p><h4 id="生成网站地图"><a href="#生成网站地图" class="headerlink" title="生成网站地图"></a>生成网站地图</h4><p>我们需要使用<code>npm</code>自动生成网站的<code>sitemap</code>，然后将生成的<code>sitemap</code>提交到百度和其他搜索引擎</p><h4 id="安装sitemap插件"><a href="#安装sitemap插件" class="headerlink" title="安装sitemap插件"></a>安装sitemap插件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><h4 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h4><p>在根目录配置文件<code>.yml</code>中修改<code>url</code>为你的站点地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line"># url: https://shw2018.github.io/</span><br><span class="line">url: https://sunhwee.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>执行完<code>hexo g</code>命令之后就会在网站根目录生成<code>sitemap.xml</code>文件和<code>baidusitemap.xml文件</code>，可以通过：<a href="https://sunhwee.com/baidusitemap.xml">https://sunhwee.com/baidusitemap.xml</a>, 查看该文件是否生成，其中<code>sitemap.xml</code>文件是搜索引擎通用的文件，<code>baidusitemap.xml</code>是百度专用的<code>sitemap</code>文件。</p><h4 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h4><p>然后我们就可以将我们生成的<code>sitemap</code>文件提交给百度，还是在百度站长平台，找到链接提交，有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和<code>sitemap</code></p><p>从效率上来说：</p><p>主动推送&gt;自动推送&gt;sitemap</p><h3 id="优化url"><a href="#优化url" class="headerlink" title="优化url"></a>优化url</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seo`搜索引擎优化认为，网站的最佳结构是**用户从首页点击三次就可以到达任何一个页面**，但是我们使用`hexo`编译的站点打开文章的`url`是：`sitename/year/mounth/day/title`四层的结构，这样的`url`结构很不利于`seo`，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章`url</span><br></pre></td></tr></table></figure><p>方案一：</p><p>可以将<code>url</code>直接改成<code>sitename/title</code>的形式，并且<code>title</code>最好是用英文，在根目录的配置文件下修改<code>permalink</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://sunhwee.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>方案二：</p><p>使用插件优化<code>url</code></p><p>插件<code>hexo-abbrlink</code>实现了这个功能，它将原来的<code>URL</code>地址重新进行了进制转换和再编码。</p><p>安装<code>hexo-abbrlink</code>。</p><p><code>npm install hexo-abbrlink --save</code></p><p>配置博客根目录下的_config.yml文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># permalink: :title/</span><br><span class="line">permalink: archives/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure><p>运行<code>hexo clean</code>和<code>hexo g</code>命令来重新生成文件看看，可以清楚的看到，<code>URL</code>结构成功变为了3层。</p><h3 id="其他seo优化"><a href="#其他seo优化" class="headerlink" title="其他seo优化"></a>其他seo优化</h3><p><code>seo</code>优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，<code>seo</code>优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上<code>keyword</code>和描述</p><p>在代码中，我们应该写出能让浏览器识别的语义化<code>HTML</code>，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置<code>nofollow</code>标签，避免<code>spider</code>爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为<code>spider</code>会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样<code>spider</code>是很有可能爬到我们中的站点的，so….</p><ul><li>网站<strong>外链</strong>的推广度、数量和质量</li><li>网站的<strong>内链</strong>足够强大</li><li>网站的<strong>原创</strong>质量</li><li>网站的<strong>年龄</strong>时间</li><li>网站的<strong>更新频率</strong>（更新次数越多越好）</li><li>网站的<strong>服务器</strong></li><li>网站的<strong>流量</strong>：流量越高网站的权重越高</li><li>网站的<strong>关键词排名</strong>：关键词排名越靠前，网站的权重越高</li><li>网站的<strong>收录</strong>数量：网站百度收录数量越多，网站百度权重越高</li><li>网站的浏览量及深度：<strong>用户体验</strong>越好，网站的百度权重越高</li></ul><h3 id="优化图片加载"><a href="#优化图片加载" class="headerlink" title="优化图片加载"></a>优化图片加载</h3><p><code>issue</code>问题：<br>优化网站加载逻辑问题：图片最后加载，加入图片懒加载方法</p><p>hexo-lazyload-image的作用原理是讲你博客里面img标签的src属性替换为一个loading image，把真实的图片地址放在data-origin属性下面。然后当你的网页翻到那张图片时（也就是图片在窗口中完全可见时），他会有一段js用data-origin的内容替换src，打到懒加载的目的。</p><p>一般情况下懒加载和gallery插件会发生冲突，比如按照我上面所说，最终结果就会变成，可能只有第一张图片在gallery中打开是原图，右翻左翻都会是那张loading image，需要你掌握js，可以修改matery.js里面的内容，甚至可能换一个gallery，比如photosiwpe之类的</p><p>解决方法：修改<code>/themes/matery/source/js</code>中的<code>matery.js</code>文件</p><p>第103行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#articleContent, #myGallery&#x27;).lightGallery(&#123;</span><br><span class="line">    selector: &#x27;.img-item&#x27;,</span><br><span class="line">    // 启用字幕</span><br><span class="line">    subHtmlSelectorRelative: true,</span><br><span class="line">    showThumbByDefault: false   //这句加上</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后面加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).find(&#x27;img[data-original]&#x27;).each(function()&#123;</span><br><span class="line">    $(this).parent().attr(&quot;href&quot;, $(this).attr(&quot;data-original&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再装个插件，<a href="https://github.com/Troy-Yang/hexo-lazyload-image">https://github.com/Troy-Yang/hexo-lazyload-image</a><br>在博客根目录配置.yml文件加入对应字段，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># lazyload configuration  2019.08.23</span><br><span class="line">lazyload:</span><br><span class="line">  enable: true </span><br><span class="line">  onlypost: false</span><br><span class="line">  loadingImg:     # eg ./images/loading.gif</span><br></pre></td></tr></table></figure><p>好了，这样实现了博客网站的图片懒加载。</p><h3 id="Gulp实现代码压缩"><a href="#Gulp实现代码压缩" class="headerlink" title="Gulp实现代码压缩"></a>Gulp实现代码压缩</h3><p><code>Gulp</code>实现代码压缩，以提升网页加载速度。</p><p>首先我们需要安装Gulp插件和5个功能模块，依次运行下面的两条命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp -g  #安装gulp</span><br><span class="line"># 安装功能模块</span><br><span class="line">npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save</span><br><span class="line"># 额外的功能模块</span><br><span class="line">npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del --save</span><br></pre></td></tr></table></figure><p>接下来在博客的根目录下新建gulpfile.js文件，并复制下面的内容到文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&quot;gulp&quot;);</span><br><span class="line">var debug = require(&quot;gulp-debug&quot;);</span><br><span class="line">var cleancss = require(&quot;gulp-clean-css&quot;); //css压缩组件</span><br><span class="line">var uglify = require(&quot;gulp-uglify&quot;); //js压缩组件</span><br><span class="line">var htmlmin = require(&quot;gulp-htmlmin&quot;); //html压缩组件</span><br><span class="line">var htmlclean = require(&quot;gulp-htmlclean&quot;); //html清理组件</span><br><span class="line">var imagemin = require(&quot;gulp-imagemin&quot;); //图片压缩组件</span><br><span class="line">var changed = require(&quot;gulp-changed&quot;); //文件更改校验组件</span><br><span class="line">var gulpif = require(&quot;gulp-if&quot;); //任务 帮助调用组件</span><br><span class="line">var plumber = require(&quot;gulp-plumber&quot;); //容错组件（发生错误不跳出任务，并报出错误内容）</span><br><span class="line">var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)</span><br><span class="line">var isDebug = true; //是否调试显示 编译通过的文件</span><br><span class="line">var gulpBabel = require(&quot;gulp-babel&quot;);</span><br><span class="line">var es2015Preset = require(&quot;babel-preset-es2015&quot;);</span><br><span class="line">var del = require(&quot;del&quot;);</span><br><span class="line">var Hexo = require(&quot;hexo&quot;);</span><br><span class="line">var hexo = new Hexo(process.cwd(), &#123;&#125;); // 初始化一个hexo对象</span><br><span class="line"></span><br><span class="line">// 清除public文件夹</span><br><span class="line">gulp.task(&quot;clean&quot;, function() &#123;</span><br><span class="line">  return del([&quot;public/**/*&quot;]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return</span><br><span class="line">// 创建静态页面 （等同 hexo generate）</span><br><span class="line">gulp.task(&quot;generate&quot;, function() &#123;</span><br><span class="line">  return hexo.init().then(function() &#123;</span><br><span class="line">    return hexo</span><br><span class="line">      .call(&quot;generate&quot;, &#123;</span><br><span class="line">        watch: false</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(function() &#123;</span><br><span class="line">        return hexo.exit();</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(function(err) &#123;</span><br><span class="line">        return hexo.exit(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 启动Hexo服务器</span><br><span class="line">gulp.task(&quot;server&quot;, function() &#123;</span><br><span class="line">  return hexo</span><br><span class="line">    .init()</span><br><span class="line">    .then(function() &#123;</span><br><span class="line">      return hexo.call(&quot;server&quot;, &#123;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(err) &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 部署到服务器</span><br><span class="line">gulp.task(&quot;deploy&quot;, function() &#123;</span><br><span class="line">  return hexo.init().then(function() &#123;</span><br><span class="line">    return hexo</span><br><span class="line">      .call(&quot;deploy&quot;, &#123;</span><br><span class="line">        watch: false</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(function() &#123;</span><br><span class="line">        return hexo.exit();</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(function(err) &#123;</span><br><span class="line">        return hexo.exit(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩public目录下的js文件</span><br><span class="line">gulp.task(&quot;compressJs&quot;, function() &#123;</span><br><span class="line">  return gulp</span><br><span class="line">    .src([&quot;./public/**/*.js&quot;, &quot;!./public/libs/**&quot;]) //排除的js</span><br><span class="line">    .pipe(gulpif(!isScriptAll, changed(&quot;./public&quot;)))</span><br><span class="line">    .pipe(gulpif(isDebug, debug(&#123; title: &quot;Compress JS:&quot; &#125;)))</span><br><span class="line">    .pipe(plumber())</span><br><span class="line">    .pipe(</span><br><span class="line">      gulpBabel(&#123;</span><br><span class="line">        presets: [es2015Preset] // es5检查机制</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩</span><br><span class="line">    .pipe(gulp.dest(&quot;./public&quot;)); //输出到目标目录</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩public目录下的css文件</span><br><span class="line">gulp.task(&quot;compressCss&quot;, function() &#123;</span><br><span class="line">  var option = &#123;</span><br><span class="line">    rebase: false,</span><br><span class="line">    //advanced: true,               //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]</span><br><span class="line">    compatibility: &quot;ie7&quot; //保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]</span><br><span class="line">    //keepBreaks: true,             //类型：Boolean 默认：false [是否保留换行]</span><br><span class="line">    //keepSpecialComments: &#x27;*&#x27;      //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀</span><br><span class="line">  &#125;;</span><br><span class="line">  return gulp</span><br><span class="line">    .src([&quot;./public/**/*.css&quot;, &quot;!./public/**/*.min.css&quot;]) //排除的css</span><br><span class="line">    .pipe(gulpif(!isScriptAll, changed(&quot;./public&quot;)))</span><br><span class="line">    .pipe(gulpif(isDebug, debug(&#123; title: &quot;Compress CSS:&quot; &#125;)))</span><br><span class="line">    .pipe(plumber())</span><br><span class="line">    .pipe(cleancss(option))</span><br><span class="line">    .pipe(gulp.dest(&quot;./public&quot;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩public目录下的html文件</span><br><span class="line">gulp.task(&quot;compressHtml&quot;, function() &#123;</span><br><span class="line">  var cleanOptions = &#123;</span><br><span class="line">    protect: /&lt;\!--%fooTemplate\b.*?%--&gt;/g, //忽略处理</span><br><span class="line">    unprotect: /&lt;script [^&gt;]*\btype=&quot;text\/x-handlebars-template&quot;[\s\S]+?&lt;\/script&gt;/gi //特殊处理</span><br><span class="line">  &#125;;</span><br><span class="line">  var minOption = &#123;</span><br><span class="line">    collapseWhitespace: true, //压缩HTML</span><br><span class="line">    collapseBooleanAttributes: true, //省略布尔属性的值  &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">    removeEmptyAttributes: true, //删除所有空格作属性值    &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">    removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot;</span><br><span class="line">    removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;</span><br><span class="line">    removeComments: true, //清除HTML注释</span><br><span class="line">    minifyJS: true, //压缩页面JS</span><br><span class="line">    minifyCSS: true, //压缩页面CSS</span><br><span class="line">    minifyURLs: true //替换页面URL</span><br><span class="line">  &#125;;</span><br><span class="line">  return gulp</span><br><span class="line">    .src(&quot;./public/**/*.html&quot;)</span><br><span class="line">    .pipe(gulpif(isDebug, debug(&#123; title: &quot;Compress HTML:&quot; &#125;)))</span><br><span class="line">    .pipe(plumber())</span><br><span class="line">    .pipe(htmlclean(cleanOptions))</span><br><span class="line">    .pipe(htmlmin(minOption))</span><br><span class="line">    .pipe(gulp.dest(&quot;./public&quot;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩 public/uploads 目录内图片</span><br><span class="line">gulp.task(&quot;compressImage&quot;, function() &#123;</span><br><span class="line">  var option = &#123;</span><br><span class="line">    optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span><br><span class="line">    progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span><br><span class="line">    interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br><span class="line">    multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化</span><br><span class="line">  &#125;;</span><br><span class="line">  return gulp</span><br><span class="line">    .src(&quot;./public/medias/**/*.*&quot;)</span><br><span class="line">    .pipe(gulpif(!isScriptAll, changed(&quot;./public/medias&quot;)))</span><br><span class="line">    .pipe(gulpif(isDebug, debug(&#123; title: &quot;Compress Images:&quot; &#125;)))</span><br><span class="line">    .pipe(plumber())</span><br><span class="line">    .pipe(imagemin(option))</span><br><span class="line">    .pipe(gulp.dest(&quot;./public&quot;));</span><br><span class="line">&#125;);</span><br><span class="line">// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器</span><br><span class="line">gulp.task(</span><br><span class="line">  &quot;build&quot;,</span><br><span class="line">  gulp.series(</span><br><span class="line">    &quot;clean&quot;,</span><br><span class="line">    &quot;generate&quot;,</span><br><span class="line">    &quot;compressHtml&quot;,</span><br><span class="line">    &quot;compressCss&quot;,</span><br><span class="line">    &quot;compressJs&quot;,</span><br><span class="line">    &quot;compressImage&quot;,</span><br><span class="line">    gulp.parallel(&quot;deploy&quot;)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 默认任务</span><br><span class="line">gulp.task(</span><br><span class="line">  &quot;default&quot;,</span><br><span class="line">  gulp.series(</span><br><span class="line">    &quot;clean&quot;,</span><br><span class="line">    &quot;generate&quot;,</span><br><span class="line">    gulp.parallel(&quot;compressHtml&quot;, &quot;compressCss&quot;, &quot;compressImage&quot;, &quot;compressJs&quot;)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line">//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数</span><br></pre></td></tr></table></figure><p>最后 <code>hexo clean</code> &amp;&amp; <code>hexo g</code> &amp;&amp; <code>gulp</code> &amp;&amp; <code>hexo d</code> 就可以了。</p><p>注意，很可能会运行到第三步，也就是运行<code>gulp</code>压缩命令时会报错：</p><p>那是因为gulp安装的本地版本和hexo自带的版本不对应导致，第三步gulp压缩可以用下面命令强制使用本地版本：</p><p><code>node ./node_modules/gulp/bin/gulp.js</code></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引详解</title>
      <link href="/2022/03/04/article13/"/>
      <url>/2022/03/04/article13/</url>
      
        <content type="html"><![CDATA[<p>1、什么是索引？</p><p>索引是帮助 MySQL 高效获取数据的数据结构（有序）。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>索引本身也很大，一般以索引文件的形式存在磁盘上。</p><p>2、说一下索引有哪些优势有哪些劣势？</p><p>优势：</p><p>1、提高数据的查询效率，降低了数据库的 IO 成本；</p><p>2、通过索引列对数据进行排序，可以大大降低排序的成本，即降低了 CPU 的消耗。</p><p>劣势：</p><p>1、实际上索引也是一张表，该表中保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占用空间的；</p><p>2、虽然索引大大提高了查询效率，但同时也降低了更新表的速度，如对表进行 insert，update，delete。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件。每次更新或添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p><p>3、介绍一下索引的数据结构？</p><p>索引是在 MySQL 的引擎层中实现的，所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。</p><p>MySQL 目前提供了以下四种结构的索引：</p><p>1、BTREE 索引：最常见的索引类型，大部分索引都支持 B 树索引。</p><p>2、HASH 索引（了解）：只有 Memory 引擎支持，适用场景简单。</p><p>3、R-TREE 索引（了解）：即空间索引，是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型。</p><p>4、Full-text 索引（了解）：即全文索引，也是 MyISAM 引擎的一个特殊索引类型，主要用于全文检索，InnoDB 从 MySQL5.6 开始支持全文检索。</p><p>我们平常所说的索引，如果没有特别指明，都指的是 B+树索引。其中 InnoDB 引擎，默认使用的就是 B+树结构的索引。</p><p>4、BTREE 索引的检索原理</p><p>初始化简介：</p><p>一颗 B+树，浅蓝色的块我们称之为一个磁盘块，每个磁盘块包含几个数据项（深蓝色）和指针（黄色）；</p><p>如：磁盘块 1 包含数据项 17 和 35，包含指针 P1，P2，P3；</p><p>P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块；</p><p>真实的数据只存在于叶子节点，即：3、5、9、10、13、15、28、29、36、60、75、79、90、99；</p><p>非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如：17、35 并不真实存在于数据表中。</p><p>查找过程：</p><p>如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针；</p><p>通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指针；</p><p>通过磁盘块 3 的 P2 指针的磁盘地址把磁盘块 8 由磁盘加载到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，共计 3 次 IO。</p><p>总结：</p><p>真实的情况是，3 层的 B+树可以表示上百万的数据，如果上百万的数据查找只需要 3 次 IO，性能提高将是巨大的；</p><p>如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，成本非常高。</p><p>5、索引分为哪些类型？</p><p>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。</p><p>唯一索引：索引列的值必须唯一，但允许有空值。</p><p>复合索引：即一个索引包含多个列。</p><p>6、索引的基本语法？</p><p>1、创建索引：</p><p>方式 1：</p><p>create [UNIQUE] index 索引名 on 表名(字段名…)；</p><p>示例：create [UNIQUE] index idx_city_name on city(city_name);</p><p>方式 2：</p><p>alter table 表名 add index 索引名(字段名…)</p><p>示例：alter table city add index idx_city_name(city_name);</p><p>2、查看索引：</p><p>show index from 表名；</p><p>示例：show index from city；</p><p>3、删除索引：</p><p>drop index 索引名 on 表名；</p><p>示例：drop index idx_city_name on city；</p><p>7、哪些情况需要创建索引？</p><p>1、主键自动建立唯一索引</p><p>2、频繁作为查询条件的字段应创建索引</p><p>3、查询中与其它表关联的字段，外键关系建立索引</p><p>4、查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</p><p>5、查询中统计或分组字段</p><p>8、哪些情况不需要创建索引？</p><p>1、数据量太少</p><p>2、经常做增删改频繁操作的的字段</p><p>3、数据重复且分布平均的表字段</p><p>解释：假如一个表有 10 万记录，有一个字段只有 true 和 false 两种值，且每个值的分布概率大约为 50%，那么这个对该字段建索引不会提高查询效率；</p><p>索引的选择性：索引列中不同的值的数目/表记录数</p><p>如果一个表中有 2000 条数据，索引列有 1980 个不同的值，那么这个索引的选择性就是 1980/2000=0.99，选择性越接近 1，索引的效率越高。</p><p>4、where 条件里用不到的字段</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建（二）</title>
      <link href="/2022/03/03/hexo2/"/>
      <url>/2022/03/03/hexo2/</url>
      
        <content type="html"><![CDATA[<h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>我们要定制自己的博客的话，首先就要来了解一下<code>Hexo</code>博客的一些目录和文件的作用，以及如何平滑更换漂亮的主题模板并加入自己的定制源代码实现个性化定制</p><h3 id="博客目录构成介绍"><a href="#博客目录构成介绍" class="headerlink" title="博客目录构成介绍"></a>博客目录构成介绍</h3><p>博客的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- node_modules</span><br><span class="line">- public</span><br><span class="line">- scaffolds</span><br><span class="line">- source</span><br><span class="line">    - _data</span><br><span class="line">    - _posts</span><br><span class="line">    - about</span><br><span class="line">    - archives</span><br><span class="line">    - categories</span><br><span class="line">    - friends</span><br><span class="line">    - tags</span><br><span class="line">- themes</span><br></pre></td></tr></table></figure><p><code>node_modules</code>是<code>node.js</code>各种库的目录，<code>public</code>是生成的网页文件目录，<code>scaffolds</code>里面就三个文件，存储着新文章和新页面的初始设置，<code>source</code>是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，<code>themes</code>存放着主题文件，一般也用不到。</p><p>平时写文章只需要关注<code>source/_posts</code>这个文件夹就行了。</p><h3 id="hexo基本配置"><a href="#hexo基本配置" class="headerlink" title="hexo基本配置"></a>hexo基本配置</h3><p>在文件根目录下的<code>_config.yml</code>，就是整个<code>hexo</code>框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。</p><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><p>参数描述<code>title</code>网站标题<code>subtitle</code>网站副标题<code>description</code>网站描述<code>author</code>您的名字<code>language</code>网站使用的语言<code>timezone</code>网站时区。<code>Hexo</code> 默认使用您电脑的时区。时区列表。比如说：<code>America/New_York, Japan</code>, 和 <code>UTC</code> 。</p><p>其中，<code>description</code>主要用于<code>SEO</code>，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><p>参数描述<code>url</code>网址<code>root</code>网站根目录 <code>permalink</code>文章的<a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a>格式<code>permalink_defaults</code>永久链接中各部分的默认值</p><p>在这里，你需要把<code>url</code>改成你的<strong>网站域名</strong>。</p><p><code>permalink</code>，也就是你生成某个文章时的那个链接格式。</p><p>比如我新建一个文章叫<code>temp.md</code>，那么这个时候他自动生成的地址就是<code>http://yoursite.com/2018/09/05/temp</code>。</p><p>以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 。</p><p><code>参数结果:year/:month/:day/:title/2019/08/10/hello-world :year-:month-:day-:title.html 2019-08-10-hello-world.html :category/:titlefoo/bar/hello-world</code></p><p>再往下翻，中间这些都默认就好了。</p><p><code>theme: landscap</code></p><p><code>theme</code>就是选择什么主题，也就是在<code>themes</code>这个文件夹下，在官网上有很多个主题，默认给你安装的是<code>lanscape</code>这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在<code>themes</code>文件夹下，再修改这个主题参数就可以了。</p><h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p><code>Front-matter</code> 是<code>md</code>文件最上方以 <code>---</code>分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo+Github博客搭建记录</span><br><span class="line">date: 2019-08-10 21:44:44</span><br></pre></td></tr></table></figure><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><p>参数描述<code>layout</code>布局<code>title</code>标题<code>date</code>建立日期<code>updated</code>更新日期<code>comments</code>开启文章的评论功能<code>tags</code>标签（不适用于分页）<code>categories</code>分类（不适用于分页）<code>permalink</code>覆盖文章网址</p><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说<code>Foo</code>，<code>Bar</code>不等于<code>Bar</code>，<code>Foo</code>；而标签没有顺序和层次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo博客搭建</span><br><span class="line">date: 2022-03-05 21:44:44</span><br><span class="line">author: 中元</span><br><span class="line">img: /banner/7.jpg</span><br><span class="line">coverImg: /banner/7.jpg</span><br><span class="line">top: true</span><br><span class="line">cover: true</span><br><span class="line">toc: true</span><br><span class="line">password: </span><br><span class="line">mathjax: true</span><br><span class="line">summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Github</span><br><span class="line">- 博客</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a>layout（布局）</h4><p>当你每一次使用代码</p><p><code>hexo new XXX</code></p><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p><code>Hexo</code>有三种默认布局：<code>post</code>、<code>page</code>和<code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和<code>post</code>相同，都将储存到<code>source/_posts</code>文件夹。</p><p>而new这个命令其实是：</p><p><code>hexo new [layout] &lt;title&gt;</code></p><p>只不过这个<code>layout</code>默认是<code>post</code>罢了。</p><p>如果你想另起一页，那么可以使用</p><p><code>hexo new page newpage</code></p><p>系统会自动给你在<code>source</code>文件夹下创建一个<code>newpage</code>文件夹，以及<code>newpage</code>文件夹中的<code>index.md</code>，这样你访问的<code>newpage</code>对应的链接就是<a href="http://xxx.xxx/newpage">http://xxx.xxx/newpage</a></p><p><code>draft</code>是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><p><code>hexo new draft newdraft</code></p><p>这样会在<code>source/_draft</code>中新建一个<code>newdraft.md</code>文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><p><code>hexo server --draft</code></p><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到<code>post</code>中，</p><p><code>hexo publish draft newdraft</code></p><p>就会自动把<code>newdraft.md</code>发送到<code>post</code>中。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>我们在了解<code>Hexo</code>博客文件基础之后，知道主题文件就放在<code>themes</code>文件下，那么我们就可以去Hexo官网下载喜欢的主题，复制进去然后修改参数即可。<br>网上大多数主题都是github排名第一的<code>Next</code>主题，但是我个人不是很喜欢，我在网上看到一个主题感觉还不错：<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>，地址在<a href="https://github.com/blinkfox/hexo-theme-matery">传送门</a>。这个主题看着比较漂亮，并且响应式比较友好，点起来很舒服，功能也比较很多。</p><p>当然，人各有异，这个主题风格也不一定是你喜欢，那么你也可以跟着这教程类似的方法替换成你喜欢的就行了。</p><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><p>他的介绍文档写得非常的详细，还有中英文两个版本。</p><p>首先先按照文档教程安装一遍主题，然后是可以正常打开的，如果你是一般使用的话，基本没啥问题了。不过有些地方有些地方可以根据你自己的习惯和喜好修改一下， 下面记录一下我这个博客修改了的一些地方。</p><p>首先为了新建文章方便，我们可以修改一下文章模板，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">author: </span><br><span class="line">img: </span><br><span class="line">coverImg: </span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">toc: true</span><br><span class="line">mathjax: false</span><br><span class="line">password:</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，修改对应信息就可以了。</p><p>原来的主题没有<code>404</code>页面，我们加一个。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 404</span><br><span class="line">date: 2019-08-5 16:41:10</span><br><span class="line">type: &quot;404&quot;</span><br><span class="line">layout: &quot;404&quot;</span><br><span class="line">description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;</span><br></pre></td></tr></table></figure><p>然后在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    /* don&#x27;t remove. */</span><br><span class="line">    .about-cover &#123;</span><br><span class="line">        height: 75vh;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;brand&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;title center-align&quot;&gt;</span><br><span class="line">                        404</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;description center-align&quot;&gt;</span><br><span class="line">                        &lt;%= page.description %&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 每天切换 banner 图.  Switch banner image every day.</span><br><span class="line">    $(&#x27;.bg-cover&#x27;).css(&#x27;background-image&#x27;, &#x27;url(/medias/banner/&#x27; + new Date().getDay() + &#x27;.jpg)&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>修改<code>/themes/matery/layout/_partial</code>中的<code>footer.ejs</code>，在最后加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=javascript&gt;</span><br><span class="line">    function siteTime() &#123;</span><br><span class="line">        window.setTimeout(&quot;siteTime()&quot;, 1000);</span><br><span class="line">        var seconds = 1000;</span><br><span class="line">        var minutes = seconds * 60;</span><br><span class="line">        var hours = minutes * 60;</span><br><span class="line">        var days = hours * 24;</span><br><span class="line">        var years = days * 365;</span><br><span class="line">        var today = new Date();</span><br><span class="line">        var todayYear = today.getFullYear();</span><br><span class="line">        var todayMonth = today.getMonth() + 1;</span><br><span class="line">        var todayDate = today.getDate();</span><br><span class="line">        var todayHour = today.getHours();</span><br><span class="line">        var todayMinute = today.getMinutes();</span><br><span class="line">        var todaySecond = today.getSeconds();</span><br><span class="line">        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span><br><span class="line">        year - 作为date对象的年份，为4位年份值</span><br><span class="line">        month - 0-11之间的整数，做为date对象的月份</span><br><span class="line">        day - 1-31之间的整数，做为date对象的天数</span><br><span class="line">        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span><br><span class="line">        minutes - 0-59之间的整数，做为date对象的分钟数</span><br><span class="line">        seconds - 0-59之间的整数，做为date对象的秒数</span><br><span class="line">        microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span><br><span class="line">        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00</span><br><span class="line">        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);</span><br><span class="line">        var diff = t2 - t1;</span><br><span class="line">        var diffYears = Math.floor(diff / years);</span><br><span class="line">        var diffDays = Math.floor((diff / days) - diffYears * 365);</span><br><span class="line">        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);</span><br><span class="line">        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);</span><br><span class="line">        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);</span><br><span class="line">        document.getElementById(&quot;sitetime&quot;).innerHTML = &quot;本站已运行 &quot; +diffYears+&quot; 年 &quot;+diffDays + &quot; 天 &quot; + diffHours + &quot; 小时 &quot; + diffMinutes + &quot; 分钟 &quot; + diffSeconds + &quot; 秒&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    siteTime();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后在合适的地方（比如<code>copyright</code>声明后面）加上下面的代码就行了：</p><p><code>&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;</code></p><h4 id="修改不蒜子初始化计数"><a href="#修改不蒜子初始化计数" class="headerlink" title="修改不蒜子初始化计数"></a>修改不蒜子初始化计数</h4><p>因为不蒜子至今未开放注册，所以没办法在官网修改初始化，只能自己动手了。和上一条一样，我们在<code>/themes/matery/layout/_partial</code>里的<code>footer.ejs</code>文件最后加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(document).ready(function () &#123;</span><br><span class="line"></span><br><span class="line">        var int = setInterval(fixCount, 50);  // 50ms周期检测函数</span><br><span class="line">        var pvcountOffset = 80000;  // 初始化首次数据</span><br><span class="line">        var uvcountOffset = 20000;</span><br><span class="line"></span><br><span class="line">        function fixCount() &#123;</span><br><span class="line">            if (document.getElementById(&quot;busuanzi_container_site_pv&quot;).style.display != &quot;none&quot;) &#123;</span><br><span class="line">                $(&quot;#busuanzi_value_site_pv&quot;).html(parseInt($(&quot;#busuanzi_value_site_pv&quot;).html()) + pvcountOffset);</span><br><span class="line">                clearInterval(int);</span><br><span class="line">            &#125;</span><br><span class="line">            if ($(&quot;#busuanzi_container_site_pv&quot;).css(&quot;display&quot;) != &quot;none&quot;) &#123;</span><br><span class="line">                $(&quot;#busuanzi_value_site_uv&quot;).html(parseInt($(&quot;#busuanzi_value_site_uv&quot;).html()) + uvcountOffset); // 加上初始数据 </span><br><span class="line">                clearInterval(int); // 停止检测</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后把上面几行有段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanziStatistics &amp;&amp; theme.busuanziStatistics.totalTraffic) &#123; %&gt;</span><br><span class="line">    &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-heart-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">        本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot; class=&quot;white-color&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;% if (theme.busuanziStatistics &amp;&amp; theme.busuanziStatistics.totalNumberOfvisitors) &#123; %&gt;</span><br><span class="line">    &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">        人次,&amp;nbsp;访客数 &lt;span id=&quot;busuanzi_value_site_uv&quot; class=&quot;white-color&quot;&gt;&lt;/span&gt; 人.</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanziStatistics &amp;&amp; theme.busuanziStatistics.totalTraffic) &#123; %&gt;</span><br><span class="line">    &lt;span id=&quot;busuanzi_container_site_pv&quot; style=&#x27;display:none&#x27;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-heart-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">        本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot; class=&quot;white-color&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;% if (theme.busuanziStatistics &amp;&amp; theme.busuanziStatistics.totalNumberOfvisitors) &#123; %&gt;</span><br><span class="line">    &lt;span id=&quot;busuanzi_container_site_uv&quot; style=&#x27;display:none&#x27;&gt;</span><br><span class="line">        人次,&amp;nbsp;访客数 &lt;span id=&quot;busuanzi_value_site_uv&quot; class=&quot;white-color&quot;&gt;&lt;/span&gt; 人.</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>其实就是增加了两个<code>style=&#39;display:none&#39;</code>而已。</p><h4 id="添加动漫人物"><a href="#添加动漫人物" class="headerlink" title="添加动漫人物"></a>添加动漫人物</h4><p><code>npm install --save hexo-helper-live2d</code></p><p><code>npm install live2d-widget-model-wanko</code></p><p>这里的动漫模型可以改，只需要下载对应模型就行了，你可以官方仓库去看有哪些模型，下载你喜欢的就行。</p><p>在根目录配置文件中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">    enable: true</span><br><span class="line">    scriptFrom: local</span><br><span class="line">    pluginRootPath: live2dw/</span><br><span class="line">    pluginJsPath: lib/</span><br><span class="line">    pluginModelPath: assets/</span><br><span class="line">    tagMode: false</span><br><span class="line">    log: false</span><br><span class="line">    model:</span><br><span class="line">        use: live2d-widget-model-shizuku</span><br><span class="line">    display:</span><br><span class="line">        position: right</span><br><span class="line">        width: 150</span><br><span class="line">        height: 300</span><br><span class="line">    mobile:</span><br><span class="line">        show: false</span><br><span class="line">    react:</span><br><span class="line">        opacity: 0.7</span><br></pre></td></tr></table></figure><p>然后<code>hexo g</code>再<code>hexo s</code>就能预览出效果了，但是有个注意的地方，<strong>这个动漫人物最好不要和不蒜子同时使用</strong>，不然不蒜子会显示不出来。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建</title>
      <link href="/2022/03/01/hexo1/"/>
      <url>/2022/03/01/hexo1/</url>
      
        <content type="html"><![CDATA[<h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><p>这篇文章篇幅较长，主要针对新手，每一步很详细，所以可能会显得比较啰嗦，建议基础比较好小伙伴根据右侧目录选择自己感兴趣的部分跳着看</p><h2 id="博客开源"><a href="#博客开源" class="headerlink" title="博客开源"></a>博客开源</h2><p>本博客基于<code>Hexo</code>框架搭建，用到<a href="https://github.com/shw2018/hexo-theme-matery">hexo-theme-matery</a>主题,并在此基础之上做了很多修改，修复了一些bug，增加了一些新的特性和功能</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p><code>hexo</code>的初级搭建还有部署到<code>github page</code>上，以及个人域名的绑定。</p><h3 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h3><ol><li>安装<code>git</code></li><li>安装 <code>nodejs</code></li><li>安装<code>hexo</code></li><li><code>github</code>创建个人仓库</li><li>生成<code>ssh</code>添加到<code>github</code></li><li>设置个人域名</li><li>发布文章</li></ol><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>为了把本地的网页文件上传到<code>github</code>上面去，需要用到工具———<a href="https://git-scm.com/download">Git</a><code>Git</code>是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。<code>Git</code>非常强大，建议每个人都去了解一下。廖雪峰老师的<code>Git</code>教程写的非常好，大家可以看一下。<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a></p><p><strong>windows：</strong>到<code>git</code>官网上下载<code>.exe</code>文件,<a href="https://git-scm.com/download/win">Download git</a>,安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开<code>git</code>了。</p><p><strong>linux：</strong>对<code>linux</code>来说实在是太简单了，因为最早的<code>git</code>就是在<code>linux</code>上编写的，只需要一行代码</p><p><code>sudo apt-get install git</code></p><p>安装完成后在命令提示符中输入<code>git --version</code>来查看一下版本验证是否安装成功。</p><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p><strong>windows：</strong>下载稳定版或者最新版都可以<a href="http://nodejs.cn/download/">Node.js</a>，安装选项全部默认，一路点击<code>Next</code>。<br>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><p><strong>linux：</strong>命令行安装：</p><p><code>sudo apt-get install nodejs </code></p><p><code>sudo apt-get install npm</code></p><p>安装完后，检查是否安装成功，输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code></p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>初始化hexo</p><p><code>hexo init 项目名称</code></p><p>安装相关依赖</p><p><code>npm install</code></p><p>常用<code>hexo</code>相关指令</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">hexo init</td><td align="center">初始化</td></tr><tr><td align="center">hexo new</td><td align="center">新建文章</td></tr><tr><td align="center">hexo publish</td><td align="center">发表草稿</td></tr><tr><td align="center">hexo generate</td><td align="center">生成静态文件。可简写为 hexo g</td></tr><tr><td align="center">hexo server</td><td align="center">启动服务器。可简写为 hexo s</td></tr><tr><td align="center">hexo deploy</td><td align="center">部署网站。可简写为 hexo d</td></tr><tr><td align="center">hexo render</td><td align="center">渲染文件。</td></tr><tr><td align="center">hexo clean</td><td align="center">清除缓存文件和已生成的静态文件</td></tr></tbody></table><h4 id="创建github个人仓库"><a href="#创建github个人仓库" class="headerlink" title="创建github个人仓库"></a>创建<code>github</code>个人仓库</h4><p>新建一个项目仓库<code>New repository</code>，如下所示：</p><p>然后如下图所示，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，<code>README</code>初始化也要勾上。</p><p>要创建一个和你用户名相同的仓库，后面加.<a href="http://github.io/">http://github.io</a>，只有这样，将来要部署到<code>GitHub page</code>的时候，才会被识别</p><h4 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h4><p>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地。<br>右键打开<code>git bash</code>，然后输入下面命令：</p><p><code>git config --global user.name &quot;yourname&quot; </code></p><p><code>git config --global user.email &quot;youremail&quot;</code></p><p>这里的<code>yourname</code>输入你的<code>GitHub</code>用户名，<code>youremail</code>输入你<code>GitHub</code>的邮箱。这样<code>GitHub</code>才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><p><code>git config user.name </code></p><p><code>git config user.email</code></p><p>然后创建<code>SSH</code>,一路回车</p><p><code>ssh</code>，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>GitHub</code>上，这样当你链接<code>GitHub</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>GitHub</code>上。</p><p><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></p><p>这个时候它会告诉你已经生成了<code>.ssh</code>的文件夹。在你的电脑中找到这个文件夹。或者<code>git bash</code>中输入</p><p><code>cat ~/.ssh/id_rsa.pub</code></p><p>将输出的内容复制到框中，点击确定保存。</p><p>打开<a href="http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取一个都可以，把你的<code>id_rsa.pub</code>里面的信息复制进去。</p><p>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><h4 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h4><p>这一步，我们就可以将<code>hexo</code>和<code>GitHub</code>关联起来，也就是将<code>hexo</code>生成的文章部署到<code>GitHub</code>上，打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 你的项目地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><code>repository</code>修改为你自己的<code>github</code>项目地址即可，就是部署时，告诉工具，将生成网页通过<code>git</code>方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装<code>deploy-git</code> ，也就是部署的命令,这样你才能用命令部署到<code>GitHub</code>。</p><p><code>npm install hexo-deployer-git --save</code></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html完整语法学习</title>
      <link href="/2022/02/22/article12/"/>
      <url>/2022/02/22/article12/</url>
      
        <content type="html"><![CDATA[<h3 id="一个-html"><a href="#一个-html" class="headerlink" title="一个 html"></a>一个 html</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;!--meta  描述性标签，用来描述网站的一些信息--&gt;    &lt;!--meta 标签一般用来做SEO--&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;key&quot; content=&quot;第一个网站，学html&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;学习html&quot;&gt;    &lt;title&gt;第一个网站&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello,World!&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;基本标签学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--标题标签--&gt;&lt;h1&gt;一级标签&lt;/h1&gt;&lt;h2&gt;二级标签&lt;/h2&gt;&lt;h3&gt;三级标签&lt;/h3&gt;&lt;h4&gt;四级标签&lt;/h4&gt;&lt;h5&gt;五级标签&lt;/h5&gt;&lt;h6&gt;六级标签&lt;/h6&gt;&lt;!--段落标签  将文字分为一个个段落--&gt;&lt;p&gt;两只老虎，两只老虎&lt;/p&gt;&lt;P&gt;跑得快，跑得快&lt;/P&gt;&lt;P&gt;一只没有眼睛&lt;/P&gt;&lt;P&gt;一只没有尾巴&lt;/P&gt;&lt;P&gt;真奇怪！真奇怪！&lt;/P&gt;&lt;!--水平线标签--&gt;&lt;hr/&gt;&lt;!--换行标签  只是换了一行，但是还是一段--&gt;两只老虎，两只老虎&lt;br/&gt;跑得快，跑得快&lt;br/&gt;一只没有眼睛&lt;br/&gt;一只没有尾巴&lt;br/&gt;真奇怪！真奇怪&lt;br/&gt;&lt;!--粗体，斜体--&gt;&lt;h1&gt;字体样式标签&lt;/h1&gt;粗体：&lt;strong&gt;i love you&lt;/strong&gt;  &lt;br/&gt;斜体：&lt;em&gt;i love you&lt;/em&gt;  &lt;br/&gt;粗体：&lt;B&gt;i love you&lt;/B&gt;    &lt;br/&gt;斜体：&lt;I&gt;i love you&lt;/I&gt;    &lt;br/&gt;&lt;hr/&gt;&lt;!--特殊符号--&gt;空       格；  &lt;br/&gt;&lt;!--&amp;nbsp;代表一个空格--&gt;空&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;格    &lt;br/&gt;&lt;!--&amp;gt; 代表大于号  &amp;lt;代表小于号--&gt;&amp;gt;&amp;lt;    &lt;br/&gt;&lt;!--版权符号--&gt;&amp;copy;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图片标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--src:图片的地址绝对地址：使用盘符找到的文件   D:\代码\HTML\resources\image\2.png相对地址：相对于当前项目的文件  ../resources/image/2.png../返回上一级目录alt ： 如果src路径下的文件未找到，就用这里名的内容替代title  ： 将鼠标放置在这个图片上面会显示title里卖弄的内容width  : 图片显示的宽度height  ： 图片显示的高度--&gt;&lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;&lt;!--从这里可以直接跳转到下面这个链接的down这个锚标记处--&gt;&lt;a href=&quot;4.链接标签.html#down&quot;&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;链接标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--使用a标签里面的name属性设置锚链接标记--&gt;&lt;a name=&quot;top&quot;&gt;顶部&lt;/a&gt;&lt;br/&gt;&lt;!--a标签：href  ： 必填，表示要跳转到哪里去target  : 表示窗口在哪里打开            _blank  ： 在新标签中打开            _self   : 在自己的网页中打开，属于默认设置a标签中间填写链接的文本或图片--&gt;&lt;a href=&quot;1.我的第一个html.html&quot; target=&quot;_blank&quot;&gt;点击我跳转到页面一&lt;/a&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_self&quot;&gt;点击我跳转到百度&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;1.我的第一个html.html&quot;&gt;    &lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;&lt;/a&gt;&lt;p&gt;    &lt;a href=&quot;1.我的第一个html.html&quot;&gt;        &lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p&gt;    &lt;a href=&quot;1.我的第一个html.html&quot;&gt;        &lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p&gt;    &lt;a href=&quot;1.我的第一个html.html&quot;&gt;        &lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p&gt;    &lt;a href=&quot;1.我的第一个html.html&quot;&gt;        &lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p&gt;    &lt;a href=&quot;1.我的第一个html.html&quot;&gt;        &lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;p&gt;    &lt;a href=&quot;1.我的第一个html.html&quot;&gt;        &lt;img src=&quot;../resources/image/2.png&quot; alt=&quot;桌面壁纸&quot; title=&quot;悬停文字&quot; width=&quot;255&quot; height=&quot;255&quot;&gt;    &lt;/a&gt;&lt;/p&gt;&lt;!--锚链接 ：    1.需要一个锚标记    2.跳转到锚标记使用方法为 #+锚链接的标记名可以实现页面内的跳转，，也可从一个页面直接跳转到锚链接的标记位置--&gt;&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;&lt;a name=&quot;down&quot;&gt;down&lt;/a&gt;&lt;!--功能性链接：    mailto:邮箱地址（可以将内容发送到这个邮箱里面）  QQL链接--&gt;&lt;a href=&quot;mailto:1713791837@qq.com&quot;&gt;点击联系我&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=1713791837&amp;site=qq&amp;menu=yes&quot;&gt;    &lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2:1713791837:52&quot; alt=&quot;你好&quot; title=&quot;你好&quot;/&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--有序列表 ： Orderly list   显示出有顺序的结构，前边用数字显示顺序应用范围：试卷，答题卡...--&gt;&lt;ol&gt;    &lt;li&gt;Java&lt;/li&gt;    &lt;li&gt;Python&lt;/li&gt;    &lt;li&gt;汇编&lt;/li&gt;    &lt;li&gt;前端&lt;/li&gt;    &lt;li&gt;编译原理&lt;/li&gt;&lt;/ol&gt;&lt;!--无序列表   显示出没有顺序的结构，前边用黑点显示应用范围：导航，侧边栏...--&gt;&lt;ul&gt;    &lt;li&gt;Java&lt;/li&gt;    &lt;li&gt;Python&lt;/li&gt;    &lt;li&gt;汇编&lt;/li&gt;    &lt;li&gt;前端&lt;/li&gt;    &lt;li&gt;编译原理&lt;/li&gt;&lt;/ul&gt;&lt;!--自定义列表dl : 列表标签dt : 列表名称dd : 列表内容--&gt;&lt;dl&gt;    &lt;dt&gt;学科&lt;/dt&gt;    &lt;dd&gt;java&lt;/dd&gt;    &lt;dd&gt;linux&lt;/dd&gt;    &lt;dd&gt;spring&lt;/dd&gt;    &lt;dd&gt;c&lt;/dd&gt;    &lt;dt&gt;位置&lt;/dt&gt;    &lt;dd&gt;宁夏&lt;/dd&gt;    &lt;dd&gt;西安&lt;/dd&gt;    &lt;dd&gt;甘肃&lt;/dd&gt;&lt;/dl&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--表格 ： table行 ： tr列 ： tdcolspan  : 合并多少列为一列rowspan  : 合并多少行为一行border : 设置边框宽度--&gt;&lt;table border=&quot;1px&quot;&gt;    &lt;tr&gt;        &lt;td colspan=&quot;3&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;学生成绩&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td rowspan=&quot;2&quot;&gt;小破孩&lt;/td&gt;        &lt;td&gt;语文&lt;/td&gt;        &lt;td&gt;100&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;数学&lt;/td&gt;        &lt;td&gt;100&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td rowspan=&quot;2&quot;&gt;憨憨&lt;/td&gt;        &lt;td&gt;语文&lt;/td&gt;        &lt;td&gt;100&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;数学&lt;/td&gt;        &lt;td&gt;100&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="视频与音频"><a href="#视频与音频" class="headerlink" title="视频与音频"></a>视频与音频</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;媒体元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--视频和音频controls  :  控制条autoplay  :  设置视频自动播放--&gt;&lt;video src=&quot;../resources/video/2.qlv&quot; controls autoplay&gt;&lt;/video&gt;&lt;br/&gt;&lt;audio src=&quot;../resources/audio/ai.mp3&quot; controls&gt;&lt;/audio&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;页面结构&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;header&gt;        &lt;h1&gt;网页头部&lt;/h1&gt;    &lt;/header&gt;    &lt;section&gt;        &lt;h1&gt;网页主体&lt;/h1&gt;    &lt;/section&gt;    &lt;footer&gt;        &lt;h1&gt;网页脚部&lt;/h1&gt;    &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;内联框架&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--iframe : 可以将src里面的网页内容嵌套在本网页内src  : 链接地址w-h : 宽和高还可以使用name属性：        将a标签里面的链接内容放置到iframe里面--&gt;&lt;iframe src=&quot;&quot; name=&quot;hello&quot; width=&quot;855px&quot; height=&quot;512px&quot;&gt;&lt;/iframe&gt;&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;hello&quot;&gt;点击跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;```### form表单```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--表单formaction : 提交到哪个位置，可以是网站也可以是请求处理地址method : 提交方式，，有post与get        get方式提交，数据可以在url里面看到，不安全，但高效        post方式提交：比较安全，能够提交数据量较大的文件--&gt;&lt;h1&gt;注册&lt;/h1&gt;&lt;form action=&quot;1.我的第一个html.html&quot; method=&quot;get&quot;&gt;    &lt;!--文本输入框  ： type=&quot;text&quot;     value=&quot;你好帅&quot;   默认初始值     maxlength=&quot;8&quot;   最多能输入几个字符     size=&quot;30&quot;       文本框的长度     readonly  只读     placeholder  提示的默认信息 只能用在输入框上     required  非空判断，表示此字段必须填写  只能用在输入框上    --&gt;    &lt;p&gt;名字：&lt;input type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;请输入用户名&quot; required&gt; &lt;/p&gt;    &lt;!--密码框 ： type=&quot;password&quot;     hidden 隐藏，将这个框用户看不到，但是却是存在的，可以放置默认值     --&gt;    &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; hidden value=&quot;123456&quot;&gt; &lt;/p&gt;    &lt;p&gt;性别：        &lt;!--单选框:        type=&quot;radio&quot;        value:单选框的值        name : 表示组，name值一样则表示为一组数据，不能同时选择两个        disabled : 禁用，禁止选择男性        --&gt;        &lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;sex&quot; disabled&gt;男        &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;sex&quot;&gt;女    &lt;/p&gt;    &lt;p&gt;        &lt;!--多选框         type=&quot;checkbox&quot;         value:多选框的值         name : 表示组，name值一样则表示为一组数据        --&gt;        &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;睡觉        &lt;!--checked  : 默认选中--&gt;        &lt;input type=&quot;checkbox&quot; value=&quot;code&quot; name=&quot;hobby&quot; checked&gt;敲代码        &lt;input type=&quot;checkbox&quot; value=&quot;chat&quot; name=&quot;hobby&quot;&gt;聊天        &lt;input type=&quot;checkbox&quot; value=&quot;game&quot; name=&quot;hobby&quot;&gt;游戏    &lt;/p&gt;    &lt;p&gt;        &lt;!--按钮        type=&quot;button&quot;        name ： 按钮名称        value : 按钮上显示的内容         --&gt;        &lt;input type=&quot;button&quot; name=&quot;btn1&quot; value=&quot;点击按钮&quot;&gt;        &lt;!--图片按钮  相当于提交按钮--&gt;        &lt;input type=&quot;image&quot; src=&quot;../resources/image/2.png&quot; width=&quot;50px&quot; height=&quot;50px&quot;&gt;    &lt;/p&gt;    &lt;p&gt;国家：        &lt;!--下拉框        使用select标签        name ：列表的名称，后台可以获得列表名称        value ： 传到后端的值        --&gt;        &lt;select name=&quot;country&quot;&gt;            &lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt;            &lt;option value=&quot;usa&quot;&gt;美国&lt;/option&gt;            &lt;!--selected  表示默认选择法国--&gt;            &lt;option value=&quot;fa&quot; selected&gt;法国&lt;/option&gt;            &lt;option value=&quot;ying&quot;&gt;英国&lt;/option&gt;        &lt;/select&gt;    &lt;/p&gt;    &lt;p&gt;反馈：        &lt;!--文本域        textarea标签        cols  : 默认显示几列        rows  : 默认显示几行        --&gt;        &lt;textarea name=&quot;textarea&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;默认文本&lt;/textarea&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--文件域--&gt;        &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--邮箱验证  输入的值必须添加@并且前后都有值--&gt;        邮箱：&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--url验证  输入的值必须是一个网址--&gt;        url:&lt;input type=&quot;url&quot; name=&quot;url&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--数字验证  输入的值必须大于0小于100并且是10的倍数        max  ： 最大值        min  ： 最小值        step  ： 步长，每次加几        --&gt;        数字:&lt;input type=&quot;number&quot; name=&quot;num&quot; max=&quot;100&quot; min=&quot;0&quot; step=&quot;10&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--滑块        range 标签        可以在参数中获取得到的多少数值        --&gt;        滑块：&lt;input type=&quot;range&quot; name=&quot;voice&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;2&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--搜索框--&gt;        搜索:&lt;input type=&quot;search&quot; name=&quot;search&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--增强鼠标可用性        label标签        也就是在点击label这个标签里面的内容时，会自动将光标锁定到输入框id为for属性里面的内容        --&gt;        &lt;label for=&quot;work&quot;&gt;你点我逝世：&lt;/label&gt;        &lt;input type=&quot;text&quot; id=&quot;work&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--pattern  正则表达式，这里输入的东西必须满足pattern的规则--&gt;        自定义邮箱：        &lt;input type=&quot;text&quot; name=&quot;diyEmail&quot;               pattern=&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--提交按钮 ： type=&quot;submit&quot; --&gt;        &lt;input type=&quot;submit&quot;&gt;        &lt;!--重置按钮 ： type=&quot;reset&quot;--&gt;        &lt;input type=&quot;reset&quot;&gt;    &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 CSS 轻松实现一些高频出现的奇形怪状按钮</title>
      <link href="/2022/02/09/article11/"/>
      <url>/2022/02/09/article11/</url>
      
        <content type="html"><![CDATA[<p>先让我们来看看这些经常会出现的按钮形状：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f865a6b485941fb83b85a857e8a4a08~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="矩形与圆角按钮"><a href="#矩形与圆角按钮" class="headerlink" title="矩形与圆角按钮"></a>矩形与圆角按钮</h2><p>正常而言，我们遇到的按钮就这两种 – 矩形和圆角：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/213bdbde25cd419985affcdd034ca2d0~tplv-k3u1fbpfcp-zoom-1.image"></p><p>它们非常的简单，宽高和圆角和背景色。</p><pre><code>&lt;div class=&#39;btn rect&#39;&gt;rect&lt;/div&gt;&lt;div class=&#39;btn circle&#39;&gt;circle&lt;/div&gt;.btn &#123;   margin: 8px auto;   flex-shrink: 0;   width: 160px;   height: 64px;&#125;.rect &#123;    background: #f6ed8d;&#125;.circle &#123;    border-radius: 64px;    background: #7de3c8;&#125;</code></pre><h2 id="梯形与平行四边形"><a href="#梯形与平行四边形" class="headerlink" title="梯形与平行四边形"></a>梯形与平行四边形</h2><p>接下来，基于矩形的变形，经常会出现<strong>梯形与平行四边形</strong>的按钮。</p><p>实现它们主要使用 <code>transform</code> 即可，但是要注意一点，使用了 <code>transform</code> 之后，标签内的文字也会同样的变形，所以，我们通常使用元素的伪元素去实现造型，这样可以做到不影响按钮内的文字。</p><h3 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h3><p>使用 <code>transform: skewX()</code> 即可，注意上述说的，利用元素的伪元素实现平行四边形，做到不影响内部的文字。</p>   <div class='btn parallelogram'>Parallelogram</div>   .parallelogram {       position: relative;       width: 160px;       height: 64px;<pre><code>   &amp;::before &#123;       content: &quot;&quot;;       position: absolute;       top: 0;       left: 0;       bottom: 0;       right: 0;       background: #03f463;       transform: skewX(15deg);   &#125;</code></pre><p>}</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d02e72e6e0af4b23b5c5bbf2fbcb63c1~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如果不想使用伪元素，除了 <code>transform: skewX()</code>，平行四边形使用渐变也是可以实现的。</p><p>大概就是这样：</p><pre><code>&#123;    background: linear-gradient(45deg, transparent 22%, #04e6fb 22%, #9006fb 78%, transparent 0);&#125;</code></pre><h3 id="梯形"><a href="#梯形" class="headerlink" title="梯形"></a>梯形</h3><p>梯形比平行四边形稍微复杂一点，它多借助了 <code>perspective</code>，其实是利用了一定的 3D 变换。原理就是一个矩形，绕着 X 轴旋转，像是这样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/083a479bed964814a78600c567e005d7~tplv-k3u1fbpfcp-zoom-1.image"></p><p>使用 <code>perspective</code> 和 <code>transform: rotateX()</code> 即可，当然，它们可以合在一起写：</p><pre><code>&lt;div class=&#39;btn trapezoid&#39;&gt;Trapezoid&lt;/div&gt;.parallelogram &#123;    position: relative;    width: 160px;    height: 64px;    &amp;::after &#123;          content:&quot;&quot;;          position: absolute;          top: 0; right: 0; bottom: 0; left: 0;          transform: perspective(40px) rotateX(10deg);          transform-origin: bottom;          background: #ff9800;    &#125;&#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b10e95e7278e464489034261e4634f75~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="切角-–-纯色背景与渐变色背景"><a href="#切角-–-纯色背景与渐变色背景" class="headerlink" title="切角 – 纯色背景与渐变色背景"></a>切角 – 纯色背景与渐变色背景</h2><p>接下来是切角图形，最常见的方法主要是借助渐变 <code>linear-gradient</code> 实现，来看这样一个图形</p><pre><code>&lt;div&gt;&lt;/div&gt;.notching &#123;    background: linear-gradient(135deg, transparent 10px, #ff1493 0);    background-repeat: no-repeat;&#125;</code></pre><p>结果如下，</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403085aae53a472787da5b0b8a82bab3~tplv-k3u1fbpfcp-zoom-1.image"></p><p>基于此，我们只需要利用多重渐变，实现 4 个这样的图形即可，并且，利用 <code>background-position</code> 定位到四个角：</p><pre><code>&lt;div class=&quot;notching&quot;&gt;notching&lt;/div&gt;.notching &#123;    background:        linear-gradient(135deg, transparent 10px, #ff1493 0) top left,        linear-gradient(-135deg, transparent 10px, #ff1493 0) top right,        linear-gradient(-45deg, transparent 10px, #ff1493 0) bottom right,        linear-gradient(45deg, transparent 10px, #ff1493 0) bottom left;    background-size: 50% 50%;    background-repeat: no-repeat;&#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e185404519245bc9548693c1b514cb4~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="利用-clip-path-实现渐变背景的切角图形"><a href="#利用-clip-path-实现渐变背景的切角图形" class="headerlink" title="利用 clip-path 实现渐变背景的切角图形"></a>利用 clip-path 实现渐变背景的切角图形</h3><p>当然，这个技巧有个问题，当要求底色是渐变色的时候，这个方法就比较笨拙了。</p><p>好在，我们还有另外一种方式，借助 <code>clip-path</code> 切出一个切角图形，这样，背景色可以是任意定制的颜色，无论是渐变还是纯色都不在话下：</p><pre><code>&lt;div class=&quot;clip-notching&quot;&gt;notching&lt;/div&gt;.clip-notching &#123;    background: linear-gradient(        45deg,        #f9d9e7,        #ff1493    );    clip-path: polygon(        15px 0,        calc(100% - 15px) 0,        100% 15px,        100% calc(100% - 15px),        calc(100% - 15px) 100%,        15px 100%,        0 calc(100% - 15px),        0 15px    );&#125;</code></pre><p>简单的实现一个渐变背景，接着核心就是，在渐变矩形图形的基础上，利用 <code>clip-path: polygon()</code> 切出我们想要的形状（一个 8 边形）：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/035df81ad9754fdcb59bc13e65c9275b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>当然，上述代码非常容易联想到下述这种 6 边形，使用渐变和 <code>clip-path</code> 都可以轻松得到：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0185c3e6db894ea1a4e4a561124cc843~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="箭头按钮"><a href="#箭头按钮" class="headerlink" title="箭头按钮"></a>箭头按钮</h2><p>接下来是箭头按钮，仔细观察上面的切角按钮，当两边的角被切掉的足够多的时候，就变成了一个箭头的形状。</p><p>我们可以利用两重渐变，实现一个单箭头按钮：</p><pre><code>&lt;div class=&quot;arrow&quot;&gt;arrow&lt;/div&gt;&amp;.arrow &#123;    background: linear-gradient(                -135deg,                transparent 22px,                #04e6fb 22px,                #65ff9a 100%            )            top right,        linear-gradient(                -45deg,                transparent 22px,                #04e6fb 22px,                #65ff9a 100%            )            bottom right;    background-size: 100% 50%;    background-repeat: no-repeat;&#125;一个箭头就出来了：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc39ca54f91d47a88c429fe2b0047df6~tplv-k3u1fbpfcp-zoom-1.image)它是由上下两个渐变块组合得到的，换个颜色立马就能明白：![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca4903b269f64c75ab51ebffdc341e19~tplv-k3u1fbpfcp-zoom-1.image)那如果是这样一个箭头造型呢？![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aed4f085c4f84b41b5ac95ad6672161b~tplv-k3u1fbpfcp-zoom-1.image)一样的，它也是两个渐变的叠加，渐变的颜色是**透明 --&gt; 颜色A --&gt; 颜色B --&gt; 透明**。当然，同样在这里也可以使用 `clip-path`：这里给出 `clip-path` 的解法：```CSS&#123;    background: linear-gradient(45deg, #04e6fb, #65ff9a);    clip-path: polygon(        0 0,        30px 50%,        0 100%,        calc(100% - 30px) 100%,        100% 50%,        calc(100% - 30px) 0    );&#125;</code></pre><h2 id="内切圆角"><a href="#内切圆角" class="headerlink" title="内切圆角"></a>内切圆角</h2><p>下面这个按钮形状，多出现于优惠券，最常见的解法，也是使用渐变，当然，与切角不同，这里使用的径向渐变。</p><p>首先，看这样一个简单的例子：</p><pre><code>&lt;div&gt;&lt;/div&gt;div &#123;    background-image: radial-gradient(circle at 100% 100%, transparent 0, transparent 12px, #2179f5 12px);&#125;</code></pre><p>可以得到这样一个图形：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fad928ea83d8461ab604dea37f590321~tplv-k3u1fbpfcp-zoom-1.image"></p><p>所以，只需控制下 <code>background-size</code>，在 4 个角实现 4 个这样的图形即可：</p><pre><code>&lt;div class=&quot;inset-circle&quot;&gt;inset-circle&lt;/div&gt;&amp;.inset-circle &#123;    background-size: 70% 70%;    background-image: radial-gradient(            circle at 100% 100%,            transparent 0,            transparent 12px,            #2179f5 13px        ),        radial-gradient(            circle at 0 0,            transparent 0,            transparent 12px,            #2179f5 13px        ),        radial-gradient(            circle at 100% 0,            transparent 0,            transparent 12px,            #2179f5 13px        ),        radial-gradient(            circle at 0 100%,            transparent 0,            transparent 12px,            #2179f5 13px        );    background-repeat: no-repeat;    background-position: right bottom, left top, right top, left bottom;&#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a950088d1edd4b05aba575854aeed0c5~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="借助-mask-实现渐变的内切圆角按钮"><a href="#借助-mask-实现渐变的内切圆角按钮" class="headerlink" title="借助 mask 实现渐变的内切圆角按钮"></a>借助 mask 实现渐变的内切圆角按钮</h3><p>如果背景色要求渐变怎么办呢？</p><p>假设我们有一张矩形背景图案，我们只需要使用 <code>mask</code> 实现一层遮罩，利用 <code>mask</code> 的特性，把 4 个角给遮住即可。</p><p><code>mask</code> 的代码和上述的圆角切角代码非常类似，简单改造下即可得到渐变的内切圆角按钮：</p><pre><code>&lt;div class=&quot;mask-inset-circle&quot;&gt;inset-circle&lt;/div&gt;.mask-inset-circle &#123;    background: linear-gradient(45deg, #2179f5, #e91e63);    mask: radial-gradient(            circle at 100% 100%,            transparent 0,            transparent 12px,            #2179f5 13px        ),        radial-gradient(            circle at 0 0,            transparent 0,            transparent 12px,            #2179f5 13px        ),        radial-gradient(            circle at 100% 0,            transparent 0,            transparent 12px,            #2179f5 13px        ),        radial-gradient(            circle at 0 100%,            transparent 0,            transparent 12px,            #2179f5 13px        );    mask-repeat: no-repeat;    mask-position: right bottom, left top, right top, left bottom;    mask-size: 70% 70%;&#125;</code></pre><p>这样，我们就得到了这样一个图形：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aef32f16930d4091bd6d3cdef2e79dec~tplv-k3u1fbpfcp-zoom-1.image"></p><p>当然，读懂上述代码，你需要首先弄清楚 CSS <code>mask</code> 属性的原理，如果你对它还有些陌生，可以看看我的这篇文章：</p><p><a href="https://github.com/chokcoco/iCSS/issues/80">奇妙的 CSS MASK</a></p><h2 id="圆角不规则矩形"><a href="#圆角不规则矩形" class="headerlink" title="圆角不规则矩形"></a>圆角不规则矩形</h2><p>下面这个按钮形状，也是最近被问到最多的，先来看看它的造型：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cd059aca5a84f45b756bac650452fca~tplv-k3u1fbpfcp-zoom-1.image"></p><p>不太好给它起名，一侧是规则的带圆角直角，另外一侧则是带圆角的斜边。</p><p>其实，它就是由<strong>圆角矩形</strong> + <strong>圆角平行四边形组成</strong>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56619c01c9234ff1aeeb3a83a6c6c3ce~tplv-k3u1fbpfcp-zoom-1.image"></p><p>所以，借助两个伪元素，可以轻松的实现它们：</p><pre><code>&lt;div class=&quot;skew&quot;&gt;Skew&lt;/div&gt;.skew &#123;    position: relative;    width: 120px;    &amp;::after &#123;        content: &quot;&quot;;        position: absolute;        top: 0;        left: 0;        right: 0;        bottom: 0;        border-radius: 10px;        background: orange;        transform: skewX(15deg);    &#125;    &amp;::before &#123;        content: &quot;&quot;;        position: absolute;        top: 0;        right: -13px;        width: 100px;        height: 64px;        border-radius: 10px;        background: orange;    &#125;&#125;</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4f471820794d58a80f81f5c4c00052~tplv-k3u1fbpfcp-zoom-1.image"></p><p>由于一个伪元素叠加在另外一个之上，所以对其中一个使用渐变，一个则是纯色，其颜色是可以完美衔接在一起的，这样就实现了渐变色的该图形：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4bb1de4018421a9eb142d7b7590cfa~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="外圆角按钮"><a href="#外圆角按钮" class="headerlink" title="外圆角按钮"></a>外圆角按钮</h2><p>接下来这个按钮形状，常见于 Tab 页上，类似于 Chrome 的分页：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d516c287fa9a40738b77f91ea92fc152~tplv-k3u1fbpfcp-zoom-1.image"></p><p>我们对这个按钮形状拆解一下，这里其实是 3 块的叠加：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1b933f02fc54a34a36a0430254b4a12~tplv-k3u1fbpfcp-zoom-1.image"></p><p>只需要想清楚如何实现两侧的弧形三角即可。这里还是借助了渐变 – <strong>径向渐变</strong>，其实他是这样，如下图所示，我们只需要把黑色部分替换为透明即可， 两个伪 元素即可：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/851ef119668d4670b14989db2ad105a0~tplv-k3u1fbpfcp-zoom-1.image"></p><p>代码如下：</p><pre><code>&lt;div class=&quot;outside-circle&quot;&gt;outside-circle&lt;/div&gt;.outside-circle &#123;    position: relative;    background: #e91e63;    border-radius: 10px 10px 0 0;    &amp;::before &#123;        content: &quot;&quot;;        position: absolute;        width: 20px;        height: 20px;        left: -20px;        bottom: 0;        background: #000;        background:radial-gradient(circle at 0 0, transparent 20px, #e91e63 21px);    &#125;    &amp;::after &#123;        content: &quot;&quot;;        position: absolute;        width: 20px;        height: 20px;        right: -20px;        bottom: 0;        background: #000;        background:radial-gradient(circle at 100% 0, transparent 20px, #e91e63 21px);    &#125;&#125;</code></pre><p>即可得到：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf23b36595f14f4ca3bc77e107525226~tplv-k3u1fbpfcp-zoom-1.image"></p><p>上述的所有图形的完整代码，你可以在这里看到：<a href="https://codepen.io/Chokcoco/pen/QWMoBGO?editors=1100">CodePen Demo – CSS Various Button Shapes | CSS 各种造型按钮</a></p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>基于上述的实现，我们不难发现，一些稍微特殊的按钮，无非都通过拼接、障眼法、遮罩等方式实现。</p><p>而在其中：</p><ul><li>渐变（线性渐变 <code>linear-gradient</code>、径向渐变 <code>radial-gradient</code>、多重渐变）</li><li>遮罩 <code>mask</code></li><li>裁剪 <code>clip-path</code></li><li>变形 <code>transform</code></li></ul><p>发挥了重要的作用，熟练使用它们，我们对于这些图形就可以信手拈来，基于它们的变形也能从容面对。</p><p>上述的图形，再配合 <code>filter: drop-shadow()</code>，基本都能实现不规则阴影。</p><p>再者，更为复杂的图形，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22c9c459077b48b79fd91fea13ef94e4~tplv-k3u1fbpfcp-zoom-1.image"></p><p>还是切图吧，CSS 虽好，实际使用中也需要考虑投入产出比。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows注册表自启项</title>
      <link href="/2022/02/01/article10/"/>
      <url>/2022/02/01/article10/</url>
      
        <content type="html"><![CDATA[<h2 id="Run-和-RunOnce-注册表项"><a href="#Run-和-RunOnce-注册表项" class="headerlink" title="Run 和 RunOnce 注册表项"></a>Run 和 RunOnce 注册表项</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows 的 Run 和 RunOnce 注册表项可以让用户登陆系统时自动启动一些程序。<br>其中涉及到的注册表项如下：</p><ul><li>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</li><li>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</li><li>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</li><li>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce<br>在这四种项中添加的自启动程序的规则不一样：</li><li>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run 表示任何账户每一次登陆到 Windows 系统都会自动启动在这个项下面注册的程序</li><li>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce 表示任何账户下一次登陆到 Windows 系统会自动启动在这个项下面注册的程序，以后就不会自启了</li><li>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run 表示当前账户每一次登陆到 Windows 系统都会自动启动在这个项下面注册的程序</li><li>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce 表示当前账户下一次登陆到 Windows 系统会自动启动在这个项下面注册的程序，以后就不会自启了<br>一般来说<br>在 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run 项下注册自启动项就行了，</li></ul><h2 id="注册方法"><a href="#注册方法" class="headerlink" title="注册方法"></a>注册方法</h2><h3 id="一-打开注册表编辑器：按下-Win-键盘，输入注册表或者regedit然后-Enter"><a href="#一-打开注册表编辑器：按下-Win-键盘，输入注册表或者regedit然后-Enter" class="headerlink" title="一.打开注册表编辑器：按下 Win 键盘，输入注册表或者regedit然后 Enter:"></a>一.打开注册表编辑器：按下 Win 键盘，输入<code>注册表</code>或者<code>regedit</code>然后 Enter:</h3><h3 id="二-将上面对应的注册表项粘贴到如下位置按-Enter："><a href="#二-将上面对应的注册表项粘贴到如下位置按-Enter：" class="headerlink" title="二.将上面对应的注册表项粘贴到如下位置按 Enter："></a>二.将上面对应的注册表项粘贴到如下位置按 Enter：</h3><h3 id="三-添加自动启动项："><a href="#三-添加自动启动项：" class="headerlink" title="三.添加自动启动项："></a>三.添加自动启动项：</h3><p>空白处右击，选择”新建”-&gt;”字符串值”：<br>取个名字：<br>复制你的程序的路径：按住 Shift 键右击程序，选择”复制文件地址”：<br>回到注册表编辑器，右击你取的程序的名字，然后选择修改：<br>在如下位置按 Ctrl+V 粘贴，然后点击确定，就行了：</p><blockquote><p>也可以通过右击每一项的名字（键），选择删除某一个程序的自动启项，让程序开机时不自动启动，可以提升开机速度，减少内存消耗</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础学习</title>
      <link href="/2022/01/16/article9/"/>
      <url>/2022/01/16/article9/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h1><p>以软件包格式：<br>rpm：<br>Red Hat Enterprise Linux<br>CentOS<br>openSUSE<br>Fedora<br>deb：<br>Debian<br>Ubuntu<br>linux mint<br>安全测试系统：<br>kali</p><h1 id="安装-centos"><a href="#安装-centos" class="headerlink" title="安装 centos"></a>安装 centos</h1><p>在虚拟机里创建 centos</p><p>选择语言，默认为英语</p><p>在此界面设置系统相关选项，时区、软件、硬盘、网络等</p><p>设置时区</p><p>选择 minimal 安装</p><p>硬盘分区</p><p>开始安装并设置 root 密码，创建普通用户</p><p>登录系统</p><h1 id="history-记录命令执行时间"><a href="#history-记录命令执行时间" class="headerlink" title="history 记录命令执行时间"></a>history 记录命令执行时间</h1><p>]$ export HISTTIMEFORMAT=’%F %T ‘<br>注：在当前登录 shell 中生效<br>编辑.bashrc 文件，在文件中加入会永久有效</p><h1 id="Linux-哲学思想"><a href="#Linux-哲学思想" class="headerlink" title="Linux 哲学思想"></a>Linux 哲学思想</h1><p>1：一切皆文件<br>硬件也是文件<br>2：由众多功能单一的程序组成；一个程序只做一件事，并且做好；<br>组合小程序完成复杂任务；<br>3：尽量避免跟用户交互；<br>目标：易于以编程的方式实现自动化任务<br>4：使用文本文件保存配置信息</p><h1 id="Linux-常用命令："><a href="#Linux-常用命令：" class="headerlink" title="Linux 常用命令："></a>Linux 常用命令：</h1><pre><code>catcat [OPTION]... [FILE]...datedate [OPTION]... [+FORMAT]date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]ifconfigifconfig [-v] [-a] [-s] [interface]ifconfig [-v] interface [aftype] options | address ...lsls [OPTION]... [FILE]...</code></pre><h1 id="Linux-文件目录"><a href="#Linux-文件目录" class="headerlink" title="Linux 文件目录"></a>Linux 文件目录</h1><pre><code>Filesystem Hierarchy Standard/bin: 所有用户可用的基本命令程序文件；/sbin: 供系统管理工作使用的工具程序；/boot: 引导加载器必须用到的各静态文件：kernel，initramfs(initrd)，grub等；/dev: 存储特殊文件或设备文件；设备有两种类型：字符设备(线性设备)，块设备(随机设备)；/etc: 系统程序的配置文件，只能为静态文件；/home: 普通用户的家目录的集中位置；一般每个普通用户的家目录默认此目录下与用户同名的子目录，/home/USERNAME/lib: 为系统启动或根文件系统上的应用程序(/bin, /sbin)提供共享库，以及为内核提供内核模块libc.so.*: 动态链接的C库；ld*: 运行时链接器/加载器；modules: 用于存储内核模块的目录；/lib64: 64位系统特有的存放共享库的路径；/media: 便携式设备挂载点，cdrom，floppy等；/mnt: 其它文件系统的临时挂载点；/opt: 附加应用程序的安装位置；可选路径；/srv: 当前主机为服务提供的数据；/tmp: 为那些会产生临时文件的程序提供的用于存储临时文件的目录；/usr: User Hierarchy，全局共享的只读数据路径；binsbinliblib64include: C程序头文件share：命令手册页和自带文档等架构特有的文件的存储位置local：另一个层级目录X11R6: X-Window程序的安装位置src：程序源码文件的存储位置/usr/lcoal: Local Hierarchy，让系统管理员安装本地应用程序；/var: 存储常发生变化的数据的目录；/proc: 虚拟文件系统，用于为内核及进程存储其相关信息；它们多为内核参数；/sys: sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径；</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Vue的天地图入门</title>
      <link href="/2022/01/07/article8/"/>
      <url>/2022/01/07/article8/</url>
      
        <content type="html"><![CDATA[<h3 id="天地图组件的引用"><a href="#天地图组件的引用" class="headerlink" title="天地图组件的引用"></a>天地图组件的引用</h3><p>首先去<a href="https://www.tianditu.gov.cn/">天地图官网</a>，登录或者注册。<br>依次点击开发资源-网页 Api-新弹出页面右上角控制台</p><p>在控制台页面，单击右上角创建新应用，随便填一填巴拉巴拉。</p><p>申请成功后记住你的 key。</p><p>我新建了一个 vue 项目，这个项目啥也没有，像丁真一样纯真。</p><p>找到 index.html 这个文件 把下列代码复制进去，实现全局引入 （当然你也可以粘贴在某个 vue 页面上来实现按需引入）</p><p><code>&lt;script src=&quot;http://api.tianditu.gov.cn/api?v=4.0&amp;tk=你的密钥&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></p><p>保存，刷新 Vue 项目，打开 F12 控制台发现请求成功。<br>新建一个 vue 文件，在你像要防止地图的地方新建一个 div，定义他的大小，id 自己命名，我取名为 map。</p><div class="bodyAll"><div id="map" style="height:100%;width:100%"></div></div>在 methods 书写 initMap()方法并在 mounted 里引用。别忘在 data return 里注入 map:{}<pre><code>methods: &#123;  initMap() &#123;    let T = window.T;//全局引入后T被注册到window里，在从这儿拿到T。T包含了天地图提供的各种方法等。    this.map = new T.Map(&quot;map&quot;);    this.map.centerAndZoom(new T.LngLat(112, 36), 7);//三个参数分别为经度，纬度，缩放等级。  &#125;,&#125;,mounted() &#123;  this.initMap();&#125;,</code></pre><p>芜湖~已经能加载出来啦。能加载出来就算成功^^_</p><h3 id="图层组件"><a href="#图层组件" class="headerlink" title="图层组件"></a>图层组件</h3><p>可以用继承于 TControl 的 MapType 类来构造图层组件。示例代码的参数是个数组，如果什么都不传会有一个默认的图层系列。</p><p>以下这些图层都可以在官方的 api 里找到</p><pre><code>//添加切换地图图层的组件addCtrl() &#123;  var ctrl = new T.Control.MapType([    &#123;      title: &quot;地图&quot;,      //地图控件上所要显示的图层名称      icon: &quot;http://api.tianditu.gov.cn/v4.0/image/map/maptype/vector.png&quot;,      //地图控件上所要显示的图层图标（默认图标大小80x80）      layer: TMAP_NORMAL_MAP, //地图类型对象，即MapType。    &#125;,    &#123;      title: &quot;卫星&quot;,      icon: &quot;http://api.tianditu.gov.cn/v4.0/image/map/maptype/satellite.png&quot;,      layer: TMAP_SATELLITE_MAP,    &#125;,    &#123;      title: &quot;卫星混合&quot;,      http: &quot;http://api.tianditu.gov.cn/v4.0/image/map/maptype/satellitepoi.png&quot;,      layer: TMAP_HYBRID_MAP,    &#125;,    &#123;      title: &quot;地形&quot;,      icon: &quot; http://api.tianditu.gov.cn/v4.0/image/map/maptype/terrain.png&quot;,      layer: TMAP_TERRAIN_MAP,    &#125;,    &#123;  title: &quot;地形混合&quot;,  icon: &quot; http://api.tianditu.gov.cn/v4.0/image/map/maptype/terrainpoi.png&quot;,      layer: TMAP_TERRAIN_HYBRID_MAP,  &#125;,]);this.map.addControl(ctrl);</code></pre><h3 id="获取地图中心坐标点"><a href="#获取地图中心坐标点" class="headerlink" title="获取地图中心坐标点"></a>获取地图中心坐标点</h3><pre><code>getMapCenter() &#123;  this.$message(    &quot;地图中心坐标点:&quot; +      this.map.getCenter().getLng() +      &quot;,&quot; +      this.map.getCenter().getLat()  );&#125;,</code></pre><h3 id="获取地图缩放级别"><a href="#获取地图缩放级别" class="headerlink" title="获取地图缩放级别"></a>获取地图缩放级别</h3><pre><code>getMapZoom() &#123;  this.$message(&quot;地图缩放级别:&quot; + this.map.getZoom());&#125;,</code></pre><h3 id="获取地图当前可视范围坐标"><a href="#获取地图当前可视范围坐标" class="headerlink" title="获取地图当前可视范围坐标"></a>获取地图当前可视范围坐标</h3><pre><code>getMapBounds() &#123;  let bs = this.map.getBounds(); //获取可视区域`  let bssw = bs.getSouthWest(); //可视区域左下角`  let bsne = bs.getNorthEast(); //可视区域右上角`  this.$message(`    &quot;当前地图可视范围是:&quot; +      bssw.getLng() +      &quot;,&quot; +      bssw.getLat() +      &quot;到&quot; +      bsne.getLng() +      &quot;,&quot; +      bsne.getLat()  );&#125;,</code></pre><p>目前的这些 api 都可以从天地图官网找到，如果你需要要更多需求，官方也许也有现成的 api。建议先熟悉一下官方 api 再进行开发。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li>天地图官网：<a href="https://www.tianditu.gov.cn/">https://www.tianditu.gov.cn/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30个类手写Spring核心原理之自定义ORM</title>
      <link href="/2021/12/21/article7/"/>
      <url>/2021/12/21/article7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-实现思路概述"><a href="#1-实现思路概述" class="headerlink" title="1 实现思路概述#"></a>1 实现思路概述<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#1--%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E6%A6%82%E8%BF%B0">#</a></h2><h3 id="1-1-从-ResultSet-说起"><a href="#1-1-从-ResultSet-说起" class="headerlink" title="1.1 从 ResultSet 说起#"></a>1.1 从 ResultSet 说起<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#11--%E4%BB%8Eresultset%E8%AF%B4%E8%B5%B7">#</a></h3><p>说到 ResultSet，有 Java 开发经验的“小伙伴”自然最熟悉不过了，不过我相信对于大多数人来说也算是“最熟悉的陌生人”。从 ResultSet 取值操作大家都会，比如：</p><pre><code>private static List&lt;Member&gt; select(String sql) &#123;    List&lt;Member&gt; result = new ArrayList&lt;&gt;();    Connection con = null;    PreparedStatement pstm = null;    ResultSet rs = null;    try &#123;        //1. 加载驱动类        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2. 建立连接        con = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/gp-vip-spring-db-demo&quot;, &quot;root&quot;,&quot;123456&quot;);        //3. 创建语句集        pstm =  con.prepareStatement(sql);        //4. 执行语句集        rs = pstm.executeQuery();        while (rs.next())&#123;            Member instance = new Member();            instance.setId(rs.getLong(&quot;id&quot;));            instance.setName(rs.getString(&quot;name&quot;));            instance.setAge(rs.getInt(&quot;age&quot;));            instance.setAddr(rs.getString(&quot;addr&quot;));            result.add(instance);        &#125;        //5. 获取结果集    &#125;catch (Exception e)&#123;        e.printStackTrace();    &#125;    //6. 关闭结果集、关闭语句集、关闭连接    finally &#123;        try &#123;            rs.close();            pstm.close();            con.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    return result;&#125;</code></pre><p>以上我们在没有使用框架以前的常规操作。随着业务和开发量的增加，在数据持久层这样的重复代码出现频次非常高。因此，我们就想到将非功能性代码和业务代码进行分离。我们首先想到将 ResultSet 封装数据的代码逻辑分离，增加一个 mapperRow()方法，专门处理对结果的封装，代码如下：</p><pre><code>private static List&lt;Member&gt; select(String sql) &#123;    List&lt;Member&gt; result = new ArrayList&lt;&gt;();    Connection con = null;    PreparedStatement pstm = null;    ResultSet rs = null;    try &#123;        //1. 加载驱动类        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2. 建立连接        con = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/gp-vip-spring-db-demo&quot;, &quot;root&quot;,&quot;123456&quot;);        //3. 创建语句集        pstm =  con.prepareStatement(sql);        //4. 执行语句集        rs = pstm.executeQuery();        while (rs.next())&#123;            Member instance = mapperRow(rs,rs.getRow());            result.add(instance);        &#125;        //5. 获取结果集    &#125;catch (Exception e)&#123;        e.printStackTrace();    &#125;    //6. 关闭结果集、关闭语句集、关闭连接    finally &#123;        try &#123;            rs.close();            pstm.close();            con.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    return result;&#125;private static Member mapperRow(ResultSet rs, int i) throws Exception &#123;    Member instance = new Member();    instance.setId(rs.getLong(&quot;id&quot;));    instance.setName(rs.getString(&quot;name&quot;));    instance.setAge(rs.getInt(&quot;age&quot;));    instance.setAddr(rs.getString(&quot;addr&quot;));    return instance;&#125;</code></pre><p>但在真实的业务场景中，这样的代码逻辑重复率实在太高，上面的改造只能应用 Member 类，换一个实体类又要重新封装，聪明的程序员肯定不会通过纯体力劳动给每一个实体类写一个 mapperRow()方法，一定会想到代码复用方案。我们不妨来做这样一个改造。<br>先创建 Member 类：</p><pre><code>package com.gupaoedu.vip.orm.demo.entity;import lombok.Data;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.io.Serializable;@Entity@Table(name=&quot;t_member&quot;)@Datapublic class Member implements Serializable &#123;    @Id private Long id;    private String name;    private String addr;    private Integer age;    @Override    public String toString() &#123;        return &quot;Member&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, addr=&#39;&quot; + addr + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>​<br> 优化 JDBC 操作：</p><p>​<br> public static void main(String[] args) {<br>Member condition = new Member();<br>condition.setName(“Tom”);<br>condition.setAge(19);<br>List&lt;?&gt; result = select(condition);<br>System.out.println(Arrays.toString(result.toArray()));<br>}</p><pre><code>private static List&lt;?&gt; select(Object condition) &#123;    List&lt;Object&gt; result = new ArrayList&lt;&gt;();    Class&lt;?&gt; entityClass = condition.getClass();    Connection con = null;    PreparedStatement pstm = null;    ResultSet rs = null;    try &#123;        //1. 加载驱动类        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2. 建立连接        con = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/gp-vip-spring-db-demo? characterEncoding=UTF-8&amp;    rewriteBatchedStatements=true&quot;,&quot;root&quot;,&quot;123456&quot;);        //根据类名找属性名        Map&lt;String,String&gt; columnMapper = new HashMap&lt;String,String&gt;();        //根据属性名找字段名        Map&lt;String,String&gt; fieldMapper = new HashMap&lt;String,String&gt;();        Field[] fields =  entityClass.getDeclaredFields();        for (Field field : fields) &#123;            field.setAccessible(true);            String fieldName = field.getName();            if(field.isAnnotationPresent(Column.class))&#123;                Column column = field.getAnnotation(Column.class);                String columnName = column.name();                columnMapper.put(columnName,fieldName);                fieldMapper.put(fieldName,columnName);            &#125;else &#123;                //默认就是字段名、属性名一致                columnMapper.put(fieldName, fieldName);                fieldMapper.put(fieldName,fieldName);            &#125;        &#125;        //3. 创建语句集        Table table = entityClass.getAnnotation(Table.class);        String sql = &quot;select * from &quot; + table.name();        StringBuffer where = new StringBuffer(&quot; where 1=1 &quot;);        for (Field field : fields) &#123;            Object value =field.get(condition);            if(null != value)&#123;                if(String.class == field.getType()) &#123;                    where.append(&quot; and &quot; + fieldMapper.get(field.getName()) + &quot; = &#39;&quot; + value + &quot;&#39;&quot;);                &#125;else&#123;                    where.append(&quot; and &quot; + fieldMapper.get(field.getName()) + &quot; = &quot; + value + &quot;&quot;);                &#125;                //其他的在这里就不一一列举，后面我们手写ORM框架时会完善            &#125;        &#125;        System.out.println(sql + where.toString());        pstm =  con.prepareStatement(sql + where.toString());        //4. 执行语句集        rs = pstm.executeQuery();        //元数据？        //保存了处理真正数值以外的所有附加信息        int columnCounts = rs.getMetaData().getColumnCount();        while (rs.next())&#123;            Object instance = entityClass.newInstance();            for (int i = 1; i &lt;= columnCounts; i++) &#123;                //实体类属性名，对应数据库表的字段名                //可以通过反射机制拿到实体类的所有字段                //从rs中取得当前这个游标下的类名                String columnName = rs.getMetaData().getColumnName(i);                //有可能是私有的                Field field = entityClass.getDeclaredField(columnMapper.get(columnName));                field.setAccessible(true);                field.set(instance,rs.getObject(columnName));            &#125;            result.add(instance);        &#125;        //5. 获取结果集    &#125;catch (Exception e)&#123;        e.printStackTrace();    &#125;    //6. 关闭结果集、关闭语句集、关闭连接    finally &#123;        try &#123;            rs.close();            pstm.close();            con.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    return result;&#125;</code></pre><p>上面巧妙地利用反射机制读取 Class 信息和 Annotation 信息，将数据库表中的列和类中的字段进行关联映射并赋值，以减少重复代码。</p><h3 id="1-2-为什么需要-ORM-框架"><a href="#1-2-为什么需要-ORM-框架" class="headerlink" title="1.2 为什么需要 ORM 框架#"></a>1.2 为什么需要 ORM 框架<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#12--%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81orm%E6%A1%86%E6%9E%B6">#</a></h3><p>通过前面的讲解，我们已经了解 ORM 框架的基本实现原理。ORM 是指对象关系映射（Object Relation Mapping），映射的不只是对象值，还有对象与对象之间的关系，例如一对多、多对多、一对一这样的表关系。现在市面上 ORM 框架也非常多，有大家所熟知的 Hibernate、Spring JDBC、MyBatis、JPA 等。在这里做一个简单的总结，如下表所示。</p><table><thead><tr><th>名称</th><th>特征</th><th>描述</th></tr></thead><tbody><tr><td>Hibernate</td><td>全自动（挡）</td><td>不需要写一句 SQL</td></tr><tr><td>MyBatis</td><td>半自动（挡）</td><td>手自一体，支持简单的映射，复杂关系需要自己写 SQL</td></tr><tr><td>Spring JDBC</td><td>纯手动（挡）</td><td>所有的 SQL 都要自己写，它帮我们设计了一套标准流程</td></tr></tbody></table><p>既然市面上有这么多选择，我为什么还要自己写 ORM 框架呢？<br>这得从我的一次空降担任架构师的经验说起。空降面临最大的难题就是如何取得团队“小伙伴们”的信任。当时，团队总共就 8 人，每个人的水平参差不齐，甚至有些人还没接触过 MySQL，诸如 Redis 等缓存中间件更不用说了。基本只会使用 Hibernate 的 CRUD，而且已经影响到了系统性能。由于工期紧张，没有时间和精力给团队做系统培训，也为了兼顾可控性，于是就产生了自研 ORM 框架的想法。我做了这样的顶层设计，以降低团队“小伙伴们”的存息成本，顶层接口统一参数、统一返回值，具体如下。</p><p>**（1）规定查询方法的接口模型为： **</p><pre><code>/** * 获取列表 * @param queryRule 查询条件 * @return */List&lt;T&gt; select(QueryRule queryRule) throws Exception;/** * 获取分页结果 * @param queryRule 查询条件 * @param pageNo 页码 * @param pageSize 每页条数 * @return */Page&lt;?&gt; select(QueryRule queryRule,int pageNo,int pageSize) throws Exception;/** * 根据SQL获取列表 * @param sql SQL语句 * @param args 参数 * @return */List&lt;Map&lt;String,Object&gt;&gt; selectBySql(String sql, Object... args) throws Exception;/** * 根据SQL获取分页 * @param sql SQL语句 * @param pageNo 页码 * @param pageSize 每页条数 * @return */Page&lt;Map&lt;String,Object&gt;&gt; selectBySqlToPage(String sql, Object [] param, int pageNo, int pageSize) throws Exception;</code></pre><p>​<br> <strong>（2）规定删除方法的接口模型为：</strong></p><p>​<br> /**<br>_ 删除一条记录<br>_ @param entity entity 中的 ID 不能为空，如果 ID 为空，其他条件不能为空，都为空不予执行<br>_ @return<br>_/<br>boolean delete(T entity) throws Exception;</p><pre><code>/** * 批量删除 * @param list * @return 返回受影响的行数 * @throws Exception */int deleteAll(List&lt;T&gt; list) throws Exception;</code></pre><p><strong>（3）规定插入方法的接口模型为：</strong></p><pre><code>/** * 插入一条记录并返回插入后的ID * @param entity 只要entity不等于null，就执行插入 * @return */PK insertAndReturnId(T entity) throws Exception;/** * 插入一条记录自增ID * @param entity * @return * @throws Exception */boolean insert(T entity) throws Exception;/** * 批量插入 * @param list * @return 返回受影响的行数 * @throws Exception */int insertAll(List&lt;T&gt; list) throws Exception;</code></pre><p><strong>（4）规定修改方法的接口模型为：</strong></p><pre><code>/** *  修改一条记录 * @param entity entity中的ID不能为空，如果ID为空，其他条件不能为空，都为空不予执行 * @return * @throws Exception */boolean update(T entity) throws Exception;</code></pre><p>利用这套基础的 API，后面我又基于 Redis、MongoDB、ElasticSearch、Hive、HBase 各封装了一套，以此来降低团队的学习成本，也大大提升了程序的可控性，更方便统一监控。</p><h2 id="2-搭建基础架构"><a href="#2-搭建基础架构" class="headerlink" title="2 搭建基础架构#"></a>2 搭建基础架构<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#2--%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84">#</a></h2><h3 id="2-1-Page"><a href="#2-1-Page" class="headerlink" title="2.1 Page#"></a>2.1 Page<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#21--page">#</a></h3><p>定义 Page 类的主要目的是为后面的分页查询统一返回结果做顶层支持，其主要功能包括分页逻辑的封装、分页数据。</p><pre><code>package javax.core.common;import java.io.Serializable;import java.util.ArrayList;import java.util.List;/** * 分页对象，包含当前页数据及分页信息，如总记录数 * 能够支持和JQuery EasyUI直接对接，能够支持和BootStrap Table直接对接 */public class Page&lt;T&gt; implements Serializable &#123;   private static final long serialVersionUID = 1L;   private static final int DEFAULT_PAGE_SIZE = 20;   private int pageSize = DEFAULT_PAGE_SIZE; //每页的记录数   private long start; //当前页第一条数据在List中的位置，从0开始   private List&lt;T&gt; rows; //当前页中存放的记录，类型一般为List   private long total; //总记录数   /**    * 构造方法，只构造空页    */   public Page() &#123;      this(0, 0, DEFAULT_PAGE_SIZE, new ArrayList&lt;T&gt;());   &#125;   /**    * 默认构造方法    *    * @param start 本页数据在数据库中的起始位置    * @param totalSize 数据库中总记录条数    * @param pageSize 本页容量    * @param rows 本页包含的数据    */   public Page(long start, long totalSize, int pageSize, List&lt;T&gt; rows) &#123;      this.pageSize = pageSize;      this.start = start;      this.total = totalSize;      this.rows = rows;   &#125;   /**    * 取总记录数    */   public long getTotal() &#123;      return this.total;   &#125;   public void setTotal(long total) &#123;      this.total = total;   &#125;   /**    * 取总页数    */   public long getTotalPageCount() &#123;      if (total % pageSize == 0)&#123;         return total / pageSize;      &#125;else&#123;         return total / pageSize + 1;      &#125;   &#125;   /**    * 取每页数据容量    */   public int getPageSize() &#123;      return pageSize;   &#125;   /**    * 取当前页中的记录    */   public List&lt;T&gt; getRows() &#123;      return rows;   &#125;   public void setRows(List&lt;T&gt; rows) &#123;      this.rows = rows;   &#125;   /**    * 取该页的当前页码，页码从1开始    */   public long getPageNo() &#123;      return start / pageSize + 1;   &#125;   /**    * 该页是否有下一页    */   public boolean hasNextPage() &#123;      return this.getPageNo() &lt; this.getTotalPageCount() - 1;   &#125;   /**    * 该页是否有上一页    */   public boolean hasPreviousPage() &#123;      return this.getPageNo() &gt; 1;   &#125;   /**    * 获取任意一页第一条数据在数据集中的位置，每页条数使用默认值    *    * @see #getStartOfPage(int,int)    */   protected static int getStartOfPage(int pageNo) &#123;      return getStartOfPage(pageNo, DEFAULT_PAGE_SIZE);   &#125;   /**    * 获取任意一页第一条数据在数据集中的位置    *    * @param pageNo 从1开始的页号    * @param pageSize 每页记录条数    * @return 该页第一条数据    */   public static int getStartOfPage(int pageNo, int pageSize) &#123;      return (pageNo - 1) * pageSize;   &#125;&#125;</code></pre><p>​</p><h3 id="2-2-ResultMsg"><a href="#2-2-ResultMsg" class="headerlink" title="2.2 ResultMsg#"></a>2.2 ResultMsg<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#22--resultmsg">#</a></h3><pre><code>ResultMsg类主要是为统一返回结果做的顶层设计，主要包括状态码、结果说明内容和返回数据。</code></pre><p>​<br> package javax.core.common;</p><pre><code>import java.io.Serializable;//底层设计public class ResultMsg&lt;T&gt; implements Serializable &#123;   private static final long serialVersionUID = 2635002588308355785L;   private int status; //状态码，系统的返回码   private String msg;  //状态码的解释   private T data;  //放任意结果   public ResultMsg() &#123;&#125;   public ResultMsg(int status) &#123;      this.status = status;   &#125;   public ResultMsg(int status, String msg) &#123;      this.status = status;      this.msg = msg;   &#125;   public ResultMsg(int status, T data) &#123;      this.status = status;      this.data = data;   &#125;   public ResultMsg(int status, String msg, T data) &#123;      this.status = status;      this.msg = msg;      this.data = data;   &#125;   public int getStatus() &#123;      return status;   &#125;   public void setStatus(int status) &#123;      this.status = status;   &#125;   public String getMsg() &#123;      return msg;   &#125;   public void setMsg(String msg) &#123;      this.msg = msg;   &#125;   public T getData() &#123;      return data;   &#125;   public void setData(T data) &#123;      this.data = data;   &#125;&#125;</code></pre><h3 id="2-3-BaseDao"><a href="#2-3-BaseDao" class="headerlink" title="2.3 BaseDao#"></a>2.3 BaseDao<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#23--basedao">#</a></h3><p>作为所有 BaseDao 持久化框架的顶层接口，主要定义增、删、改、查统一的参数列表和返回值。</p><pre><code>package javax.core.common.jdbc;import com.gupaoedu.vip.orm.framework.QueryRule;import javax.core.common.Page;import java.util.List;import java.util.Map;public interface BaseDao&lt;T,PK&gt; &#123;    /**     * 获取列表     * @param queryRule 查询条件     * @return     */    List&lt;T&gt; select(QueryRule queryRule) throws Exception;    /**     * 获取分页结果     * @param queryRule 查询条件     * @param pageNo 页码     * @param pageSize 每页条数     * @return     */    Page&lt;?&gt; select(QueryRule queryRule,int pageNo,int pageSize) throws Exception;    /**     * 根据SQL获取列表     * @param sql SQL语句     * @param args 参数     * @return     */    List&lt;Map&lt;String,Object&gt;&gt; selectBySql(String sql, Object... args) throws Exception;    /**     * 根据SQL获取分页     * @param sql SQL语句     * @param pageNo 页码     * @param pageSize 每页条数     * @return     */    Page&lt;Map&lt;String,Object&gt;&gt; selectBySqlToPage(String sql, Object [] param, int pageNo, int pageSize) throws Exception;    /**     * 删除一条记录     * @param entity entity中的ID不能为空，如果ID为空，其他条件不能为空，都为空则不予执行     * @return     */    boolean delete(T entity) throws Exception;    /**     * 批量删除     * @param list     * @return 返回受影响的行数     * @throws Exception     */    int deleteAll(List&lt;T&gt; list) throws Exception;    /**     * 插入一条记录并返回插入后的ID     * @param entity 只要entity不等于null，就执行插入操作     * @return     */    PK insertAndReturnId(T entity) throws Exception;    /**     * 插入一条记录自增ID     * @param entity     * @return     * @throws Exception     */    boolean insert(T entity) throws Exception;    /**     * 批量插入     * @param list     * @return 返回受影响的行数     * @throws Exception     */    int insertAll(List&lt;T&gt; list) throws Exception;    /**     *  修改一条记录     * @param entity entity中的ID不能为空，如果ID为空，其他条件不能为空，都为空则不予执行     * @return     * @throws Exception     */    boolean update(T entity) throws Exception;&#125;### 2.4 QueryRule[#](https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#24--queryrule)</code></pre><p>如果用 QueryRule 类来构建查询条件，用户在做条件查询时不需要手写 SQL，实现业务代码与 SQL 解耦。</p><pre><code>package com.gupaoedu.vip.orm.framework;import java.io.Serializable;import java.util.ArrayList;import java.util.List;/** * QueryRule，主要功能用于构造查询条件 */public final class QueryRule implements Serializable&#123;   private static final long serialVersionUID = 1L;   public static final int ASC_ORDER = 101;   public static final int DESC_ORDER = 102;   public static final int LIKE = 1;   public static final int IN = 2;   public static final int NOTIN = 3;   public static final int BETWEEN = 4;   public static final int EQ = 5;   public static final int NOTEQ = 6;   public static final int GT = 7;   public static final int GE = 8;   public static final int LT = 9;   public static final int LE = 10;   public static final int ISNULL = 11;   public static final int ISNOTNULL = 12;   public static final int ISEMPTY = 13;   public static final int ISNOTEMPTY = 14;   public static final int AND = 201;   public static final int OR = 202;   private List&lt;Rule&gt; ruleList = new ArrayList&lt;Rule&gt;();   private List&lt;QueryRule&gt; queryRuleList = new ArrayList&lt;QueryRule&gt;();   private String propertyName;   private QueryRule() &#123;&#125;   private QueryRule(String propertyName) &#123;      this.propertyName = propertyName;   &#125;   public static QueryRule getInstance() &#123;      return new QueryRule();   &#125;   /**    * 添加升序规则    * @param propertyName    * @return    */   public QueryRule addAscOrder(String propertyName) &#123;      this.ruleList.add(new Rule(ASC_ORDER, propertyName));      return this;   &#125;   /**    * 添加降序规则    * @param propertyName    * @return    */   public QueryRule addDescOrder(String propertyName) &#123;      this.ruleList.add(new Rule(DESC_ORDER, propertyName));      return this;   &#125;   public QueryRule andIsNull(String propertyName) &#123;      this.ruleList.add(new Rule(ISNULL, propertyName).setAndOr(AND));      return this;   &#125;   public QueryRule andIsNotNull(String propertyName) &#123;      this.ruleList.add(new Rule(ISNOTNULL, propertyName).setAndOr(AND));      return this;   &#125;   public QueryRule andIsEmpty(String propertyName) &#123;      this.ruleList.add(new Rule(ISEMPTY, propertyName).setAndOr(AND));      return this;   &#125;   public QueryRule andIsNotEmpty(String propertyName) &#123;      this.ruleList.add(new Rule(ISNOTEMPTY, propertyName).setAndOr(AND));      return this;   &#125;   public QueryRule andLike(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(LIKE, propertyName, new Object[] &#123; value &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule andEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(EQ, propertyName, new Object[] &#123; value &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule andBetween(String propertyName, Object... values) &#123;      this.ruleList.add(new Rule(BETWEEN, propertyName, values).setAndOr(AND));      return this;   &#125;   public QueryRule andIn(String propertyName, List&lt;Object&gt; values) &#123;      this.ruleList.add(new Rule(IN, propertyName, new Object[] &#123; values &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule andIn(String propertyName, Object... values) &#123;      this.ruleList.add(new Rule(IN, propertyName, values).setAndOr(AND));      return this;   &#125;   public QueryRule andNotIn(String propertyName, List&lt;Object&gt; values) &#123;      this.ruleList.add(new Rule(NOTIN, propertyName, new Object[] &#123; values &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule orNotIn(String propertyName, Object... values) &#123;      this.ruleList.add(new Rule(NOTIN, propertyName, values).setAndOr(OR));      return this;   &#125;   public QueryRule andNotEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(NOTEQ, propertyName, new Object[] &#123; value &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule andGreaterThan(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(GT, propertyName, new Object[] &#123; value &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule andGreaterEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(GE, propertyName, new Object[] &#123; value &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule andLessThan(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(LT, propertyName, new Object[] &#123; value &#125;).setAndOr(AND));      return this;   &#125;   public QueryRule andLessEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(LE, propertyName, new Object[] &#123; value &#125;).setAndOr(AND));      return this;   &#125;</code></pre><p>​<br> public QueryRule orIsNull(String propertyName) {<br>this.ruleList.add(new Rule(ISNULL, propertyName).setAndOr(OR));<br>return this;<br>}</p><pre><code>   public QueryRule orIsNotNull(String propertyName) &#123;      this.ruleList.add(new Rule(ISNOTNULL, propertyName).setAndOr(OR));      return this;   &#125;   public QueryRule orIsEmpty(String propertyName) &#123;      this.ruleList.add(new Rule(ISEMPTY, propertyName).setAndOr(OR));      return this;   &#125;   public QueryRule orIsNotEmpty(String propertyName) &#123;      this.ruleList.add(new Rule(ISNOTEMPTY, propertyName).setAndOr(OR));      return this;   &#125;   public QueryRule orLike(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(LIKE, propertyName, new Object[] &#123; value &#125;).setAndOr(OR));      return this;   &#125;   public QueryRule orEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(EQ, propertyName, new Object[] &#123; value &#125;).setAndOr(OR));      return this;   &#125;   public QueryRule orBetween(String propertyName, Object... values) &#123;      this.ruleList.add(new Rule(BETWEEN, propertyName, values).setAndOr(OR));      return this;   &#125;   public QueryRule orIn(String propertyName, List&lt;Object&gt; values) &#123;      this.ruleList.add(new Rule(IN, propertyName, new Object[] &#123; values &#125;).setAndOr(OR));      return this;   &#125;   public QueryRule orIn(String propertyName, Object... values) &#123;      this.ruleList.add(new Rule(IN, propertyName, values).setAndOr(OR));      return this;   &#125;   public QueryRule orNotEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(NOTEQ, propertyName, new Object[] &#123; value &#125;).setAndOr(OR));      return this;   &#125;   public QueryRule orGreaterThan(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(GT, propertyName, new Object[] &#123; value &#125;).setAndOr(OR));      return this;   &#125;   public QueryRule orGreaterEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(GE, propertyName, new Object[] &#123; value &#125;).setAndOr(OR));      return this;   &#125;   public QueryRule orLessThan(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(LT, propertyName, new Object[] &#123; value &#125;).setAndOr(OR));      return this;   &#125;   public QueryRule orLessEqual(String propertyName, Object value) &#123;      this.ruleList.add(new Rule(LE, propertyName, new Object[] &#123; value &#125;).setAndOr(OR));      return this;   &#125;   public List&lt;Rule&gt; getRuleList() &#123;      return this.ruleList;   &#125;   public List&lt;QueryRule&gt; getQueryRuleList() &#123;      return this.queryRuleList;   &#125;   public String getPropertyName() &#123;      return this.propertyName;   &#125;   protected class Rule implements Serializable &#123;      private static final long serialVersionUID = 1L;      private int type;  //规则的类型      private String property_name;      private Object[] values;      private int andOr = AND;      public Rule(int paramInt, String paramString) &#123;         this.property_name = paramString;         this.type = paramInt;      &#125;      public Rule(int paramInt, String paramString,            Object[] paramArrayOfObject) &#123;         this.property_name = paramString;         this.values = paramArrayOfObject;         this.type = paramInt;      &#125;      public Rule setAndOr(int andOr)&#123;         this.andOr = andOr;         return this;      &#125;      public int getAndOr()&#123;         return this.andOr;      &#125;      public Object[] getValues() &#123;         return this.values;      &#125;      public int getType() &#123;         return this.type;      &#125;      public String getPropertyName() &#123;         return this.property_name;      &#125;   &#125;&#125;</code></pre><h3 id="2-5-Order"><a href="#2-5-Order" class="headerlink" title="2.5 Order#"></a>2.5 Order<a href="https://www.cnblogs.com/gupaoedu-tom/p/15697485.html#25--order">#</a></h3><p>Order 类主要用于封装排序规则，代码如下：</p><pre><code>package com.gupaoedu.vip.orm.framework;/** * SQL排序组件 */public class Order &#123;   private boolean ascending; //升序还是降序   private String propertyName; //哪个字段升序，哪个字段降序   public String toString() &#123;      return propertyName + &#39; &#39; + (ascending ? &quot;asc&quot; : &quot;desc&quot;);   &#125;   /**    * Constructor for Order.    */   protected Order(String propertyName, boolean ascending) &#123;      this.propertyName = propertyName;      this.ascending = ascending;   &#125;   /**    * Ascending order    *    * @param propertyName    * @return Order    */   public static Order asc(String propertyName) &#123;      return new Order(propertyName, true);   &#125;   /**    * Descending order    *    * @param propertyName    * @return Order    */   public static Order desc(String propertyName) &#123;      return new Order(propertyName, false);   &#125;&#125;</code></pre><h2 id="3-基于-Spring-JDBC-实现关键功能"><a href="#3-基于-Spring-JDBC-实现关键功能" class="headerlink" title="3 基于 Spring JDBC 实现关键功能#"></a>3 基于 Spring JDBC 实现关键功能<a href="https://www.cnblogs.com/gupaoedu-tom/p/15702051.html#3--%E5%9F%BA%E4%BA%8Espring-jdbc%E5%AE%9E%E7%8E%B0%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD">#</a></h2><h3 id="3-1-ClassMappings"><a href="#3-1-ClassMappings" class="headerlink" title="3.1 ClassMappings#"></a>3.1 ClassMappings<a href="https://www.cnblogs.com/gupaoedu-tom/p/15702051.html#31--classmappings">#</a></h3><p>ClassMappings 主要定义基础的映射类型，代码如下：</p><pre><code>package com.tom.orm.framework;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.math.BigDecimal;import java.sql.Date;import java.sql.Timestamp;import java.util.Arrays;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;public class ClassMappings &#123;   private ClassMappings()&#123;&#125;    static final Set&lt;Class&lt;?&gt;&gt; SUPPORTED_SQL_OBJECTS = new HashSet&lt;Class&lt;?&gt;&gt;();       static &#123;          //只要这里写了，默认支持自动类型转换           Class&lt;?&gt;[] classes = &#123;                   boolean.class, Boolean.class,                   short.class, Short.class,                   int.class, Integer.class,                   long.class, Long.class,                   float.class, Float.class,                   double.class, Double.class,                   String.class,                   Date.class,                   Timestamp.class,                   BigDecimal.class           &#125;;           SUPPORTED_SQL_OBJECTS.addAll(Arrays.asList(classes));       &#125;       static boolean isSupportedSQLObject(Class&lt;?&gt; clazz) &#123;           return clazz.isEnum() || SUPPORTED_SQL_OBJECTS.contains(clazz);       &#125;       public static Map&lt;String, Method&gt; findPublicGetters(Class&lt;?&gt; clazz) &#123;           Map&lt;String, Method&gt; map = new HashMap&lt;String, Method&gt;();           Method[] methods = clazz.getMethods();           for (Method method : methods) &#123;               if (Modifier.isStatic(method.getModifiers()))                   continue;               if (method.getParameterTypes().length != 0)                   continue;               if (method.getName().equals(&quot;getClass&quot;))                   continue;               Class&lt;?&gt; returnType = method.getReturnType();               if (void.class.equals(returnType))                   continue;               if(!isSupportedSQLObject(returnType))&#123;                  continue;               &#125;               if ((returnType.equals(boolean.class)                       || returnType.equals(Boolean.class))                       &amp;&amp; method.getName().startsWith(&quot;is&quot;)                       &amp;&amp; method.getName().length() &gt; 2) &#123;                   map.put(getGetterName(method), method);                   continue;               &#125;               if ( ! method.getName().startsWith(&quot;get&quot;))                   continue;               if (method.getName().length() &lt; 4)                   continue;               map.put(getGetterName(method), method);           &#125;           return map;       &#125;       public static Field[] findFields(Class&lt;?&gt; clazz)&#123;           return clazz.getDeclaredFields();       &#125;       public static Map&lt;String, Method&gt; findPublicSetters(Class&lt;?&gt; clazz) &#123;           Map&lt;String, Method&gt; map = new HashMap&lt;String, Method&gt;();           Method[] methods = clazz.getMethods();           for (Method method : methods) &#123;               if (Modifier.isStatic(method.getModifiers()))                   continue;               if ( ! void.class.equals(method.getReturnType()))                   continue;               if (method.getParameterTypes().length != 1)                   continue;               if ( ! method.getName().startsWith(&quot;set&quot;))                   continue;               if (method.getName().length() &lt; 4)                   continue;               if(!isSupportedSQLObject(method.getParameterTypes()[0]))&#123;                  continue;               &#125;               map.put(getSetterName(method), method);           &#125;           return map;       &#125;       public static String getGetterName(Method getter) &#123;           String name = getter.getName();           if (name.startsWith(&quot;is&quot;))               name = name.substring(2);           else               name = name.substring(3);           return Character.toLowerCase(name.charAt(0)) + name.substring(1);       &#125;       private static String getSetterName(Method setter) &#123;           String name = setter.getName().substring(3);           return Character.toLowerCase(name.charAt(0)) + name.substring(1);       &#125;&#125;</code></pre><h3 id="3-2-EntityOperation"><a href="#3-2-EntityOperation" class="headerlink" title="3.2 EntityOperation#"></a>3.2 EntityOperation<a href="https://www.cnblogs.com/gupaoedu-tom/p/15702051.html#32--entityoperation">#</a></h3><p>EntityOperation 主要实现数据库表结构和对象类结构的映射关系，代码如下：</p><pre><code>package com.tom.orm.framework;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.HashMap;import java.util.Map;import java.util.TreeMap;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import javax.persistence.Transient;import org.apache.log4j.Logger;import org.springframework.jdbc.core.RowMapper;import javax.core.common.utils.StringUtils;/** * 实体对象的反射操作 * * @param &lt;T&gt; */public class EntityOperation&lt;T&gt; &#123;   private Logger log = Logger.getLogger(EntityOperation.class);   public Class&lt;T&gt; entityClass = null; // 泛型实体Class对象   public final Map&lt;String, PropertyMapping&gt; mappings;   public final RowMapper&lt;T&gt; rowMapper;   public final String tableName;   public String allColumn = &quot;*&quot;;   public Field pkField;   public EntityOperation(Class&lt;T&gt; clazz,String pk) throws Exception&#123;      if(!clazz.isAnnotationPresent(Entity.class))&#123;         throw new Exception(&quot;在&quot; + clazz.getName() + &quot;中没有找到Entity注解，不能做ORM映射&quot;);      &#125;      this.entityClass = clazz;      Table table = entityClass.getAnnotation(Table.class);       if (table != null) &#123;             this.tableName = table.name();       &#125; else &#123;             this.tableName =  entityClass.getSimpleName();       &#125;      Map&lt;String, Method&gt; getters = ClassMappings.findPublicGetters(entityClass);       Map&lt;String, Method&gt; setters = ClassMappings.findPublicSetters(entityClass);       Field[] fields = ClassMappings.findFields(entityClass);       fillPkFieldAndAllColumn(pk,fields);       this.mappings = getPropertyMappings(getters, setters, fields);       this.allColumn = this.mappings.keySet().toString().replace(&quot;[&quot;, &quot;&quot;).replace(&quot;]&quot;,&quot;&quot;). replaceAll(&quot; &quot;,&quot;&quot;);       this.rowMapper = createRowMapper();   &#125;    Map&lt;String, PropertyMapping&gt; getPropertyMappings(Map&lt;String, Method&gt; getters, Map&lt;String, Method&gt; setters, Field[] fields) &#123;        Map&lt;String, PropertyMapping&gt; mappings = new HashMap&lt;String, PropertyMapping&gt;();        String name;        for (Field field : fields) &#123;            if (field.isAnnotationPresent(Transient.class))                continue;            name = field.getName();            if(name.startsWith(&quot;is&quot;))&#123;               name = name.substring(2);            &#125;            name = Character.toLowerCase(name.charAt(0)) + name.substring(1);            Method setter = setters.get(name);            Method getter = getters.get(name);            if (setter == null || getter == null)&#123;                continue;            &#125;            Column column = field.getAnnotation(Column.class);            if (column == null) &#123;                mappings.put(field.getName(), new PropertyMapping(getter, setter, field));            &#125; else &#123;                mappings.put(column.name(), new PropertyMapping(getter, setter, field));            &#125;        &#125;        return mappings;    &#125;   RowMapper&lt;T&gt; createRowMapper() &#123;           return new RowMapper&lt;T&gt;() &#123;               public T mapRow(ResultSet rs, int rowNum) throws SQLException &#123;                   try &#123;                       T t = entityClass.newInstance();                       ResultSetMetaData meta = rs.getMetaData();                       int columns = meta.getColumnCount();                       String columnName;                       for (int i = 1; i &lt;= columns; i++) &#123;                           Object value = rs.getObject(i);                           columnName = meta.getColumnName(i);                           fillBeanFieldValue(t,columnName,value);                       &#125;                       return t;                   &#125;catch (Exception e) &#123;                       throw new RuntimeException(e);                   &#125;               &#125;           &#125;;       &#125;   protected void fillBeanFieldValue(T t, String columnName, Object value) &#123;       if (value != null) &#123;             PropertyMapping pm = mappings.get(columnName);             if (pm != null) &#123;                 try &#123;               pm.set(t, value);            &#125; catch (Exception e) &#123;               e.printStackTrace();            &#125;             &#125;         &#125;   &#125;   private void fillPkFieldAndAllColumn(String pk, Field[] fields) &#123;      //设定主键       try &#123;          if(!StringUtils.isEmpty(pk))&#123;             pkField = entityClass.getDeclaredField(pk);             pkField.setAccessible(true);          &#125;       &#125; catch (Exception e) &#123;             log.debug(&quot;没找到主键列，主键列名必须与属性名相同&quot;);       &#125;      for (int i = 0 ; i &lt; fields.length ;i ++) &#123;         Field f = fields[i];         if(StringUtils.isEmpty(pk))&#123;            Id id = f.getAnnotation(Id.class);            if(id != null)&#123;               pkField = f;               break;            &#125;         &#125;      &#125;   &#125;   public T parse(ResultSet rs) &#123;      T t = null;      if (null == rs) &#123;         return null;      &#125;      Object value = null;      try &#123;         t = (T) entityClass.newInstance();         for (String columnName : mappings.keySet()) &#123;            try &#123;               value = rs.getObject(columnName);            &#125; catch (Exception e) &#123;               e.printStackTrace();            &#125;            fillBeanFieldValue(t,columnName,value);         &#125;      &#125; catch (Exception ex) &#123;         ex.printStackTrace();      &#125;      return t;   &#125;   public Map&lt;String, Object&gt; parse(T t) &#123;      Map&lt;String, Object&gt; _map = new TreeMap&lt;String, Object&gt;();      try &#123;         for (String columnName : mappings.keySet()) &#123;            Object value = mappings.get(columnName).getter.invoke(t);            if (value == null)               continue;            _map.put(columnName, value);         &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();      &#125;      return _map;   &#125;   public void println(T t) &#123;      try &#123;         for (String columnName : mappings.keySet()) &#123;            Object value = mappings.get(columnName).getter.invoke(t);            if (value == null)               continue;            System.out.println(columnName + &quot; = &quot; + value);         &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();      &#125;   &#125;&#125;class PropertyMapping &#123;    final boolean insertable;    final boolean updatable;    final String columnName;    final boolean id;    final Method getter;    final Method setter;    final Class enumClass;    final String fieldName;    public PropertyMapping(Method getter, Method setter, Field field) &#123;        this.getter = getter;        this.setter = setter;        this.enumClass = getter.getReturnType().isEnum() ? getter.getReturnType() : null;        Column column = field.getAnnotation(Column.class);        this.insertable = column == null || column.insertable();        this.updatable = column == null || column.updatable();        this.columnName = column == null ? ClassMappings.getGetterName(getter) : (&quot;&quot;.equals(column.name()) ? ClassMappings.getGetterName    (getter) : column.name());        this.id = field.isAnnotationPresent(Id.class);        this.fieldName = field.getName();    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    Object get(Object target) throws Exception &#123;        Object r = getter.invoke(target);        return enumClass == null ? r : Enum.valueOf(enumClass, (String) r);    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    void set(Object target, Object value) throws Exception &#123;        if (enumClass != null &amp;&amp; value != null) &#123;            value = Enum.valueOf(enumClass, (String) value);        &#125;        //BeanUtils.setProperty(target, fieldName, value);        try &#123;            if(value != null)&#123;                setter.invoke(target, setter.getParameterTypes()[0].cast(value));             &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();         /**          * 出错原因如果是boolean字段、mysql字段类型，设置tinyint(1)          */         System.err.println(fieldName + &quot;--&quot; + value);      &#125;    &#125;&#125;</code></pre><h3 id="3-3-QueryRuleSqlBuilder"><a href="#3-3-QueryRuleSqlBuilder" class="headerlink" title="3.3 QueryRuleSqlBuilder#"></a>3.3 QueryRuleSqlBuilder<a href="https://www.cnblogs.com/gupaoedu-tom/p/15702051.html#33--queryrulesqlbuilder">#</a></h3><p>QueryRuleSqlBuilder 根据用户构建好的 QueryRule 来自动生成 SQL 语句，代码如下：</p><pre><code>package com.tom.orm.framework;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.commons.lang.ArrayUtils;import com.tom.orm.framework.QueryRule.Rule;import javax.core.common.utils.StringUtils;</code></pre><p>​<br> /**<br>_ 根据 QueryRule 自动构建 SQL 语句<br>_/<br>public class QueryRuleSqlBuilder {</p><pre><code>   private int CURR_INDEX = 0; //记录参数所在的位置   private List&lt;String&gt; properties; //保存列名列表   private List&lt;Object&gt; values; //保存参数值列表   private List&lt;Order&gt; orders; //保存排序规则列表   private String whereSql = &quot;&quot;;   private String orderSql = &quot;&quot;;   private Object [] valueArr = new Object[]&#123;&#125;;   private Map&lt;Object,Object&gt; valueMap = new HashMap&lt;Object,Object&gt;();   /**    * 获得查询条件    * @return    */   public String getWhereSql()&#123;      return this.whereSql;   &#125;   /**    * 获得排序条件    * @return    */   public String getOrderSql()&#123;      return this.orderSql;   &#125;   /**    * 获得参数值列表    * @return    */   public Object [] getValues()&#123;      return this.valueArr;   &#125;   /**    * 获取参数列表    * @return    */   public Map&lt;Object,Object&gt; getValueMap()&#123;      return this.valueMap;   &#125;   /**    * 创建SQL构造器    * @param queryRule    */   public  QueryRuleSqlBuilder(QueryRule queryRule) &#123;      CURR_INDEX = 0;      properties = new ArrayList&lt;String&gt;();      values = new ArrayList&lt;Object&gt;();      orders = new ArrayList&lt;Order&gt;();      for (QueryRule.Rule rule : queryRule.getRuleList()) &#123;         switch (rule.getType()) &#123;         case QueryRule.BETWEEN:            processBetween(rule);            break;         case QueryRule.EQ:            processEqual(rule);            break;         case QueryRule.LIKE:            processLike(rule);            break;         case QueryRule.NOTEQ:            processNotEqual(rule);            break;         case QueryRule.GT:            processGreaterThen(rule);            break;         case QueryRule.GE:            processGreaterEqual(rule);            break;         case QueryRule.LT:            processLessThen(rule);            break;         case QueryRule.LE:            processLessEqual(rule);            break;         case QueryRule.IN:            processIN(rule);            break;         case QueryRule.NOTIN:            processNotIN(rule);            break;         case QueryRule.ISNULL:            processIsNull(rule);            break;         case QueryRule.ISNOTNULL:            processIsNotNull(rule);            break;         case QueryRule.ISEMPTY:            processIsEmpty(rule);            break;         case QueryRule.ISNOTEMPTY:            processIsNotEmpty(rule);            break;         case QueryRule.ASC_ORDER:            processOrder(rule);            break;         case QueryRule.DESC_ORDER:            processOrder(rule);            break;         default:            throw new IllegalArgumentException(&quot;type &quot; + rule.getType() + &quot; not supported.&quot;);         &#125;      &#125;      //拼装where语句      appendWhereSql();      //拼装排序语句      appendOrderSql();      //拼装参数值      appendValues();   &#125;   /**    * 去掉order    *    * @param sql    * @return    */   protected String removeOrders(String sql) &#123;      Pattern p = Pattern.compile(&quot;order\\s*by[\\w|\\W|\\s|\\S]*&quot;, Pattern.CASE_INSENSITIVE);      Matcher m = p.matcher(sql);      StringBuffer sb = new StringBuffer();      while (m.find()) &#123;         m.appendReplacement(sb, &quot;&quot;);      &#125;      m.appendTail(sb);      return sb.toString();   &#125;   /**    * 去掉select    *    * @param sql    * @return    */   protected String removeSelect(String sql) &#123;      if(sql.toLowerCase().matches(&quot;from\\s+&quot;))&#123;         int beginPos = sql.toLowerCase().indexOf(&quot;from&quot;);         return sql.substring(beginPos);      &#125;else&#123;         return sql;      &#125;   &#125;   /**    * 处理like    * @param rule    */   private  void processLike(QueryRule.Rule rule) &#123;      if (ArrayUtils.isEmpty(rule.getValues())) &#123;         return;      &#125;      Object obj = rule.getValues()[0];      if (obj != null) &#123;         String value = obj.toString();         if (!StringUtils.isEmpty(value)) &#123;            value = value.replace(&#39;*&#39;, &#39;%&#39;);            obj = value;         &#125;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;like&quot;,&quot;%&quot;+rule.getValues()[0]+&quot;%&quot;);   &#125;   /**    * 处理between    * @param rule    */   private  void processBetween(QueryRule.Rule rule) &#123;      if ((ArrayUtils.isEmpty(rule.getValues()))            || (rule.getValues().length &lt; 2)) &#123;         return;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,&quot;between&quot;,rule.getValues()[0],&quot;and&quot;);      add(0,&quot;&quot;,&quot;&quot;,&quot;&quot;,rule.getValues()[1],&quot;&quot;);   &#125;   /**    * 处理 =    * @param rule    */   private  void processEqual(QueryRule.Rule rule) &#123;      if (ArrayUtils.isEmpty(rule.getValues())) &#123;         return;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;=&quot;,rule.getValues()[0]);   &#125;   /**    * 处理 &lt;&gt;    * @param rule    */   private  void processNotEqual(QueryRule.Rule rule) &#123;      if (ArrayUtils.isEmpty(rule.getValues())) &#123;         return;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;&gt;&quot;,rule.getValues()[0]);   &#125;   /**    * 处理 &gt;    * @param rule    */   private  void processGreaterThen(         QueryRule.Rule rule) &#123;      if (ArrayUtils.isEmpty(rule.getValues())) &#123;         return;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;&gt;&quot;,rule.getValues()[0]);   &#125;   /**    * 处理&gt;=    * @param rule    */   private  void processGreaterEqual(         QueryRule.Rule rule) &#123;      if (ArrayUtils.isEmpty(rule.getValues())) &#123;         return;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;&gt;=&quot;,rule.getValues()[0]);   &#125;   /**    * 处理&lt;    * @param rule    */   private  void processLessThen(QueryRule.Rule rule) &#123;      if (ArrayUtils.isEmpty(rule.getValues())) &#123;         return;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;&quot;,rule.getValues()[0]);   &#125;   /**    * 处理&lt;=    * @param rule    */   private  void processLessEqual(         QueryRule.Rule rule) &#123;      if (ArrayUtils.isEmpty(rule.getValues())) &#123;         return;      &#125;      add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;=&quot;,rule.getValues()[0]);   &#125;   /**    * 处理  is null    * @param rule    */   private  void processIsNull(QueryRule.Rule rule) &#123;      add(rule.getAndOr(),rule.getPropertyName(),&quot;is null&quot;,null);   &#125;   /**    * 处理 is not null    * @param rule    */   private  void processIsNotNull(QueryRule.Rule rule) &#123;      add(rule.getAndOr(),rule.getPropertyName(),&quot;is not null&quot;,null);   &#125;   /**    * 处理  &lt;&gt;&#39;&#39;    * @param rule    */   private  void processIsNotEmpty(QueryRule.Rule rule) &#123;      add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;&gt;&quot;,&quot;&#39;&#39;&quot;);   &#125;   /**    * 处理 =&#39;&#39;    * @param rule    */   private  void processIsEmpty(QueryRule.Rule rule) &#123;      add(rule.getAndOr(),rule.getPropertyName(),&quot;=&quot;,&quot;&#39;&#39;&quot;);   &#125;</code></pre><p>​<br> /**<br>_ 处理 in 和 not in<br>_ @param rule<br>_ @param name<br>_/<br>private void inAndNotIn(QueryRule.Rule rule,String name){<br>if (ArrayUtils.isEmpty(rule.getValues())) {<br>return;<br>}<br>if ((rule.getValues().length == 1) &amp;&amp; (rule.getValues()[0] != null)<br>&amp;&amp; (rule.getValues()[0] instanceof List)) {<br>List<Object> list = (List) rule.getValues()[0];</p><pre><code>         if ((list != null) &amp;&amp; (list.size() &gt; 0))&#123;            for (int i = 0; i &lt; list.size(); i++) &#123;               if(i == 0 &amp;&amp; i == list.size() - 1)&#123;                  add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list.get(i),&quot;)&quot;);               &#125;else if(i == 0 &amp;&amp; i &lt; list.size() - 1)&#123;                  add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list.get(i),&quot;&quot;);               &#125;               if(i &gt; 0 &amp;&amp; i &lt; list.size() - 1)&#123;                  add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list.get(i),&quot;&quot;);               &#125;               if(i == list.size() - 1 &amp;&amp; i != 0)&#123;                  add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list.get(i),&quot;)&quot;);               &#125;            &#125;         &#125;      &#125; else &#123;         Object[] list =  rule.getValues();         for (int i = 0; i &lt; list.length; i++) &#123;            if(i == 0 &amp;&amp; i == list.length - 1)&#123;               add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list[i],&quot;)&quot;);            &#125;else if(i == 0 &amp;&amp; i &lt; list.length - 1)&#123;               add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list[i],&quot;&quot;);            &#125;            if(i &gt; 0 &amp;&amp; i &lt; list.length - 1)&#123;               add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list[i],&quot;&quot;);            &#125;            if(i == list.length - 1 &amp;&amp; i != 0)&#123;               add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list[i],&quot;)&quot;);            &#125;         &#125;      &#125;   &#125;   /**    * 处理 not in    * @param rule    */   private void processNotIN(QueryRule.Rule rule)&#123;      inAndNotIn(rule,&quot;not in&quot;);   &#125;   /**    * 处理 in    * @param rule    */   private  void processIN(QueryRule.Rule rule) &#123;      inAndNotIn(rule,&quot;in&quot;);   &#125;   /**    * 处理 order by    * @param rule 查询规则    */   private void processOrder(Rule rule) &#123;      switch (rule.getType()) &#123;      case QueryRule.ASC_ORDER:         //propertyName非空         if (!StringUtils.isEmpty(rule.getPropertyName())) &#123;            orders.add(Order.asc(rule.getPropertyName()));         &#125;         break;      case QueryRule.DESC_ORDER:         //propertyName非空         if (!StringUtils.isEmpty(rule.getPropertyName())) &#123;            orders.add(Order.desc(rule.getPropertyName()));         &#125;         break;      default:         break;      &#125;   &#125;</code></pre><p>​<br> /**<br>_ 加入 SQL 查询规则队列<br>_ @param andOr and 或者 or<br>_ @param key 列名<br>_ @param split 列名与值之间的间隔<br>_ @param value 值<br>_/<br>private void add(int andOr,String key,String split ,Object value){<br>add(andOr,key,split,””,value,””);<br>}</p><pre><code>   /**    * 加入SQL查询规则队列    * @param andOr and 或则 or    * @param key 列名    * @param split 列名与值之间的间隔    * @param prefix 值前缀    * @param value 值    * @param suffix 值后缀    */   private void add(int andOr,String key,String split,String prefix,Object value,String suffix)&#123;      String andOrStr = (0 == andOr ? &quot;&quot; :(QueryRule.AND == andOr ? &quot; and &quot; : &quot; or &quot;));      properties.add(CURR_INDEX, andOrStr + key + &quot; &quot; + split + prefix + (null != value ? &quot; ? &quot; : &quot; &quot;) + suffix);      if(null != value)&#123;         values.add(CURR_INDEX,value);         CURR_INDEX ++;      &#125;   &#125;</code></pre><p>​<br> /**<br>_ 拼装 where 语句<br>_/<br>private void appendWhereSql(){<br>StringBuffer whereSql = new StringBuffer();<br>for (String p : properties) {<br>whereSql.append(p);<br>}<br>this.whereSql = removeSelect(removeOrders(whereSql.toString()));<br>}</p><pre><code>   /**    * 拼装排序语句    */   private void appendOrderSql()&#123;      StringBuffer orderSql = new StringBuffer();      for (int i = 0 ; i &lt; orders.size(); i ++) &#123;         if(i &gt; 0 &amp;&amp; i &lt; orders.size())&#123;            orderSql.append(&quot;,&quot;);         &#125;         orderSql.append(orders.get(i).toString());      &#125;      this.orderSql = removeSelect(removeOrders(orderSql.toString()));   &#125;   /**    * 拼装参数值    */   private void appendValues()&#123;      Object [] val = new Object[values.size()];      for (int i = 0; i &lt; values.size(); i ++) &#123;         val[i] = values.get(i);         valueMap.put(i, values.get(i));      &#125;      this.valueArr = val;   &#125;&#125;</code></pre><h3 id="3-4-BaseDaoSupport"><a href="#3-4-BaseDaoSupport" class="headerlink" title="3.4 BaseDaoSupport#"></a>3.4 BaseDaoSupport<a href="https://www.cnblogs.com/gupaoedu-tom/p/15702051.html#34--basedaosupport">#</a></h3><p>BaseDaoSupport 主要是对 JdbcTemplate 的包装，下面讲一下其重要代码，请“小伙伴们” 关 注 公 众 号 『 Tom 弹架构 』，回复 “ Spring “ 可下载全部源代码。先看全局定义：</p><pre><code>package com.tom.orm.framework;.../** * BaseDao 扩展类，主要功能是支持自动拼装SQL语句，必须继承方可使用 * @author Tom */public abstract class BaseDaoSupport&lt;T extends Serializable, PK extends Serializable&gt; implements BaseDao&lt;T,PK&gt; &#123;   private Logger log = Logger.getLogger(BaseDaoSupport.class);   private String tableName = &quot;&quot;;   private JdbcTemplate jdbcTemplateWrite;   private JdbcTemplate jdbcTemplateReadOnly;   private DataSource dataSourceReadOnly;   private DataSource dataSourceWrite;   private EntityOperation&lt;T&gt; op;   @SuppressWarnings(&quot;unchecked&quot;)   protected BaseDaoSupport()&#123;      try&#123;         Class&lt;T&gt; entityClass = GenericsUtils.getSuperClassGenricType(getClass(), 0);         op = new EntityOperation&lt;T&gt;(entityClass,this.getPKColumn());         this.setTableName(op.tableName);      &#125;catch(Exception e)&#123;         e.printStackTrace();      &#125;   &#125;   protected String getTableName() &#123; return tableName; &#125;   protected DataSource getDataSourceReadOnly() &#123; return dataSourceReadOnly;  &#125;   protected DataSource getDataSourceWrite() &#123; return dataSourceWrite;  &#125;   /**    * 动态切换表名    */   protected void setTableName(String tableName) &#123;      if(StringUtils.isEmpty(tableName))&#123;         this.tableName = op.tableName;      &#125;else&#123;         this.tableName = tableName;      &#125;   &#125;   protected void setDataSourceWrite(DataSource dataSourceWrite) &#123;      this.dataSourceWrite = dataSourceWrite;      jdbcTemplateWrite = new JdbcTemplate(dataSourceWrite);   &#125;   protected void setDataSourceReadOnly(DataSource dataSourceReadOnly) &#123;      this.dataSourceReadOnly = dataSourceReadOnly;      jdbcTemplateReadOnly = new JdbcTemplate(dataSourceReadOnly);   &#125;   private JdbcTemplate jdbcTemplateReadOnly() &#123;      return this.jdbcTemplateReadOnly;   &#125;   private JdbcTemplate jdbcTemplateWrite() &#123;      return this.jdbcTemplateWrite;   &#125;   /**    * 还原默认表名    */   protected void restoreTableName()&#123; this.setTableName(op.tableName);  &#125;   /**    * 获取主键列名称，建议子类重写    * @return    */   protected abstract String getPKColumn();   protected abstract void setDataSource(DataSource dataSource);//此处有省略&#125;</code></pre><p>​<br> 为了照顾程序员的一般使用习惯，查询方法的前缀命名主要有 select、get、load，兼顾 Hibernate 和 MyBatis 的命名风格。</p><p>​<br> /**<br>_ 查询函数，使用查询规则<br>_ 例如以下代码查询条件为匹配的数据 *<br>_ @param queryRule 查询规则<br>_ @return 查询的结果 List<br>*/<br>public List<T> select(QueryRule queryRule) throws Exception{<br>QueryRuleSqlBuilder bulider = new QueryRuleSqlBuilder(queryRule);<br>String ws = removeFirstAnd(bulider.getWhereSql());<br>String whereSql = (“”.equals(ws) ? ws : (“ where “ + ws));<br>String sql = “select “ + op.allColumn + “ from “ + getTableName() + whereSql;<br>Object [] values = bulider.getValues();<br>String orderSql = bulider.getOrderSql();<br>orderSql = (StringUtils.isEmpty(orderSql) ? “ “ : (“ order by “ + orderSql));<br>sql += orderSql;<br>log.debug(sql);<br>return (List<T>) this.jdbcTemplateReadOnly().query(sql, this.op.rowMapper, values);<br>}</p><pre><code>...   /**    * 根据SQL语句执行查询，参数为Object数组对象    * @param sql 查询语句    * @param args 为Object数组    * @return 符合条件的所有对象    */   public List&lt;Map&lt;String,Object&gt;&gt; selectBySql(String sql,Object... args) throws Exception&#123;      return this.jdbcTemplateReadOnly().queryForList(sql,args);   &#125;...   /**    * 分页查询函数，使用查询规则&lt;br&gt;    * 例如以下代码查询条件为匹配的数据    *    * @param queryRule 查询规则    * @param pageNo 页号，从1开始    * @param pageSize 每页的记录条数    * @return 查询的结果Page    */   public Page&lt;T&gt; select(QueryRule queryRule,final int pageNo, final int pageSize) throws Exception&#123;      QueryRuleSqlBuilder bulider = new QueryRuleSqlBuilder(queryRule);      Object [] values = bulider.getValues();      String ws = removeFirstAnd(bulider.getWhereSql());      String whereSql = (&quot;&quot;.equals(ws) ? ws : (&quot; where &quot; + ws));      String countSql = &quot;select count(1) from &quot; + getTableName() + whereSql;      long count = (Long) this.jdbcTemplateReadOnly().queryForMap(countSql, values).get (&quot;count(1)&quot;);      if (count == 0) &#123;         return new Page&lt;T&gt;();      &#125;      long start = (pageNo - 1) * pageSize;      //在有数据的情况下，继续查询      String orderSql = bulider.getOrderSql();      orderSql = (StringUtils.isEmpty(orderSql) ? &quot; &quot; : (&quot; order by &quot; + orderSql));      String sql = &quot;select &quot; + op.allColumn +&quot; from &quot; + getTableName() + whereSql + orderSql + &quot; limit &quot; + start + &quot;,&quot; + pageSize;      List&lt;T&gt; list = (List&lt;T&gt;) this.jdbcTemplateReadOnly().query(sql, this.op.rowMapper, values);      log.debug(sql);      return new Page&lt;T&gt;(start, count, pageSize, list);   &#125;...   /**    * 分页查询特殊SQL语句    * @param sql 语句    * @param param  查询条件    * @param pageNo   页码    * @param pageSize 每页内容    * @return    */   public Page&lt;Map&lt;String,Object&gt;&gt; selectBySqlToPage(String sql, Object [] param, final int pageNo, final int pageSize) throws Exception &#123;      String countSql = &quot;select count(1) from (&quot; + sql + &quot;) a&quot;;      long count = (Long) this.jdbcTemplateReadOnly().queryForMap(countSql,param).get(&quot;count(1)&quot;);      if (count == 0) &#123;         return new Page&lt;Map&lt;String,Object&gt;&gt;();      &#125;      long start = (pageNo - 1) * pageSize;      sql = sql + &quot; limit &quot; + start + &quot;,&quot; + pageSize;      List&lt;Map&lt;String,Object&gt;&gt; list = (List&lt;Map&lt;String,Object&gt;&gt;) this.jdbcTemplateReadOnly(). queryForList(sql, param);      log.debug(sql);      return new Page&lt;Map&lt;String,Object&gt;&gt;(start, count, pageSize, list);   &#125;/**    * 获取默认的实例对象    * @param &lt;T&gt;    * @param pkValue    * @param rowMapper    * @return    */   private &lt;T&gt; T doLoad(Object pkValue, RowMapper&lt;T&gt; rowMapper)&#123;      Object obj = this.doLoad(getTableName(), getPKColumn(), pkValue, rowMapper);      if(obj != null)&#123;         return (T)obj;      &#125;      return null;   &#125;</code></pre><p>​<br>​<br> 插入方法，均以 insert 开头：</p><p>​<br> /**<br>_ 插入并返回 ID<br>_ @param entity<br>_ @return<br>_/<br>public PK insertAndReturnId(T entity) throws Exception{<br>return (PK)this.doInsertRuturnKey(parse(entity));<br>}</p><pre><code>   /**    * 插入一条记录    * @param entity    * @return    */   public boolean insert(T entity) throws Exception&#123;      return this.doInsert(parse(entity));   &#125;/**    * 批量保存对象.&lt;br&gt;    *    * @param list 待保存的对象List    * @throws InvocationTargetException    * @throws IllegalArgumentException    * @throws IllegalAccessException    */   public int insertAll(List&lt;T&gt; list) throws Exception &#123;      int count = 0 ,len = list.size(),step = 50000;      Map&lt;String, PropertyMapping&gt; pm = op.mappings;      int maxPage = (len % step == 0) ? (len / step) : (len / step + 1);      for (int i = 1; i &lt;= maxPage; i ++) &#123;         Page&lt;T&gt; page = pagination(list, i, step);         String sql = &quot;insert into &quot; + getTableName() + &quot;(&quot; + op.allColumn + &quot;) values &quot;;// (&quot; + valstr.toString() + &quot;)&quot;;         StringBuffer valstr = new StringBuffer();         Object[] values = new Object[pm.size() * page.getRows().size()];         for (int j = 0; j &lt; page.getRows().size(); j ++) &#123;            if(j &gt; 0 &amp;&amp; j &lt; page.getRows().size())&#123; valstr.append(&quot;,&quot;); &#125;            valstr.append(&quot;(&quot;);            int k = 0;            for (PropertyMapping p : pm.values()) &#123;               values[(j * pm.size()) + k] = p.getter.invoke(page.getRows().get(j));               if(k &gt; 0 &amp;&amp; k &lt; pm.size())&#123; valstr.append(&quot;,&quot;); &#125;               valstr.append(&quot;?&quot;);               k ++;            &#125;            valstr.append(&quot;)&quot;);         &#125;         int result = jdbcTemplateWrite().update(sql + valstr.toString(), values);         count += result;      &#125;      return count;   &#125;private Serializable doInsertRuturnKey(Map&lt;String,Object&gt; params)&#123;      final List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();      final String sql = makeSimpleInsertSql(getTableName(),params,values);      KeyHolder keyHolder = new GeneratedKeyHolder();      final JdbcTemplate jdbcTemplate = new JdbcTemplate(getDataSourceWrite());        try &#123;             jdbcTemplate.update(new PreparedStatementCreator() &#123;            public PreparedStatement createPreparedStatement(                  Connection con) throws SQLException &#123;               PreparedStatement ps = con.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);               for (int i = 0; i &lt; values.size(); i++) &#123;                  ps.setObject(i+1, values.get(i)==null?null:values.get(i));               &#125;               return ps;             &#125;         &#125;, keyHolder);        &#125; catch (DataAccessException e) &#123;           log.error(&quot;error&quot;,e);        &#125;</code></pre><p>​<br>​<br> if (keyHolder == null) { return “”; }</p><p>​<br> Map&lt;String, Object&gt; keys = keyHolder.getKeys();<br>if (keys == null || keys.size() == 0 || keys.values().size() == 0) {<br>return “”;<br>}<br>Object key = keys.values().toArray()[0];<br>if (key == null || !(key instanceof Serializable)) {<br>return “”;<br>}<br>if (key instanceof Number) {<br>//Long k = (Long) key;<br>Class clazz = key.getClass();<br>// return clazz.cast(key);<br>return (clazz == int.class || clazz == Integer.class) ? ((Number) key).intValue() : ((Number)key).longValue();</p><p>​<br> } else if (key instanceof String) {<br>return (String) key;<br>} else {<br>return (Serializable) key;<br>}</p><p>​<br> }</p><pre><code>/**    * 插入    * @param params    * @return    */   private boolean doInsert(Map&lt;String, Object&gt; params) &#123;      String sql = this.makeSimpleInsertSql(this.getTableName(), params);      int ret = this.jdbcTemplateWrite().update(sql, params.values().toArray());      return ret &gt; 0;   &#125;删除方法，均以delete开头：</code></pre><p>​<br> /**<br>_ 删除对象.<br><br>_<br>_ @param entity 待删除的实体对象<br>_/<br>public boolean delete(T entity) throws Exception {<br>return this.doDelete(op.pkField.get(entity)) &gt; 0;<br>}</p><pre><code>   /**    * 删除对象.&lt;br&gt;    *    * @param list 待删除的实体对象列表    * @throws InvocationTargetException    * @throws IllegalArgumentException    * @throws IllegalAccessException    */   public int deleteAll(List&lt;T&gt; list) throws Exception &#123;      String pkName = op.pkField.getName();      int count = 0 ,len = list.size(),step = 1000;      Map&lt;String, PropertyMapping&gt; pm = op.mappings;      int maxPage = (len % step == 0) ? (len / step) : (len / step + 1);      for (int i = 1; i &lt;= maxPage; i ++) &#123;         StringBuffer valstr = new StringBuffer();         Page&lt;T&gt; page = pagination(list, i, step);         Object[] values = new Object[page.getRows().size()];         for (int j = 0; j &lt; page.getRows().size(); j ++) &#123;            if(j &gt; 0 &amp;&amp; j &lt; page.getRows().size())&#123; valstr.append(&quot;,&quot;); &#125;            values[j] = pm.get(pkName).getter.invoke(page.getRows().get(j));            valstr.append(&quot;?&quot;);         &#125;         String sql = &quot;delete from &quot; + getTableName() + &quot; where &quot; + pkName + &quot; in (&quot; + valstr.toString() + &quot;)&quot;;         int result = jdbcTemplateWrite().update(sql, values);         count += result;      &#125;      return count;   &#125;   /**    * 根据id删除对象。如果有记录则删之，没有记录也不报异常&lt;br&gt;    * 例如：删除主键唯一的记录    *    * @param id 序列化id    */   protected void deleteByPK(PK id)  throws Exception &#123;      this.doDelete(id);   &#125;/**    * 删除实例对象，返回删除记录数    * @param tableName    * @param pkName    * @param pkValue    * @return    */   private int doDelete(String tableName, String pkName, Object pkValue) &#123;      StringBuffer sb = new StringBuffer();      sb.append(&quot;delete from &quot;).append(tableName).append(&quot; where &quot;).append(pkName).append(&quot; = ?&quot;);      int ret = this.jdbcTemplateWrite().update(sb.toString(), pkValue);      return ret;   &#125;</code></pre><p>​<br> 修改方法，均以 update 开头：</p><p>​<br> /**<br>_ 更新对象.<br><br>_<br>_ @param entity 待更新对象<br>_ @throws IllegalAccessException<br>_ @throws IllegalArgumentException<br>_/<br>public boolean update(T entity) throws Exception {<br>return this.doUpdate(op.pkField.get(entity), parse(entity)) &gt; 0;<br>}</p><pre><code>/**    * 更新实例对象，返回删除记录数    * @param pkValue    * @param params    * @return    */   private int doUpdate(Object pkValue, Map&lt;String, Object&gt; params)&#123;      String sql = this.makeDefaultSimpleUpdateSql(pkValue, params);      params.put(this.getPKColumn(), pkValue);      int ret = this.jdbcTemplateWrite().update(sql, params.values().toArray());      return ret;   &#125;</code></pre><p>至此一个完整的 ORM 框架就横空出世。当然，还有很多优化的地方，请小伙伴可以继续完善。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React框架-总结</title>
      <link href="/2021/12/07/article6/"/>
      <url>/2021/12/07/article6/</url>
      
        <content type="html"><![CDATA[<p><strong>创建项目</strong></p><p>1.静态页面创建</p><p>页面直接引入 React，ReactDOM 的 js 文件：react.js，react-dom.js，</p><p>页面 CDN 引入：</p><p>React：<a href="https://cdn.bootcdn.net/ajax/libs/react/16.14.0/umd/react.development.js">https://cdn.bootcdn.net/ajax/libs/react/16.14.0/umd/react.development.js</a></p><p>ReactDOM：<a href="https://cdn.bootcdn.net/ajax/libs/react-dom/16.14.0/cjs/react-dom.development.js">https://cdn.bootcdn.net/ajax/libs/react-dom/16.14.0/cjs/react-dom.development.js</a></p><p>2.通过脚手架创建</p><p>全局安装：<code>npm install -g create-react-app</code></p><p>创建项目：<code>create-react-app react-demo</code></p><p>有了 vue 的基础，我们直接通过脚手架创建项目，开始我们 React 的学习旅程。</p><p><strong>目录结构</strong></p><pre><code>react-demo--node_modules   // 项目依赖包--public   // 公共资源文件，如：图片，json文件等--src        // 项目页面组件，样式，脚本文件，路由等--package.json  // 项目webpack配置和包管理文件--README.md  // 项目说明文件</code></pre><p>运行：<code>npm run start</code></p><p>项目模板的初始页面就可以访问了：<a href="http://localhost:3000/">http://localhost:3000/</a></p><p><strong>渲染组件</strong></p><p>文件 src/index.js</p><p>可以看到 ReactDOM.render() ，渲染组件（App），把模板转换成 html 语言并插入到指定的节点。</p><p>导入 react（import React from ‘react’），react-dom（import ReactDOM from ‘react-dom’）</p><p>文件 src/App.js</p><p>这里使用了 JSX 语法写 html 页面，遇到 html 标签（例如：&lt;&gt;）就用 html 解析，遇到代码块（例如：{ }）就用 javascript 规则解析。</p><p>可以尝试修改里面的内容，预览效果。</p><p><strong>数据绑定</strong></p><p>React 里面没有像 Vue 里面那么简单的数据绑定功能，这里需要我们自己去完成表单控件的数据绑定的功能。</p><p>使用状态 state 存储输入控件的值，使用 onChange 的回调函数，通过 this.setState 修改 state 里面的值，每次修改完会自动调用 <strong>this.render</strong> 方法，再次渲染组件。这样就可以实现输入框的数据绑定。</p><pre><code>import React, &#123; Component &#125; from &#39;react&#39;export default class AddUser extends Component &#123;    // 定义状态    state = &#123;        userName: &quot;&quot;,        userAge: &quot;&quot;    &#125;    // 定义表单控件输入框事件    handleChange = (event)=&gt;&#123;        // 获取控件名称 name        const name = event.target.name;        this.setState(&#123;            [name]: event.target.value   // 获取控件的值        &#125;);    &#125;    // 定义按钮事件    handleAddUser = () =&gt; &#123;        console.log(&quot;用户名和年龄：&quot;, this.state)    &#125;    render() &#123;        return (            &lt;div&gt;                &lt;div&gt;&lt;input name=&quot;userName&quot; value=&#123;this.state.userName&#125; onChange=&#123;this.handleChange&#125; placeholder=&quot;请输入用户名&quot; /&gt;&lt;/div&gt;                &lt;div&gt;&lt;input name=&quot;userAge&quot; value=&#123;this.state.userAge&#125; onChange=&#123;this.handleChange&#125; placeholder=&quot;请输入年龄&quot; /&gt;&lt;/div&gt;                &lt;div&gt;&lt;input onClick=&#123;this.handleAddUser&#125; value=&quot;添加&quot;/&gt;&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><p><strong>生命周期</strong></p><p>React 中组件的生命周期分为三个状态，<strong>Mounting</strong>是已经插入真实 DOM，<strong>Updating</strong>是正在被重新渲染，<strong>Unmounting</strong>是已移出真实 DOM。每个状态都有两种处理函数，<strong>will</strong>函数是进入状态之前，<strong>did</strong>函数是进入状态之后，共有五个函数如下：</p><p><code>componentWillMount()</code><br><code>componentDidMount()，一般会在这个里面请求数据</code><br><code>componentWillUpdate(object nextProps,object nextState)</code><br><code>componentWillUpdate(object prevState, object prevState)</code><br><code>componentWillUnMount()，这里面一般会清除定时器，清空对象</code></p><p><strong>唯一 ID 生成器</strong></p><p>nanoid 是一个非常小巧，安全友好的 JavaScript 唯一 ID 生成器，比 uuid 更可靠和易用，源码地址：<a href="https://github.com/ai/nanoid">https://github.com/ai/nanoid</a></p><p>在模拟添加数据的时候，一般都会需要一个唯一 ID 值，那么我们就使用 nanoid 来生成这个 ID 值。</p><p>安装：<code>npm install nanoid --save</code></p><p>导入：<code>import &#123; nanoid &#125; from &#39;nanoid&#39;</code></p><p>使用：<code>const id = nanoid();</code></p><p>其它使用方法参考文档：<a href="https://www.npmjs.com/package/nanoid">https://www.npmjs.com/package/nanoid</a></p><p><strong>Props</strong></p><p>Props 是只读的，不能修改自身的 props，父子组件传值就要通过 props 来完成。</p><p>Props 验证使用 propTypes，它可以保证我们的应用组件被正确使用。参考：<a href="https://www.npmjs.com/package/prop-types">https://www.npmjs.com/package/prop-types</a></p><p>安装：<code>npm install prop-types --save</code></p><p><strong>发布订阅（pubsub-js）</strong></p><p>React 的父子组件之间可以通过 props 传递值，如果组件和组件之间需要传值的话要借助它们的父组件进行传值，这样父组件需要定义 state 和写好多回调函数。如果想在任意组件传递数据可以使用 pubsub-js 来完成。</p><p>安装：<code>npm install pubsub-js --save</code></p><p>导入：<code>import PubSub from &#39;pubsub-js&#39;</code></p><p>使用：</p><pre><code>PubSub.publish(&#39;name&#39;, param)  // 发布订阅，name: 发布的消息名，param：提供给订阅者的参数PubSub.subscribe(&#39;name&#39;, func) // 订阅消息，name: 发布的消息名，func：事件的监听函数var func = function(msg, data) &#123;  console.log(msg,data);&#125;PubSub.unsubscribe(&#39;name&#39;) // 取消订阅</code></pre><p>有关 pubsub-js 的其它用法，可以参考文档：<a href="https://www.npmjs.com/package/pubsub-js">https://www.npmjs.com/package/pubsub-js</a></p><p><strong>调试工具</strong></p><p>谷歌浏览器安装插件：react developer tools，打开开发者工具，调试窗口如下图：</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/20210917/1631858840239098687.png"></p><p><strong>温馨提示</strong></p><p>文章内容如果写的存在问题欢迎留言指出，让我们共同交流，共同探讨，共同进步~~~</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欲罢不能的node.js</title>
      <link href="/2021/10/23/article4/"/>
      <url>/2021/10/23/article4/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-node-js"><a href="#什么是-node-js" class="headerlink" title="什么是 node.js"></a>什么是 node.js</h3><p>到底什么是 node.js 呢？看看<a href="http://www.nodejs.org/">官网</a>对 nodejs 的描述：</p><p>Node.js is a platform built on Chrome’s JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</p><p>我们可以对此总结出几点</p><ol><li>node.js 是一个构建在 Chrome JavaScript 运行环境的平台，这是很重要的一点，<strong>node.js 并不是一门语言，而是一个平台</strong></li><li>node.js 致力于使构建速度快、稳定的网络程序更简单</li><li>node.js 具有事件驱动和非阻塞 I/O 的特色，使之轻量级并且高效率</li><li>node.js 非常适合在分布式设备运行数据密集型实时应用程序</li></ol><h3 id="服务器端运行的-JavaScript？"><a href="#服务器端运行的-JavaScript？" class="headerlink" title="服务器端运行的 JavaScript？"></a><strong>服务器端运行的 JavaScript？</strong></h3><p>Chrome JavaScript runtime 也就是我们常说的 Chrome 的 V8 JavaScript Engine，也就是 Goole 开发的一个用于 Chrome 浏览器的底层 JavaScript 引擎，用于解析 JavaScript 语句创建其运行环境，保证我们写的语句在浏览器上的表现和我们预期的一致。</p><p>那么为什么说 node.js 是服务器端运行的 JavaScript？好好地 nodejs 干嘛要和 V8 扯上关系？除了 Google 搞的 V8 解释 JavaScript 十分的快，十分重要的一个原因是 V8 JavaScript 引擎并不仅限于在浏览器中运行，可以嵌入任何应用程序中运行。Node.js 和.net framework 类似是一个平台（这里有些搞不明白，望大神们指点一二），但它没有像.net 一样创造了一门语言——C#在这个平台上运行，而是很巧妙的借用了 web 开发人员已经非常熟悉的 JavaScript 语法，使用 V8 引擎来解析语句，并将其重建可在服务器上使用。所以严格上说 node.js 并不是服务器端运行的 Javascript，而是可以在服务器端运行 JavaScript 语法的平台。</p><h3 id="为什么要用-node-js"><a href="#为什么要用-node-js" class="headerlink" title="为什么要用 node.js"></a>为什么要用 node.js</h3><p>搞了半天就是一个新瓶装旧酒的东西，看起来除了一个新鲜的可以使用 JavaScript 语法，node.js 没什么长处，为什么要用它而不是同样可以在服务器端运行的 Java 或 C#呢？这要从 node.js 事件驱动和非阻塞 I/O 的特色谈起。关于事件驱动熟悉 JavaScript 的同学应该很熟悉了，node.js 采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统、数据库之类的资源提供接口，比如一个数据库访问，采用事件机制,发起请求之后,立即将进程交出,当数据返回后触发事件,再继续处理数据。</p><p>在传统的阻塞 I/O 中其运行过程是这样的</p><pre><code>int num=query(&#39;select * from ......&#39;);print(num);...................//无关语句</code></pre><p>print 方法必须等待 query 方法返回结果，如果数据库出现网络连接故障，那么 print 方法就要等到超时才能执行，然后后面一些无关语句才能一次执行，而在非阻塞 I/O 中是这样的</p><pre><code>query(&#39;select * from...&#39;,callback(data)&#123;  .............//相关语句  print();&#125;);..............//无关语句</code></pre><p>跟我们使用 ajax，在回调函数中处理结果，但是不影响下面语句执行。 怪不得 node.js 要借用 JavaScript 来做此事，JavaScript 的几个特性使它很胜任这项工作</p><ol><li>事件机制</li><li>函数式编程，支持匿名函数，函数参数</li></ol><p>Node.js 中代码是单进程、单线程执行的（我们写的代码是，但 node.js 本身不是有兴趣同学可以看看<a href="http://rickgaribay.net/archive/2012/01/28/node-is-not-single-threaded.aspx">这个</a>进一步了解），使用事件轮询机制和非阻塞 I/O，在不新增额外线程的情况下对任务进行并行处理 。node.js 解决了阻塞式编程浪费大量进程资源只是在等待,导致的大量内存和 cpu 的浪费问题，所以才敢宣称自己 perfect for 数据密集型的实时 web 应用程序。</p><h3 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h3><p>nodejs 的安装还是很简单的，尤其是现在安装包都把 npm 集成了进去，不用单独安装了，下载下安装包运行就可以了，另外想完整使用 nodejs 的话需要有 C 语言的编译环境、git 和 python，使用 window 的同学很能会稍微麻烦一些，需要搞定这些。对命令行情有独钟的同学可以看看<a href="http://howtonode.org/how-to-install-nodejs">How to Install Node.js</a></p><p><strong>npm 是什么</strong></p><p>npm 是 node packaged modules 的缩写，其实是一个 nodejs 的 module 的管理工具</p><p><strong>什么是 module</strong></p><p>所谓 module 和 java 中的包的概念很类似，一些解决方案的集合，官方会提供核心的几个，第三方的很多</p><p><strong>如何安装第三方 module</strong></p><p>因为 nodejs 的社区很活跃，有很多好用的第三方的包，我们可以在终端中使用 npm 的命令安装</p><ul><li><em>npm install [-g] <name>:使用 install 指令可以把 nodule 下载安装的 nodejs 的全局的 path 处，不加的话会安装到当前路径</em></li><li><em>npm remove <name>:移除 module</em></li><li><em>npm update <name>:更新 module</em></li></ul><p>还有一些常用命令可以看看<a href="http://blog.csdn.net/haidaochen/article/details/8546796">npm 常用命令</a></p><h3 id="第一个-demo"><a href="#第一个-demo" class="headerlink" title="第一个 demo"></a>第一个 demo</h3><p>这些都搞定后我们就可以写传说中的 hello world 了。在任意目录建一个 test.js 文件</p><p>console.log(‘Hello, World!’);</p><p>简单的一句话就可以，然后使用 node 命令运行</p><p><img src="https://images0.cnblogs.com/blog/349217/201312/14180746-9e477b3401c84b5f9aa964344aa6a15f.png"></p><p>这这这。。。太没技术含量了，看看官方给的 demo，使用 nodejs 创建一个 web server 有多简单</p><pre><code>var http=require(&#39;http&#39;);//引入http modulehttp.createServer(function(request,response)&#123;//创建一个web server    //回调函数，这样创建server方法就不会阻塞了    response.writeHead(200,&#123;&#39;contentType&#39;:&#39;text/plain&#39;&#125;);    response.end(&#39;Hello World!\n&#39;);&#125;).listen(8124);console.log(&#39;Server running at http://127.0.0.1:8124/&#39;);</code></pre><p>先运行一下服务器，按两次 Ctrl+C 退出</p><p><img src="https://images0.cnblogs.com/blog/349217/201312/14181624-c88df45c5236483aa49cf4af3f140868.png" alt="img"></p><p>使用浏览器访问一下</p><p><img src="https://images0.cnblogs.com/blog/349217/201312/14181637-8fc77389050a4fa0818a3672bf528ed1.png" alt="img"></p><p>就这么简单</p><h3 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h3><p>看到上面的 demo 是不是也对 nodejs 产生兴趣了呢，可是像我这样的懒人接触一门新语言的时候不知道该如何下手，难道又要去做个无聊的购物车神马的嘛，学习 nodejs 不用，nodejs 为我们提供了一个小游戏一样的教程，就像个寻宝过程从零开始，没步都有一个任务和一下提示让你走的更远，上<a href="http://nodeschool.io/">nodeschool</a>下载然后开始寻宝吧，我就是被这小游戏迷住了，顺便秀一下我一天的战绩，每个任务都完成了</p><p><img src="https://images0.cnblogs.com/blog/349217/201312/14182240-ea57a8c1ac1c4c50b1d927071f5f6e21.png" alt="img"></p><p>看看解释就知道怎么做了，不过建议最开始 run 和 verify 结合使用，verify 告诉你执行结果和预期结果，run 会告诉你有哪些错误</p><p>当然除了这些小游戏帮我们熟悉 nodejs 语法及使用，一些优秀的社区也可以帮我们很多</p><p><a href="http://cnodejs.org/">CNode</a></p><p><a href="http://www.oschina.net/p/nodejs/">开源中国</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 自定义http.Client</title>
      <link href="/2021/10/04/article3/"/>
      <url>/2021/10/04/article3/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>go 中可以使用 http.DefaultClient 进行 http 请求，也可以自己创建 http.Client，传入自定义 Transport 可以实现对 request 的处理。</p><p>http.Client</p><pre><code>// A Client is an HTTP client. Its zero value (DefaultClient) is a// usable client that uses DefaultTransport.//// The Client&#39;s Transport typically has internal state (cached TCP// connections), so Clients should be reused instead of created as// needed. Clients are safe for concurrent use by multiple goroutines.//// A Client is higher-level than a RoundTripper (such as Transport)// and additionally handles HTTP details such as cookies and// redirects.//// When following redirects, the Client will forward all headers set on the// initial Request except://// when forwarding sensitive headers like &quot;Authorization&quot;,// &quot;WWW-Authenticate&quot;, and &quot;Cookie&quot; to untrusted targets.// These headers will be ignored when following a redirect to a domain// that is not a subdomain match or exact match of the initial domain.// For example, a redirect from &quot;foo.com&quot; to either &quot;foo.com&quot; or &quot;sub.foo.com&quot;// will forward the sensitive headers, but a redirect to &quot;bar.com&quot; will not.//// • when forwarding the &quot;Cookie&quot; header with a non-nil cookie Jar.// Since each redirect may mutate the state of the cookie jar,// a redirect may possibly alter a cookie set in the initial request.// When forwarding the &quot;Cookie&quot; header, any mutated cookies will be omitted,// with the expectation that the Jar will insert those mutated cookies// with the updated values (assuming the origin matches).// If Jar is nil, the initial cookies are forwarded without change.</code></pre><p>type Client struct</p><pre><code>// Transport specifies the mechanism by which individual// HTTP requests are made.// If nil, DefaultTransport is used.Transport RoundTripper // CheckRedirect specifies the policy for handling redirects. // If CheckRedirect is not nil, the client calls it before // following an HTTP redirect. The arguments req and via are // the upcoming request and the requests made already, oldest // first. If CheckRedirect returns an error, the Client&#39;s Get // method returns both the previous Response (with its Body // closed) and CheckRedirect&#39;s error (wrapped in a url.Error) // instead of issuing the Request req. // As a special case, if CheckRedirect returns ErrUseLastResponse, // then the most recent response is returned with its body // unclosed, along with a nil error. // // If CheckRedirect is nil, the Client uses its default policy, // which is to stop after 10 consecutive requests.CheckRedirect func(req *Request, via []*Request) error // Jar specifies the cookie jar. // // The Jar is used to insert relevant cookies into every // outbound Request and is updated with the cookie values // of every inbound Response. The Jar is consulted for every // redirect that the Client follows.`` // // If Jar is nil, cookies are only sent if they are explicitly // set on the Request.Jar CookieJar// Timeout specifies a time limit for requests made by this// Client. The timeout includes connection time, any// redirects, and reading the response body. The timer remains// running after Get, Head, Post, or Do return and will// interrupt reading of the Response.Body.//// A Timeout of zero means no timeout.//// The Client cancels requests to the underlying Transport// as if the Request&#39;s Context ended.//// For compatibility, the Client will also use the deprecated// CancelRequest method on Transport if found. New// RoundTripper implementations should use the Request&#39;s Context// for cancellation instead of implementing CancelRequest.Timeout time.Duration&#125;</code></pre><p>http.RoundTripper</p><pre><code>// RoundTripper is an interface representing the ability to execute a// single HTTP transaction, obtaining the Response for a given Request.//// A RoundTripper must be safe for concurrent use by multiple// goroutines.type RoundTripper interface&#123;// RoundTrip executes a single HTTP transaction, returning// a Response for the provided Request.//// RoundTrip should not attempt to interpret the response. In// particular, RoundTrip must return err == nil if it obtained// a response, regardless of the response&#39;s HTTP status code.// A non-nil err should be reserved for failure to obtain a// response. Similarly, RoundTrip should not attempt to// handle higher-level protocol details such as redirects,// authentication, or cookies.//// RoundTrip should not modify the request, except for// consuming and closing the Request&#39;s Body. RoundTrip may// read fields of the request in a separate goroutine. Callers// should not mutate or reuse the request until the Response&#39;s// Body has been closed.//// RoundTrip must always close the body, including on errors,// but depending on the implementation may do so in a separate// goroutine even after RoundTrip returns. This means that// callers wanting to reuse the body for subsequent requests// must arrange to wait for the Close call before doing so.//// The Request&#39;s URL and Header fields must be initialized.RoundTrip(*Request) (*Response, error)&#125;</code></pre><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>先写一个 server，打印出访问的 payload 信息。</p><pre><code>package mainimport(&quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot;) func main() &#123;    mux := http.NewServeMux()    mux.HandleFunc(&quot;/&quot;, func(rw http.ResponseWriter, r *http.Request) &#123;        req, err := ioutil.ReadAll(r.Body)        if err != nil &#123;            rw.WriteHeader(500)            rw.Write([]byte(err.Error()))            return        &#125;        fmt.Println(string(req))    &#125;)    if err := http.ListenAndServe(&quot;:8000&quot;, mux);    err != nil &#123;        panic(err)    &#125;&#125;如果使用默认的DefaultClient，只会打印出我们传入的payload。package mainimport(&quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;strings&quot; &quot;github.com/google/uuid&quot;)func main() &#123;    id := uuid.NewString()    req, _ := http.NewRequest(&quot;GET&quot;, &quot;http://localhost:8000&quot;, strings.NewReader(fmt.Sprintf(&#123;&quot;id&quot;:&quot;%s&quot;&#125;, id)))    req.Header.Add(&quot;Authorization&quot;, fmt.Sprintf(&quot;Bearer token%s&quot;, id))    resp, err := http.DefaultClient.Do(req)    if err != nil &#123;        panic(err)    &#125;    fmt.Println(resp)&#125;()</code></pre><p>结果：</p><pre><code>&#123;&quot;id&quot;:&quot;912733ce-4e17-4209-ad9e-71159fd37845&quot;&#125;&amp;&#123;200 OK 200 HTTP/1.1 1 1 map[Content-Length:[0] Date:[Sun, 28 Nov 2021 06:48:50 GMT]] &#123;&#125; 0 [] false false map[] 0xc000194000 &lt;nil&gt;&#125;</code></pre><p>使用自定义 Transport</p><pre><code>package mainimport( &quot;bytes&quot;  &quot;encoding/json&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;strings&quot;)type customTransport struct &#123;&#125;func (t *customTransport) RoundTrip(req *http.Request) (*http.Response, error) &#123;  token := req.Header.Get(&quot;Authorization&quot;)  if len(token) != 0 &amp;&amp;  strings .HasPrefix(token,  &quot;Bearer &quot; ) &#123;    token = token[7:]    var bodyBytes []byte    if req.Body != nil &#123;      bodyBytes, _ = ioutil.ReadAll(req.Body)      &#125;      var payload map[string]interface&#123;&#125;      if err := json.Unmarshal(bodyBytes, &amp;payload); err != nil &#123;        return nil, err          &#125;else&#123;            payload[``&quot;token&quot;``] = token            if bodyBytes, err := json.Marshal(payload); err != nil &#123;            return nil, err          &#125;else&#123;          req.ContentLength = int64(len(bodyBytes))          req.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))      &#125;    &#125;  &#125;  resp, err := http.DefaultTransport.RoundTrip(req)  if err != nil &#123;    return nil, err  &#125;  return resp, nil&#125;</code></pre><p>使用自定义 Client</p><pre><code>package mainimport(  &quot;fmt&quot;  &quot;io/ioutil&quot;  &quot;net/http&quot;  &quot;strings&quot;   &quot;github.com/google/uuid&quot;) func main() &#123;    id := uuid.NewString()  req, _ := http.NewRequest(&quot;GET&quot;, &quot;http://localhost:8000&quot;, strings.NewReader(fmt.Sprintf(&#123;        &quot;id&quot;:&quot;%s&quot;    &#125;, id)))    req.Header.Add(&quot;Authorization&quot;, fmt.Sprintf(&quot;Bearer token%s&quot;, id))    client := &amp;http.Client&#123;        Transport: &amp;customTransport&#123;&#125;,    &#125;    resp, err := client.Do(req)    if err != nil &#123;    panic(err)  &#125;fmt.Println(resp)&#125;()</code></pre><p>最终结果：</p><pre><code>&#123;&quot;id&quot;:&quot;ebcceb4b-1979-457b-bf49-9255ceb77322&quot;,&quot;token&quot;:&quot;tokenebcceb4b-1979-457b-bf49-9255ceb77322&quot;&#125;&amp;&#123;200 OK 200 HTTP/1.1 1 1 map[Content-Length:[0] Date:[Sun, 28 Nov 2021 06:49:25 GMT]] &#123;&#125; 0 [] false false map[] 0xc000140000 &lt;nil&gt;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式之建造者模式</title>
      <link href="/2021/09/27/article2/"/>
      <url>/2021/09/27/article2/</url>
      
        <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>日常生活中，比如组装电脑，生产汽车，都是有多个步骤来一步一步构建的，这时候就可以使用建造者模式来解决这个问题。下面以组装电脑为例子，比如组装游戏电脑，组装办公电脑。步骤都是一样的，最终都会出一个成品出来。</p><pre><code>function gameComputerBuilder() &#123;  this.buildMainboard = function() &#123;    console.log(&#39;游戏主板&#39;);  &#125;;  this.buildCPU = function() &#123;    console.log(&#39;游戏CPU&#39;);  &#125;;  this.buildHardDisk = function() &#123;    console.log(&#39;游戏硬盘&#39;);  &#125;;  this.getComputer = function() &#123;    return &#39;游戏电脑&#39;;  &#125;;&#125;function officeComputerBuilder() &#123;  this.buildMainboard = function() &#123;    console.log(&#39;办公主板&#39;);  &#125;;  this.buildCPU = function() &#123;    console.log(&#39;办公CPU&#39;);  &#125;;  this.buildHardDisk = function() &#123;    console.log(&#39;办公硬盘&#39;);  &#125;;  this.getComputer = function() &#123;    return &#39;办公电脑&#39;;  &#125;;&#125;function Operator() &#123;  this.startBuild = function(builder) &#123;    builder.buildMainboard();    builder.buildCPU();    builder.buildHardDisk();    return builder.getComputer();  &#125;;&#125;const op = new Operator();const gameComputer = new gameComputerBuilder();const officeComputer = new officeComputerBuilder();const gc = op.startBuild(gameComputer);console.log(gc)const oc = op.startBuild(officeComputer);&#123;&#125;console.log(oc)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数组详细操作</title>
      <link href="/2021/09/01/article1/"/>
      <url>/2021/09/01/article1/</url>
      
        <content type="html"><![CDATA[<p>创建一个数组:</p><pre><code>// 字面量方式:// 这个方法也是我们最常用的，在初始化数组的时候 相当方便var a = [3, 11, 8]; // [3,11,8];// 构造器:// 实际上 new Array === Array,加不加new 一点影响都没有。var a = Array(); // []var a = Array(3); // [undefined,undefined,undefined]var a = Array(3,11,8); // [ 3,11,8 ]</code></pre><p><strong>ES6 Array.of() 返回由所有参数值组成的数组</strong></p><p>定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。</p><p>目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。</p><pre><code>let a = Array.of(3, 11, 8); // [3,11,8]let a = Array.of(3); // [3]</code></pre><p><strong>ES6 Arrar.from() 将两类对象转为真正的数组</strong></p><p>定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。</p><p>参数：</p><p>第一个参数(必需):要转化为真正数组的对象。</p><p>第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。</p><p>第三个参数(可选): 用来绑定this。</p><pre><code>// 1. 对象拥有length属性let obj = &#123;0: &#39;a&#39;, 1: &#39;b&#39;, 2:&#39;c&#39;, length: 3&#125;;let arr = Array.from(obj); // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];// 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象let arr = Array.from(&#39;hello&#39;); // [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;]let arr = Array.from(new Set([&#39;a&#39;,&#39;b&#39;])); // [&#39;a&#39;,&#39;b&#39;]</code></pre><p>方法:</p><p>数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。</p><p><strong>改变原数组的方法(9个):</strong></p><pre><code>let a = [1,2,3];ES5:a.pop()/ a.shift()/ a.push()/ a.unshift()/ a.reverse()/ a.splice()/ a.sort()ES6:a.copyWithin() / a.fill</code></pre><p>对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。</p><p><strong>pop() 删除一个数组中的最后的一个元素</strong></p><p>定义: <code>pop() </code>方法删除一个数组中的最后的一个元素，并且返回这个元素。</p><p>参数: 无。</p><pre><code>let a = [1,2,3];let item = a.pop(); // 3console.log(a); // [1,2]</code></pre><p><strong>shift() 删除数组的第一个元素</strong></p><p>定义: <code>shift()</code>方法删除数组的第一个元素，并返回这个元素。</p><p>参数: 无。</p><pre><code>let a = [1,2,3];let item = a.shift(); // 1console.log(a); // [2,3]</code></pre><p><strong>push() 向数组的末尾添加元素</strong></p><p>定义：<code>push() </code>方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p><pre><code>let a = [1,2,3];let item = a.push(&#39;末尾&#39;); // 4console.log(a); // [1,2,3,&#39;末尾&#39;]</code></pre><p><strong>unshift()</strong></p><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p><pre><code>let a = [1,2,3];let item = a.unshift(&#39;开头&#39;); // 4console.log(a); // [&#39;开头&#39;,1,2,3]</code></pre><p><strong>revese() 颠倒数组中元素的顺序</strong></p><p>定义: <code>reverse() </code>方法用于颠倒数组中元素的顺序。</p><p>参数: 无</p><pre><code>let a = [1,2,3];a.reverse();console.log(a); // [3,2,1]</code></pre><p><strong>splice() 添加/删除数组元素</strong></p><p>定义： <code>splice() </code>方法向/从数组中添加/删除项目，然后返回被删除的项目</p><p><strong>语法： array.splice(index,howmany,item1,…..,itemX)</strong></p><p>参数:</p><ol><li>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</li><li>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</li><li>item1, …, itemX： 可选。向数组添加的新项目。</li></ol><p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p><p>eg1:删除元素</p><pre><code>let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0, 3); // [1,2,3]console.log(a); // [4,5,6,7]// 从数组下标0开始，删除3个元素let item = a.splice(-1, 3); // [7]// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</code></pre><p>eg2: 删除并添加</p><pre><code>let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,3,&#39;添加&#39;); // [1,2,3]console.log(a); // [&#39;添加&#39;,4,5,6,7]// 从数组下标0开始，删除3个元素，并添加元素&#39;添加&#39; let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-2,3,&#39;添加1&#39;,&#39;添加2&#39;); // [6,7]console.log(b); // [1,2,3,4,5,&#39;添加1&#39;,&#39;添加2&#39;]// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#39;添加1&#39;、&#39;添加2&#39;</code></pre><p>eg3: 不删除只添加:</p><pre><code>let a = [1, 2, 3, 4, 5, 6, 7];let item = a.splice(0,0,&#39;添加1&#39;,&#39;添加2&#39;); // [] 没有删除元素，返回空数组console.log(a); // [&#39;添加1&#39;,&#39;添加2&#39;,1,2,3,4,5,6,7]let b = [1, 2, 3, 4, 5, 6, 7];let item = b.splice(-1,0,&#39;添加1&#39;,&#39;添加2&#39;); // [] 没有删除元素，返回空数组console.log(b); // [1,2,3,4,5,6,&#39;添加1&#39;,&#39;添加2&#39;,7] 在最后一个元素的前面添加两个元素</code></pre><p>从上述三个栗子可以得出:</p><ol><li>数组如果元素不够，会删除到最后一个元素为止</li><li>操作的元素，包括开始的那个元素</li><li>可以添加很多个元素</li><li>添加是在开始的元素前面添加的</li></ol><p><strong>sort() 数组排序</strong></p><p>定义: <code>sort()</code>方法对数组元素进行排序，并返回这个数组。</p><p>参数可选: 规定排序顺序的比较函数。</p><p>默认情况下<code>sort()</code>方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。</p><pre><code>// 字符串排列 看起来很正常var a = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];a.sort(); // [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的var a = [10, 1, 3, 20,25,8];console.log(a.sort()) // [1,10,20,25,3,8];</code></pre><p><strong>比较函数的两个参数：</strong></p><p>sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p><ul><li>若比较函数返回值&lt;0，那么a将排到b的前面;</li><li>若比较函数返回值=0，那么a 和 b 相对位置不变；</li><li>若比较函数返回值&gt;0，那么b 排在a 将的前面；</li></ul><p><strong>sort排序常见用法：</strong></p><p>1、数组元素为数字的升序、降序:</p><pre><code>var array = [10, 1, 3, 4,20,4,25,8];// 升序 a-b &lt; 0 a将排到b的前面，按照a的大小来排序的// 比如被减数a是10，减数是20 10-20 &lt; 0 被减数a(10)在减数b(20)前面array.sort(function(a,b)&#123; return a-b;&#125;);console.log(array); // [1,3,4,4,8,10,20,25];// 降序 被减数和减数调换了 20-10&gt;0 被减数b(20)在减数a(10)的前面array.sort(function(a,b)&#123; return b-a;&#125;);console.log(array); // [25,20,10,8,4,4,3,1];</code></pre><p>2、数组多条件排序</p><pre><code>var array = [&#123;id:10,age:2&#125;,&#123;id:5,age:4&#125;,&#123;id:6,age:10&#125;,&#123;id:9,age:6&#125;,&#123;id:2,age:8&#125;,&#123;id:10,age:9&#125;]; array.sort(function(a,b)&#123;  if(a.id === b.id)&#123;// 如果id的值相等，按照age的值降序   return b.age - a.age  &#125;else&#123; // 如果id的值不相等，按照id的值升序   return a.id - b.id  &#125; &#125;) // [&#123;&quot;id&quot;:2,&quot;age&quot;:8&#125;,&#123;&quot;id&quot;:5,&quot;age&quot;:4&#125;,&#123;&quot;id&quot;:6,&quot;age&quot;:10&#125;,&#123;&quot;id&quot;:9,&quot;age&quot;:6&#125;,&#123;&quot;id&quot;:10,&quot;age&quot;:9&#125;,&#123;&quot;id&quot;:10,&quot;age&quot;:2&#125;]</code></pre><p>3、自定义比较函数，天空才是你的极限</p><p>类似的：运用好返回值，我们可以写出任意符合自己需求的比较函数</p><pre><code>var array = [&#123;name:&#39;Koro1&#39;&#125;,&#123;name:&#39;Koro1&#39;&#125;,&#123;name:&#39;OB&#39;&#125;,&#123;name:&#39;Koro1&#39;&#125;,&#123;name:&#39;OB&#39;&#125;,&#123;name:&#39;OB&#39;&#125;];array.sort(function(a,b)&#123; if(a.name === &#39;Koro1&#39;)&#123;// 如果name是&#39;Koro1&#39; 返回-1 ，-1&lt;0 a排在b的前面  return -1 &#125;else&#123; // 如果不是的话，a排在b的后面  return 1 &#125;&#125;)// [&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;]</code></pre><p><strong>ES6: copyWithin() 指定位置的成员复制到其他位置</strong></p><p>定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。</p><p>语法:</p><p><strong>array.copyWithin(target, start = 0, end = this.length)</strong><br>参数:</p><p>三个参数都是数值，如果不是，会自动转为数值.</p><ol><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。</li></ol><p>浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持</p><p>eg:</p><pre><code>// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]var a=[&#39;OB1&#39;,&#39;Koro1&#39;,&#39;OB2&#39;,&#39;Koro2&#39;,&#39;OB3&#39;,&#39;Koro3&#39;,&#39;OB4&#39;,&#39;Koro4&#39;,&#39;OB5&#39;,&#39;Koro5&#39;]// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换a.copyWithin(2,3,5)// [&quot;OB1&quot;,&quot;Koro1&quot;,&quot;Koro2&quot;,&quot;OB3&quot;,&quot;OB3&quot;,&quot;Koro3&quot;,&quot;OB4&quot;,&quot;Koro4&quot;,&quot;OB5&quot;,&quot;Koro5&quot;]</code></pre><p>从上述栗子:</p><ol><li>第一个参数是开始被替换的元素位置</li><li>要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取</li><li>数组的长度不会改变</li><li>读了几个元素就从开始被替换的地方替换几个元素</li></ol><p><strong>ES6: fill() 填充数组</strong></p><p>定义: 使用给定值，填充一个数组。</p><p>参数:</p><p>第一个元素(必须): 要填充数组的值</p><p>第二个元素(可选): 填充的开始位置,默认值为0</p><p>第三个元素(可选)：填充的结束位置，默认是为this.length</p><p><strong>MDN浏览器兼容</strong></p><pre><code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)// [7, 7, 7][&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)// [&#39;a&#39;, 7, &#39;c&#39;]</code></pre><p><strong>不改变原数组的方法(8个):</strong></p><pre><code>ES5：join、toLocateString、toStrigin、slice、cancat、indexOf、lastIndexOf、ES7：includes</code></pre><p><strong>join() 数组转字符串</strong></p><p>定义: <code>join() </code>方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p><p>语法:</p><p><strong>array.join(str)</strong><br>参数:</p><p>str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</p><pre><code>let a= [&#39;hello&#39;,&#39;world&#39;];let str=a.join(); // &#39;hello,world&#39;let str2=a.join(&#39;+&#39;); // &#39;hello+world&#39;</code></pre><p>使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？</p><pre><code>let a= [[&#39;OBKoro1&#39;,&#39;23&#39;],&#39;test&#39;];let str1=a.join(); // OBKoro1,23,testlet b= [&#123;name:&#39;OBKoro1&#39;,age:&#39;23&#39;&#125;,&#39;test&#39;];let str2 = b.join(); // [object Object],test// 对象转字符串推荐JSON.stringify(obj);</code></pre><p>所以，<code>join()</code>/<code>toString()</code>方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),如果是对象的话，对象会被转为[object Object]字符串。</p><p><strong>toLocaleString() 数组转字符串</strong></p><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 <code>toLocaleString() </code>返回值经调用 join() 方法连接（由逗号隔开）组成。</p><p>语法:</p><p><strong>array.toLocaleString()</strong><br>参数：无。</p><pre><code>let a=[&#123;name:&#39;OBKoro1&#39;&#125;,23,&#39;abcd&#39;,new Date()];let str=a.toLocaleString(); // [object Object],23,abcd,2021/12/3 下午1:52:20</code></pre><p>如上述栗子：调用数组的<code>toLocaleString</code>方法，数组中的每个元素都会调用自身的toLocaleString方法，对象调用对象的toLocaleString,Date调用Date的toLocaleString。</p><p><strong>toString() 数组转字符串 不推荐</strong></p><p>定义: <code>toString() </code>方法可把数组转换为由逗号链接起来的字符串。</p><p>语法:</p><p><strong>array.toString()</strong><br>参数: 无。</p><p>该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。</p><p>值得注意的是：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串</p><pre><code>let b= [ &#39;toString&#39;,&#39;演示&#39;].toString(); // toString,演示let a= [&#39;调用toString&#39;,&#39;连接在我后面&#39;]+&#39;啦啦啦&#39;; // 调用toString,连接在我后面啦啦啦</code></pre><p><strong>slice() 浅拷贝数组的元素</strong></p><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p><p>注意：字符串也有一个<code>slice() </code>方法是用来提取字符串的，不要弄混了。</p><p>语法:</p><p><strong>array.slice(begin, end);</strong><br>参数:</p><p>begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。</p><p>end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</p><pre><code>let a= [&#39;hello&#39;,&#39;world&#39;];let b=a.slice(0,1); // [&#39;hello&#39;]a[0]=&#39;改变原数组&#39;;console.log(a,b); // [&#39;改变原数组&#39;,&#39;world&#39;] [&#39;hello&#39;]b[0]=&#39;改变拷贝的数组&#39;;console.log(a,b); // [&#39;改变原数组&#39;,&#39;world&#39;] [&#39;改变拷贝的数组&#39;]</code></pre><p>如上：新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</p><p>如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</p><pre><code>let a= [&#123;name:&#39;OBKoro1&#39;&#125;];let b=a.slice();console.log(b,a); // [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;] [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]// a[0].name=&#39;改变原数组&#39;;// console.log(b,a); // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]// b[0].name=&#39;改变拷贝数组&#39;,b[0].koro=&#39;改变拷贝数组&#39;;// [&#123;&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;&#125;]</code></pre><p>原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。</p><p><strong>cancat</strong></p><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p><p>语法：</p><p><strong>var newArr =oldArray.concat(arrayX,arrayX,……,arrayX)</strong><br>参数：</p><p>arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p><p>eg1:</p><pre><code>let a = [1, 2, 3]; let b = [4, 5, 6]; //连接两个数组 let newVal=a.concat(b); // [1,2,3,4,5,6] // 连接三个数组 let c = [7, 8, 9] let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9] // 添加元素 let newVal3 = a.concat(&#39;添加元素&#39;,b, c,&#39;再加一个&#39;); // [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]// 合并嵌套数组 会浅拷贝嵌套数组let d = [1,2 ];let f = [3,[4]];let newVal4 = d.concat(f); // [1,2,3,[4]]</code></pre><p>ES6扩展运算符…合并数组：</p><p>因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用…来处理，…运算符可以实现cancat的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。</p><pre><code>let a = [2, 3, 4, 5]let b = [ 4,...a, 4, 4]console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4]</code></pre><p>更多关于扩展符的详细内容移步阮一峰大神的<a href="http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">ECMAScript 6 入门</a></p><p><strong>indexOf() 查找数组是否存在某个元素，返回下标</strong></p><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><p>语法:</p><p><strong>array.indexOf(searchElement,fromIndex)</strong><br>参数:</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p><p>严格相等的搜索:</p><p>数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。</p><p>注意：indexOf()不能识别NaN</p><p>eg:</p><pre><code>let a=[&#39;啦啦&#39;,2,4,24,NaN]console.log(a.indexOf(&#39;啦&#39;)); // -1console.log(a.indexOf(&#39;NaN&#39;)); // -1console.log(a.indexOf(&#39;啦啦&#39;)); // 0</code></pre><p>使用场景：</p><ol><li><strong>数组去重</strong></li><li>根据获取的数组下标执行操作，改变数组中的值等。</li><li>判断是否存在，执行操作。</li></ol><p><strong>lastIndexOf() 查找指定元素在数组中的最后一个位置</strong></p><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p><p>语法:</p><p><strong>arr.lastIndexOf(searchElement,fromIndex)</strong><br>参数:</p><p>searchElement(必须): 被查找的元素</p><p>fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。</p><p>关于fromIndex有三个规则:</p><ol><li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li><li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li><li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li></ol><pre><code>let a=[&#39;OB&#39;,4,&#39;Koro1&#39;,1,2,&#39;Koro1&#39;,3,4,5,&#39;Koro1&#39;]; // 数组长度为10// let b=a.lastIndexOf(&#39;Koro1&#39;,4); // 从下标4开始往前找 返回下标2// let b=a.lastIndexOf(&#39;Koro1&#39;,100); // 大于或数组的长度 查找整个数组 返回9// let b=a.lastIndexOf(&#39;Koro1&#39;,-11); // -1 数组不会被查找let b=a.lastIndexOf(&#39;Koro1&#39;,-9); // 从第二个元素4往前查找，没有找到 返回-1</code></pre><p><strong>ES7 includes() 查找数组是否包含某个元素 返回布尔</strong></p><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p><p>语法：</p><p><strong>array.includes(searchElement,fromIndex=0)</strong><br>参数：</p><p>searchElement(必须):被查找的元素</p><p>fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。</p><p>includes方法是为了弥补indexOf方法的缺陷而出现的:</p><ol><li>indexOf方法不能识别NaN</li><li>indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观</li></ol><p>eg:</p><pre><code>let a=[&#39;OB&#39;,&#39;Koro1&#39;,1,NaN];// let b=a.includes(NaN); // true 识别NaN// let b=a.includes(&#39;Koro1&#39;,100); // false 超过数组长度 不搜索// let b=a.includes(&#39;Koro1&#39;,-3); // true 从倒数第三个元素开始搜索// let b=a.includes(&#39;Koro1&#39;,-100); // true 负值绝对值超过数组长度，搜索整个数组</code></pre><p>兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。</p><p><strong>遍历方法(12个):</strong></p><p>js中遍历数组并不会改变原始数组的方法总共有12个:</p><pre><code>ES5：forEach、every 、some、 fliter、map、reduce、reduceRight、ES6：find、findIndex、keys、values、entries</code></pre><p><strong>关于遍历：</strong></p><ul><li>尽量不要在遍历的时候，修改后面要遍历的值</li><li>尽量不要在遍历的时候修改数组的长度（删除/添加）</li></ul><p>forEach<br>定义: 按升序为数组中含有效值的每一项执行一次回调函数。</p><p>语法：</p><p><strong>array.forEach(function(currentValue, index, arr), thisValue)</strong><br>参数:</p><p>function(必须): 数组中每个元素需要调用的函数。</p><blockquote><p>// 回调函数的参数<br>\1. currentValue(必须),数组当前元素的值<br>\2. index(可选), 当前元素的索引值<br>\3. arr(可选),数组对象本身</p></blockquote><p>hisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined</p><p><strong>关于forEach()你要知道：</strong></p><ul><li>无法中途退出循环，只能用return退出本次回调，进行下一次回调。</li><li>它总是返回 undefined值,即使你return了一个值。</li></ul><p><strong>下面类似语法同样适用这些规则</strong></p><blockquote><p>\1. 对于空数组是不会执行回调函数的<br>\2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数<br>\3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。<br>\4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。</p></blockquote><p>eg:</p><pre><code>let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)let obj = &#123; name: &#39;OBKoro1&#39; &#125;;let result = a.forEach(function (value, index, array) &#123; a[3] = &#39;改变元素&#39;; a.push(&#39;添加到尾端，不会被遍历&#39;) console.log(value, &#39;forEach传递的第一个参数&#39;); // 分别打印 1 ,2 ,改变元素 console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上 // break; // break会报错 return value; // return只能结束本次回调 会执行下次回调 console.log(&#39;不会执行，因为return 会执行下一次循环回调&#39;)&#125;, obj);console.log(result); // 即使return了一个值,也还是返回undefined// 回调函数也接受接头函数写法</code></pre><p><strong>every 检测数组所有元素是否都符合判断条件</strong></p><p>定义: 方法用于检测数组所有元素是否都符合函数定义的条件</p><p>语法：</p><p><strong>array.every(function(currentValue, index, arr), thisValue)</strong><br>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><blockquote><p>// 回调函数的参数<br>\1. currentValue(必须),数组当前元素的值<br>\2. index(可选), 当前元素的索引值<br>\3. arr(可选),数组对象本身</p></blockquote><p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined</p><p>方法返回值规则:</p><ol><li>如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。</li><li>如果所有元素都满足条件，则返回 true。=</li></ol><p>eg:</p><pre><code>function isBigEnough(element, index, array) &#123; return element &gt;= 10; // 判断数组中的所有元素是否都大于10&#125;let result = [12, 5, 8, 130, 44].every(isBigEnough); // falselet result = [12, 54, 18, 130, 44].every(isBigEnough); // true// 接受箭头函数写法[12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false[12, 54, 18, 130, 44].every(x =&gt; x &gt;= 10); // true</code></pre><p><strong>some 数组中的是否有满足判断条件的元素</strong></p><p>定义：数组中的是否有满足判断条件的元素</p><p>语法：</p><p><strong>array.some(function(currentValue, index, arr), thisValue)</strong><br>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><blockquote><p>// 回调函数的参数<br>\1. currentValue(必须),数组当前元素的值<br>\2. index(可选), 当前元素的索引值<br>\3. arr(可选),数组对象本身</p></blockquote><p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined</p><p>方法返回值规则：</p><ol><li><p>如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测。</p></li><li><p>如果没有满足条件的元素，则返回false。</p><p> function isBigEnough(element, index, array) {<br>  return (element &gt;= 10); //数组中是否有一个元素大于 10<br> }<br> let result = [2, 5, 8, 1, 4].some(isBigEnough); // false<br> let result = [12, 5, 8, 1, 4].some(isBigEnough); // true</p></li></ol><p><strong>filter 过滤原始数组，返回新数组</strong></p><p>定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p><p>语法：</p><p><strong>let new_array = arr.filter(function(currentValue, index, arr), thisArg)</strong><br>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><blockquote><p>// 回调函数的参数<br>\1. currentValue(必须),数组当前元素的值<br>\2. index(可选), 当前元素的索引值<br>\3. arr(可选),数组对象本身</p></blockquote><p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined</p><p>eg:</p><pre><code>let a = [32, 33, 16, 40];let result = a.filter(function (value, index, array) &#123; return value &gt;= 18; // 返回a数组中所有大于18的元素&#125;);console.log(result,a);// [32,33,40] [32,33,16,40]</code></pre><p><strong>map 对数组中的每个元素进行处理，返回新的数组</strong></p><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><p>语法：</p><p><strong>let new_array = arr.map(function(currentValue, index, arr), thisArg)</strong><br>参数:(这几个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><blockquote><p>// 回调函数的参数<br>\1. currentValue(必须),数组当前元素的值<br>\2. index(可选), 当前元素的索引值<br>\3. arr(可选),数组对象本身</p></blockquote><p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined</p><p>eg:</p><pre><code>let a = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;];let result = a.map(function (value, index, array) &#123; return value + &#39;新数组的新元素&#39;&#125;);console.log(result, a);// [&quot;1新数组的新元素&quot;,&quot;2新数组的新元素&quot;,&quot;3新数组的新元素&quot;,&quot;4新数组的新元素&quot;] [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</code></pre><p><strong>reduce 为数组提供累加器，合并为一个值</strong></p><p>定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。</p><p>语法：</p><p><strong>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</strong><br>参数：</p><p>function(必须): 数组中每个元素需要调用的函数。</p><blockquote><p>// 回调函数的参数<br>\1. total(必须)，初始值, 或者上一次调用回调返回的值<br>\2. currentValue(必须),数组当前元素的值<br>\3. index(可选), 当前元素的索引值<br>\4. arr(可选),数组对象本身</p></blockquote><p>initialValue(可选): 指定第一次回调 的第一个参数。</p><p>回调第一次执行时:</p><ul><li>如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；</li><li>如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li><li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。</li></ul><p>eg:</p><pre><code>// 数组求和let sum = [0, 1, 2, 3].reduce(function (a, b) &#123; return a + b;&#125;, 0);// 6// 将二维数组转化为一维 将数组元素展开let flattened = [[0, 1], [2, 3], [4, 5]].reduce( (a, b) =&gt; a.concat(b), []); // [0, 1, 2, 3, 4, 5]</code></pre><p><strong>reduceRight 从右至左累加</strong></p><p>这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。</p><p><strong>ES6：find()&amp; findIndex() 根据条件找到数组成员</strong></p><p>find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。</p><p>findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><p>这两个方法</p><p>语法：</p><pre><code>let new_array = arr.find(function(currentValue, index, arr), thisArg)let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)</code></pre><p>参数:(这个方法的参数，语法都类似)</p><p>function(必须): 数组中每个元素需要调用的函数。</p><blockquote><p>// 回调函数的参数<br>\1. currentValue(必须),数组当前元素的值<br>\2. index(可选), 当前元素的索引值<br>\3. arr(可选),数组对象本身</p></blockquote><p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined</p><p>这两个方法都可以识别NaN,弥补了indexOf的不足.</p><p>eg:</p><pre><code>// findlet a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN// findIndexlet a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n)); // 返回索引4</code></pre><p>浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,</p><p><strong>ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值</strong></p><p>定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p><p>语法：</p><pre><code>array.keys()array.values()array.entries()</code></pre><p>参数：无。</p><p>遍历栗子(摘自<a href="http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values">ECMAScript 6 入门</a>)：</p><pre><code>for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123; console.log(index);&#125;// 0// 1</code></pre><p>​<br>​    for (let elem of [‘a’, ‘b’].values()) {<br>​     console.log(elem);<br>​    }<br>​    // ‘a’<br>​    // ‘b’</p><p>​<br>​    for (let [index, elem] of [‘a’, ‘b’].entries()) {<br>​     console.log(index, elem);<br>​    }<br>​    // 0 “a”<br>​    // 1 “b”</p><p>在for..of中如果遍历中途要退出，可以使用break退出循环。</p><p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历:</p><pre><code>let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];let entries = letter.entries();console.log(entries.next().value); // [0, &#39;a&#39;]console.log(entries.next().value); // [1, &#39;b&#39;]console.log(entries.next().value); // [2, &#39;c&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读须知</title>
      <link href="/2021/08/18/readingInstructions/"/>
      <url>/2021/08/18/readingInstructions/</url>
      
        <content type="html"><![CDATA[<p>内部引入音乐组件(播放器在左下角,默认不播放)</p><p>可完成基本播放器功能(播放顺序为随机播放)</p><p>播放器音量默认为0.7(修改后默认记忆模式,数据清除后恢复默认音量)</p><p>本站留言和评论功能暂时关闭</p><p>如有疑问可联系本站内置联系方式</p><p>由于部分原因,原域名已废弃,本站现重新部署,域名备案尚未完成,目前使用临时域名。图床功能已损坏,正在修复中——2023年02月17日</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组扁平化</title>
      <link href="/2021/08/18/article0/"/>
      <url>/2021/08/18/article0/</url>
      
        <content type="html"><![CDATA[<p>例：将下面数组扁平化处理。</p><p><code>const arr = [1, [2, 3, [4, 5]]] // ---&gt; [ 1, 2, 3, 4, 5 ]</code></p><h3 id="1-使用-flat"><a href="#1-使用-flat" class="headerlink" title="1.使用 flat()"></a>1.使用 flat()</h3><blockquote><p><code>flat()</code> 方法是 ES10 提出的，它会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。（flat 意为“水平的；平坦的”）</p></blockquote><pre><code>const result1 = arr.flat(Infinity) // 指定深度为无限console.log(result1) // [ 1, 2, 3, 4, 5 ]const result2 = arr.flat(1) // 指定深度为1console.log(result2) // [ 1, 2, 3, [ 4, 5 ] ]const result3 = arr.flat(2) // 指定深度为2console.log(result3) // [ 1, 2, 3, 4, 5 ]</code></pre><h3 id="2-使用正则"><a href="#2-使用正则" class="headerlink" title="2.使用正则"></a>2.使用正则</h3><ul><li><p>以下做法得到的数组元素都会变成字符串，不建议使用；</p><p>const result1 = JSON.stringify(arr).replace(/[|]/g, ‘’).split(‘,’)<br>console.log(result1) // [ ‘1’, ‘2’, ‘3’, ‘4’, ‘5’ ] 数组元素都变成了字符串</p></li><li><p>对以上方法进行优化处理；</p><p>const result2 = JSON.parse(‘[‘ + JSON.stringify(arr).replace(/[|]/g, ‘’) + ‘]’)<br>console.log(result2) // [ 1, 2, 3, 4, 5 ]</p></li></ul><h3 id="3-使用-reduce-concat"><a href="#3-使用-reduce-concat" class="headerlink" title="3.使用 reduce()+concat()"></a>3.使用 reduce()+concat()</h3><blockquote><p>使用 reduce 拿到数组的当前值和前一项值，判断当前值是否为数组，初始值设置为<code>[]</code>，然后使用 concat 进行数组合并。</p></blockquote><ul><li><p>reduce()方法：对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。</p></li><li><p>concat()方法：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p><p>function flatten(arr) {<br>return arr.reduce((pre, current) =&gt; {<br>return pre.concat(Array.isArray(current) ? flatten(current) : current)<br>}, [])<br>}</p><p>const result = flatten(arr)<br>console.log(result) // [ 1, 2, 3, 4, 5 ]</p></li></ul><h3 id="4-使用函数递归"><a href="#4-使用函数递归" class="headerlink" title="4.使用函数递归"></a>4.使用函数递归</h3><blockquote><p>循环遍历数组，发现含有数组元素就进行递归处理，最终将数组转为一维数组。</p></blockquote><pre><code>const result = []function exec(arr) &#123;  arr.forEach(item =&gt; &#123;    if (Array.isArray(item)) &#123;      exec(item)    &#125; else &#123;      result.push(item)    &#125;  &#125;)&#125;exec(arr)console.log(result) // [ 1, 2, 3, 4, 5 ]</code></pre><h3 id="5-使用扩展运算符-concat"><a href="#5-使用扩展运算符-concat" class="headerlink" title="5.使用扩展运算符+concat()"></a>5.使用扩展运算符+concat()</h3><blockquote><p>ES6 新推出的扩展运算符能对数组进行降维处理（一次降一维），循环判断是否含有数组，进行 concat 合并。</p></blockquote><ul><li><p>some()方法：测试数组中是不是至少有 1 个元素通过了被提供的函数测试（它返回的是一个 Boolean 类型的值）。</p><p>function flatten(arr) {<br>while (arr.some(item =&gt; Array.isArray(item))) {<br>arr = [].concat(…arr)<br>}</p><p>return arr<br>}</p><p>const result = flatten(arr)<br>console.log(result) // [ 1, 2, 3, 4, 5 ]</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5时钟</title>
      <link href="/2020/11/19/article5/"/>
      <url>/2020/11/19/article5/</url>
      
        <content type="html"><![CDATA[<p>Canvas：<a href="https://developer.mozilla.org/en/Canvas_tutorial%E3%80%81http://www.w3.org/TR/2dcontext/">https://developer.mozilla.org/en/Canvas_tutorial、http://www.w3.org/TR/2dcontext/</a><br>三角函数：<a href="http://zh.wikipedia.org/zh/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0">http://zh.wikipedia.org/zh/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0</a><br>JavaScript：<a href="https://developer.mozilla.org/en/JavaScript%E3%80%81http://www.w3school.com.cn/js/index.asp">https://developer.mozilla.org/en/JavaScript、http://www.w3school.com.cn/js/index.asp</a></p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;&lt;title&gt;超酷HTML5时钟(作者：http://www.cnblogs.com/jscode/)&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;    .time &#123;        text-align: center;        width:400px;        font-family: &quot;Book Antiqua&quot;,Palatino,serif;        font-size: 40px;        font-weight: bold;        text-shadow: 1px 1px 3px #333;        position:absolute;    &#125;    .time em &#123;        background: white;        position: absolute;        top: 5px;        left: 130px;        height: 18px;        width: 140px;        opacity: 0.4;    &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var canvas, context;    function DrawClock() &#123;        canvas = document.getElementById(&quot;canvas&quot;);        context = canvas.getContext(&quot;2d&quot;);        setInterval(&quot;drawbackground()&quot;, 1000);    &#125;    function drawbackground() &#123;        var radius = Math.min(canvas.width / 2, canvas.height / 2) - 15;        var centerx = canvas.width / 2;        var centery = canvas.height / 2;        context.clearRect(0, 0, canvas.width, canvas.height);        context.save();        context.lineWidth = 15;        context.fillStyle = &quot;#EFEFEF&quot;;        context.strokeStyle = &quot;#000&quot;;        context.beginPath();        context.arc(centerx, centery, radius, 0, Math.PI * 2, 0);        context.fill();        context.stroke();        context.closePath();        context.restore();        for (var i = 0; i &lt; 60; i++) &#123;            context.save();            context.fillStyle = &quot;#EFEFEF&quot;;            context.strokeStyle = &quot;#000&quot;;            if (i % 5 == 0) &#123;                context.lineWidth = 3;            &#125;            context.beginPath();            context.moveTo(centerx, centery);            context.lineTo(centerx + (radius-6) * Math.cos(i * 6 * Math.PI / 180), centery - (radius-5) * Math.sin(i * 6 * Math.PI / 180));            context.fill();            context.stroke();            context.closePath();            context.restore();        &#125;        context.moveTo(centerx, centery);        context.save();        context.fillStyle = &quot;#EFEFEF&quot;;        context.strokeStyle = &quot;#EFEFEF&quot;;        context.beginPath();        context.arc(centerx, centery, radius-15, 0, Math.PI * 2, 0);        context.fill();        context.stroke();        context.closePath();        context.restore();        var r = radius - 25;        context.font = &quot;bold 20px 宋体&quot;;        Drawtext(&quot;1&quot;, centerx + (Math.cos(60 * Math.PI / 180) * r), centery - (Math.sin(60 * Math.PI / 180) * r));        Drawtext(&quot;2&quot;, centerx + (Math.cos(30 * Math.PI / 180) * r), centery - (Math.sin(30 * Math.PI / 180) * r));        Drawtext(&quot;3&quot;, centerx + (Math.cos(0 * Math.PI / 180) * r), centery - (Math.sin(0 * Math.PI / 180) * r));        Drawtext(&quot;4&quot;, centerx + (Math.cos(330 * Math.PI / 180) * r), centery - (Math.sin(330 * Math.PI / 180) * r));        Drawtext(&quot;5&quot;, centerx + (Math.cos(300 * Math.PI / 180) * r), centery - (Math.sin(300 * Math.PI / 180) * r));        Drawtext(&quot;6&quot;, centerx + (Math.cos(270 * Math.PI / 180) * r), centery - (Math.sin(270 * Math.PI / 180) * r));        Drawtext(&quot;7&quot;, centerx + (Math.cos(240 * Math.PI / 180) * r), centery - (Math.sin(240 * Math.PI / 180) * r));        Drawtext(&quot;8&quot;, centerx + (Math.cos(210 * Math.PI / 180) * r), centery - (Math.sin(210 * Math.PI / 180) * r));        Drawtext(&quot;9&quot;, centerx + (Math.cos(180 * Math.PI / 180) * r), centery - (Math.sin(180 * Math.PI / 180) * r));        Drawtext(&quot;10&quot;, centerx + (Math.cos(150 * Math.PI / 180) * r), centery - (Math.sin(150 * Math.PI / 180) * r));        Drawtext(&quot;11&quot;, centerx + (Math.cos(120 * Math.PI / 180) * r), centery - (Math.sin(120 * Math.PI / 180) * r));        Drawtext(&quot;12&quot;, centerx + (Math.cos(90 * Math.PI / 180) * r), centery - (Math.sin(90 * Math.PI / 180) * r));        context.save();        context.fillStyle=&quot;black&quot;;        context.beginPath();        context.arc(centerx,centery,10,0,Math.PI*2,0);        context.fill();        context.stroke();        context.closePath();        context.restore();        drawpoint(centerx, centery, radius);    &#125;    function drawpoint(centerx, centery, radius) &#123;        var date = new Date();        var h = date.getHours();        h = h &lt; 13 ? h : h - 12;        var m = date.getMinutes();        var s = date.getSeconds();        var th = date.getHours() &lt; 10 ? &quot;0&quot; + date.getHours() : date.getHours();        var tm = m &lt; 10 ? &quot;0&quot; + m : m;        var ts = s &lt; 10 ? &quot;0&quot; + s : s;        document.getElementById(&quot;currtime&quot;).innerHTML = th + &quot;:&quot; + tm + &quot;:&quot; + ts;        var hr = h * 30 * Math.PI / 180 + (m / 60) * 30 * Math.PI / 180 + 90 * Math.PI / 180;        var mr = m * 6 * Math.PI / 180 + s / 60 * 6 * Math.PI / 180 + 90 * Math.PI / 180;        var sr = s * 6 * Math.PI / 180 + 90 * Math.PI / 180;        context.save();        context.lineWidth = 5;        context.fillStyle = &quot;darkgray&quot;;        context.strokeStyle = &quot;black&quot;;        context.beginPath();        context.moveTo(centerx + 20 * Math.cos(hr), centery + 20 * Math.sin(hr));        context.lineTo(centerx - (radius - 120) * Math.cos(hr), centery - (radius - 120) * Math.sin(hr));        context.moveTo(centerx + 20 * Math.cos(mr), centery + 20 * Math.sin(mr));        context.lineTo(centerx - (radius - 80) * Math.cos(mr), centery - (radius - 80) * Math.sin(mr));        context.moveTo(centerx + 20 * Math.cos(sr), centery + 20 * Math.sin(sr));        context.lineTo(centerx - (radius - 50) * Math.cos(sr), centery - (radius - 50) * Math.sin(sr));        context.closePath();        context.fill();        context.stroke();        context.restore();    &#125;    function Drawtext(text, x, y) &#123;        context.save();        x -= (context.measureText(text).width / 2);        y += 9;        context.beginPath();        context.translate(x, y);        context.fillText(text, 0, 0);        context.restore();    &#125;    window.onload = DrawClock;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;超酷HTML5时钟(作者：http://www.cnblogs.com/jscode/)&lt;/h1&gt;    &lt;canvas id=&quot;canvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt;&lt;/canvas&gt;    &lt;div class=&quot;time&quot;&gt;&lt;span id=&quot;currtime&quot;&gt;00:00:00&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>方法作用解释：</p><p>DrawClock 方法取得 Canvas 上下文</p><p>drawbackground 方法主要是画时钟的背景部分：边框、文字、刻度线</p><p>drawpoint 方法用来画时、分、秒线</p><p>Drawtext 方法是添加文字的</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
